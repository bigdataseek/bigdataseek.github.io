---
title: 7차시 9:Spring Boot
layout: single
classes: wide
categories:
  - Spring Boot
toc: true # 이 포스트에서 목차를 활성화
toc_sticky: true # 목차를 고정할지 여부 (선택 사항)
---

# 1. Spring Boot 소개
## 1. 자바 웹 개발의 과거

### 1.1 Servlet & JSP 시대
이 시기에는 자바를 사용해 웹 애플리케이션을 만들 때 **Servlet**과 **JSP (JavaServer Pages)**를 주로 사용했어요.

* **`HttpServlet` 상속, `doGet`/`doPost` 메서드 작성 → 복잡한 코드**
    * 웹 요청을 처리하는 서블릿을 만들려면, 자바 클래스가 **`javax.servlet.http.HttpServlet`** 클래스를 반드시 **상속**해야 했어요.
    * 클라이언트의 **HTTP 요청 방식(GET, POST)**에 따라 각각 **`doGet()`** 또는 **`doPost()`**와 같은 메서드를 **직접 구현**해야 했죠.
    * 이 메서드 안에서 **HTML 응답**을 만들기 위한 코드를 **직접 작성**해야 했기 때문에 코드가 매우 길고 복잡해졌어요.
    * *예시:* 웹 브라우저에 "Hello World"를 출력하기 위해 `PrintWriter`를 이용해 **HTML 태그 전체를 문자열로 출력**하는 코드를 작성해야 했습니다.

* **비즈니스 로직과 UI 코드가 섞여 유지보수 어려움**
    * 데이터베이스에서 정보를 조회하거나 계산하는 **핵심 비즈니스 로직**과, 그 결과를 웹 화면에 보여주는 **UI(HTML) 생성 코드**가 같은 서블릿 클래스 또는 JSP 파일 안에 **뒤섞여** 있었어요.
    * 결과적으로, 웹 디자인을 조금만 바꿔도 비즈니스 로직 코드를 건드려야 했고, 그 반대도 마찬가지여서 **코드의 수정과 확장이 매우 어려웠습니다.** → 이를 **'책임의 분리'**가 제대로 안 된 상태라고 합니다.

### 1.2 설정의 복잡성
개발자가 실제로 코딩하는 시간보다 애플리케이션이 돌아가도록 **환경을 설정**하는 데 더 많은 시간을 써야 했어요.

* **`web.xml`에 URL 매핑, 서블릿 등록, 필터 설정 등 수동 관리**
    * 웹 애플리케이션의 설정 파일인 **`web.xml` (Deployment Descriptor)**을 사용해서 모든 설정을 **XML 형태**로 직접 작성하고 관리해야 했습니다.
    * 특정 URL(예: `/users`)로 요청이 왔을 때 어떤 **서블릿 클래스**가 처리할지 **매핑**하는 작업, 모든 요청 전에 공통 작업을 수행할 **필터(Filter)**를 등록하는 작업 등을 전부 이 파일에 수동으로 명시해야 했죠.
    * 새로운 서블릿이나 기능을 추가할 때마다 이 파일을 수정하고 **WAS (Web Application Server, 톰캣 등)**를 재시작해야 하는 번거로움이 있었습니다.

### 1.3 개발자 경험
이 모든 과정이 개발자에게 큰 부담으로 다가왔습니다.

* **"코딩보다 설정에 더 많은 시간을 쓴다"**
    * 단순히 프로젝트를 시작하고 웹 페이지 하나를 띄우기 위해서도, **수많은 XML 설정 파일**(`web.xml`, Spring 설정 파일 등)을 만들고, **특정 라이브러리**의 버전 호환성을 맞춰야 했으며, 개발 환경(WAS)에 **수동으로 배포**하는 등 부수적인 작업이 너무 많았습니다.
    * 이러한 **번거로운 초기 설정 및 환경 세팅 작업**이 개발의 진입 장벽을 높이고 피로도를 증가시키는 주범이었어요.

## 2. Spring Framework의 등장
### 2.1 **핵심 철학:**
* “객체 간의 의존성을 **느슨하게 만들자**” (IoC, DI) ➡️ 객체들이 서로에게 **직접적으로 묶여있지 않게** 하여, 한 객체를 변경해도 다른 객체에 미치는 영향을 최소화합니다.

### 2.2 **IoC (Inversion of Control) - 제어의 역전**
* 객체 생성 및 의존성 관리를 개발자가 아닌 **프레임워크**가 담당합니다. 💡
* **구체적인 설명:** 개발자가 `new ClassName()`과 같이 직접 객체를 만들거나 다른 객체를 가져다 쓰는 순서와 방식을 **프레임워크에게 맡깁니다**. 프레임워크가 필요할 때 객체를 만들고 관리하는 **"제어권"을 가져가는 것**입니다.

### 2.3 **DI (Dependency Injection) - 의존성 주입**
* 필요한 객체(의존성)를 **외부(프레임워크)**에서 주입받습니다. 💉
* **구체적인 설명:** 예를 들어, `Service` 객체가 `Repository` 객체를 필요로 할 때, `Service` 객체가 직접 `Repository`를 생성하는 대신, **Spring 컨테이너**가 이미 만들어 둔 `Repository` 객체를 `Service` 객체에 넣어주는(주입하는) 방식입니다. 
* 이를 통해 `Service` 코드는 `Repository`를 어떻게 만들지 몰라도 되므로 **코드의 유연성**이 크게 증가합니다.

### 2.4 **AOP (Aspect-Oriented Programming) - 관점 지향 프로그래밍**
* 공통 기능(로깅, 보안, 트랜잭션 등)을 **분리**하여 코드 중복을 감소시킵니다. ✂️
* **구체적인 설명:** 여러 메서드나 클래스에서 반복적으로 사용되는 기능(예: 모든 메서드 실행 시간을 기록하는 **로깅**)을 **하나의 관점(Aspect)**으로 모듈화하여, 실제 비즈니스 로직(핵심 기능) 코드와 분리합니다. 
* 핵심 로직 코드는 **자신의 역할에만 집중**할 수 있게 됩니다.

>  **장점:** **유지보수성** (느슨한 결합 덕분에 변경 용이)과 **확장성** (새 기능 추가 용이)이 크게 향상됩니다.

>  **단점:** 초기 Spring은 **설정 복잡성**이 높았습니다. **XML 설정 파일**에 수많은 **Bean** (Spring이 관리하는 객체)을 일일이 등록하고, 여러 설정 파일들을 관리해야 했기에 **초기 개발 환경 구축에 많은 시간과 노력이 필요**했습니다. **➡️ 이 단점을 극복하기 위해 등장한 것이 바로 Spring Boot입니다!**

## 3. Spring Boot의 등장 배경

* “Spring은 좋지만, 설정이 너무 복잡하다.”

### 3.1 **개발자들이 겪은 불편함**
* **XML 기반 설정 → 환경마다 다름**: 
    *   이전의 Spring 개발에서는 데이터베이스 연결 정보, 트랜잭션 처리, 컴포넌트 스캔 범위 등을 설정하기 위해 방대한 **XML 파일**을 사용했어요. 문제는 개발, 테스트, 운영 환경마다 **다른 설정**이 필요했고, 이 많은 XML 파일을 관리하고 변경하는 것이 **시간이 오래 걸리고 오류를 유발**하기 쉬웠다는 점이에요.
* **WAS(Tomcat) 따로 설치**: 
    *   웹 애플리케이션을 실행하려면 **WAS (Web Application Server)**, 예를 들어 **Tomcat**이나 **Jetty** 같은 서버를 개발 환경에 **별도로 설치**하고 Spring 프로젝트를 이 서버에 배포하는 과정이 필요했어요. 이 과정 자체가 번거롭고, 서버 설정 관리도 복잡했습니다.
* **의존성 버전 충돌 문제**: 
    *   Spring 프로젝트는 여러 외부 라이브러리(의존성)를 사용하는데, 이 라이브러리들 간의 **호환되는 버전**을 일일이 찾아서 설정해줘야 했어요. 만약 특정 라이브러리의 버전이 다른 라이브러리와 맞지 않으면 **버전 충돌**이 발생하여 애플리케이션이 제대로 동작하지 않는 문제가 잦았습니다.

### 3.2 **Spring Boot의 목표**
* “빠르게 실행 가능한 스프링 애플리케이션 만들기”
* **설정보다 관례를 우선 (Convention over Configuration)**: 
    *   개발자가 모든 것을 **명시적으로 설정**하는 대신, **"일반적으로 이렇게 개발할 것이다"**라는 **합리적인 관례(규칙)**를 Spring Boot가 미리 정해두고 **자동으로 적용**해주는 방식을 채택했어요. 개발자는 **핵심 비즈니스 로직**에 집중하고, 복잡한 설정은 Spring Boot에 맡길 수 있게 된 거죠. 마치 **"새 차를 샀을 때 시동만 걸면 바로 운전할 수 있는"** 것처럼요.
* **자동 설정 (Auto-configuration) + 내장 서버 (Embedded Server) + 통합 의존성 관리 (Starter Dependencies)**: 
    * Spring Boot는 개발자가 겪었던 불편함을 해소하기 위해 세 가지 핵심적인 기능을 제공
    * **자동 설정**: 
        *   프로젝트에 특정 라이브러리(예: 데이터베이스 관련 라이브러리)가 추가되면, Spring Boot가 이를 인식하고 **가장 합리적인 기본 설정**을 **자동**으로 처리해줍니다. (예: `spring-boot-starter-web`을 추가하면 Spring MVC, Tomcat 등의 설정이 자동으로 완료됨).
    * **내장 서버**: 
        *   **Tomcat**이나 **Jetty** 같은 WAS가 Spring Boot 애플리케이션 안에 **포함**되어 있어요. 따라서 서버를 **별도로 설치할 필요 없이**, 프로젝트 자체를 **JAR 파일** 형태로 만들어서 바로 실행할 수 있게 되었습니다. 
    * **통합 의존성 관리**: 
        *   **Starter**라는 이름이 붙은 의존성 묶음(`spring-boot-starter-*`)을 사용해요. 이 스타터 하나만 추가하면 해당 기능에 필요한 **모든 라이브러리**와 **호환되는 버전**까지 Spring Boot가 알아서 관리해줍니다. 개발자는 버전 충돌 걱정 없이 필요한 기능의 스타터만 추가하면 돼요. 


안녕하세요! 자바 입문자분들을 위해 **Spring Boot**의 핵심 철학과 특징을 좀 더 구체적인 설명과 예시를 들어 보강해 드릴게요. Spring Boot는 복잡했던 Spring 개발 환경을 획기적으로 단순화한 도구입니다.

## 4. Spring Boot의 핵심 철학과 특징
### 4.1 주요 기능

*   **자동 설정 (Auto Configuration)** :
    *   Spring Boot는 프로젝트에 추가된 **라이브러리(JAR)**를 분석하여 개발자가 설정해야 하는 **Bean (컴포넌트)**들을 **자동으로 등록**하고 구성해줍니다.
    * 예를 들어, `spring-boot-starter-web`이 있다면 **웹 애플리케이션에 필요한 설정(DispatcherServlet 등)**을 자동으로 해줍니다. 덕분에 개발자는 **보일러 플레이트(반복적인 기본 설정)** 코드를 작성할 필요가 없어집니다. 
*   **스타터 의존성 (Starter Dependencies)**:
    *   관련 라이브러리들을 모아놓은 **"꾸러미"**입니다. 
    *  **`spring-boot-starter-web`** 하나만 추가하면, 웹 개발에 필요한 **Spring MVC, Tomcat, JSON 처리 라이브러리** 등 수십 개의 의존성을 한 번에 가져와서 **버전 충돌 없이** 관리할 수 있습니다. 개발자는 필요한 **목적(웹, 데이터베이스, 보안 등)**에 맞는 스타터만 선택하면 됩니다.
*   **내장 서버 (Embedded Tomcat)**:
    * **Tomcat, Jetty, Undertow**와 같은 웹 서버를 **별도로 설치하거나 설정**할 필요 없이, 애플리케이션 **JAR 파일** 안에 포함하여 실행합니다. 
    *   덕분에 `java -jar your-app.jar` 명령 하나로 **어디서든** 즉시 서버를 실행할 수 있어 **배포(Deployment)**가 매우 간단해집니다. 
*   **Actuator**:
    * 애플리케이션의 **"상태를 관찰하는 도구"**입니다. `/health`, `/info`, `/metrics`와 같은 **특정 HTTP 엔드포인트**를 제공하여 애플리케이션의 **헬스 체크, 환경 설정 정보, 성능 지표** 등을 **실행 중**에 확인하고 모니터링할 수 있게 해줍니다. 이는 특히 **운영 환경(Production)**에서 유용합니다.
*   **DevTools (Developer Tools)**: 
    *   개발자가 코드를 **저장(Save)**할 때마다 애플리케이션이 **자동으로 재시작**되어 변경 사항이 즉시 반영되도록 돕습니다. 
    *   서버를 수동으로 껐다 켤 필요가 없어 **개발 속도**를 획기적으로 높여줍니다. 또한, **브라우저에 대한 라이브 리로드** 기능도 일부 제공합니다. 
*   **프로퍼티 기반 설정**: 
    *   복잡한 XML 설정 대신, `application.properties` (키=값 형태) 또는 `application.yml` (계층적 구조의 YAML 형태) 파일에 **단 한 줄**로 데이터베이스 연결 정보(`spring.datasource.url=...`)나 서버 포트(`server.port=8080`)와 같은 설정을 **직관적으로** 정의할 수 있습니다. 

### 4.2 핵심 비유

*   “Spring Boot는 Spring Framework에 자동차 키트 🔑를 붙인 버전이다.
*   **Spring Framework**가 **수많은 부품(엔진, 바퀴, 차체 등)**을 직접 조립해야 하는 **DIY 키트**라면,
*   **Spring Boot**는 핵심 부품들이 **최적의 상태**로 이미 조립되어 **시동만 걸면 (실행만 하면)** 바로 달릴 수 있는 **완성형 자동차**와 같다.”
* **즉, 개발자는 자동차를 '어떻게 만들지'보다 '어디로 달릴지 (비즈니스 로직)'에만 집중**할 수 있게 됩니다.


## 5. Spring Boot 애플리케이션 구조

### 5.1 애플리케이션 구조
*   Spring Boot는 **계층화된 구조 (Layered Architecture)**로 구성되어 있으며, 이는 각 계층의 **역할을 명확히 구분**하여 **유지보수**와 **확장성**을 높입니다. 이 구조는 일반적으로 웹 애플리케이션에서 사용되는 **MVC (Model-View-Controller)** 패턴의 변형으로 이해할 수 있습니다.

```
com.example.demo
├── controller     → 요청(Request) 처리, 응답(Response) 반환
├── service        → 비즈니스 로직 수행
├── repository     → 데이터베이스 접근 (JPA, MyBatis 등)
├── model/entity   → 데이터 구조 정의 (클래스, 테이블 매핑)
└── DemoApplication.java → main() 함수 포함된 진입점
```

### 5.2 주요 패키지 및 역할 상세 설명

| 패키지 | 역할 | 상세 설명 |
| :--- | :--- | :--- |
| `controller` | **요청(Request) 처리, 응답(Response) 반환** | 클라이언트(웹 브라우저, 모바일 앱 등)의 요청을 **가장 먼저** 받아들이고, 처리 후 결과를 클라이언트에게 반환하는 역할을 합니다. 주로 **REST API의 End-point**를 정의하며, **`service` 계층을 호출**하여 비즈니스 로직을 위임합니다. `@RestController` 어노테이션이 사용됩니다. |
| `service` | **비즈니스 로직 수행** | 애플리케이션의 **핵심 기능**을 구현하는 계층입니다. `controller` 계층으로부터 전달받은 요청을 처리하기 위해 **실제 비즈니스 규칙, 연산, 데이터 가공** 등을 수행하며, **`repository` 계층을 호출**하여 데이터를 조회하거나 저장합니다. `@Service` 어노테이션이 사용됩니다. |
| `repository` | **데이터베이스 접근 (JPA, MyBatis 등)** | **데이터 영속성(Persistence)**을 담당하는 계층입니다. **데이터베이스와의 통신**을 전담하며, CRUD (Create, Read, Update, Delete) 작업을 수행합니다. 주로 **Spring Data JPA**의 `JpaRepository` 인터페이스를 상속받거나 **MyBatis**를 사용하여 구현됩니다. `@Repository` 어노테이션이 사용됩니다. |
| `model`/`entity` | **데이터 구조 정의 (클래스, 테이블 매핑)** | **데이터의 형태**를 정의하는 클래스들입니다. 데이터베이스의 **테이블과 1:1로 매핑**되는 `Entity` 클래스(JPA 사용 시)나, 계층 간 데이터 전달에 사용되는 **DTO (Data Transfer Object)** 클래스 등이 이 계층에 위치합니다. `@Entity` 어노테이션이 사용됩니다. |
| `DemoApplication.java` | **main() 함수 포함된 진입점** | Spring Boot 애플리케이션을 **실제로 구동**시키는 **시작점** 클래스입니다. 내부의 `main` 메서드가 실행되면 내장된 **Tomcat** 등의 웹 서버가 시작되고, 애플리케이션의 **자동 설정(Auto-configuration)** 및 **컴포넌트 스캔**이 이루어집니다. `@SpringBootApplication` 어노테이션이 붙어 있습니다. |

### 5.3 왜 계층화 구조를 사용할까요?

이러한 계층 구조를 사용하면 각 계층의 관심사가 분리되어 (Separation of Concerns):

1.  **높은 응집도(High Cohesion)와 낮은 결합도(Low Coupling)**를 가집니다.
2.  특정 계층의 코드가 변경되어도 다른 계층에 미치는 영향이 최소화되어 **유지보수가 용이**합니다.
3.  각 계층별로 **단위 테스트**를 작성하기가 매우 수월해집니다.


### 5.4 Spring Boot 핵심 애노테이션 및 개념 소개

*   Spring Boot는 **스프링 프레임워크**를 더 쉽고 빠르게 사용할 수 있도록 돕는 도구예요. 특히 복잡한 설정을 최소화하고, 개발에 바로 집중할 수 있게 해주는 **자동 구성(Auto-Configuration)** 기능이 핵심입니다. 아래 주요 애노테이션들을 통해 이 자동 구성 원리와 각 계층의 역할을 이해할 수 있어요.

**주요 애노테이션 정리 및 구체적 설명**

| 애노테이션 | 역할 | 구체적 설명 |
| :--- | :--- | :--- |
| **`@SpringBootApplication`** | **Spring Boot 프로젝트의 시작점** | 이 애노테이션은 다음 세 가지 핵심 기능을 **하나로** 묶어 제공하며, 이 파일이 있는 위치부터 설정 및 컴포넌트를 찾기 시작해요. <br> 1. **`@EnableAutoConfiguration`**: 클래스패스에 존재하는 라이브러리 (예: 데이터베이스, 웹 서버 등)를 분석하여 **자동으로 필요한 설정**을 해줍니다. (자동 구성) <br> 2. **`@ComponentScan`**: `@Component`, `@Service`, `@Repository`, `@Controller` 등으로 표시된 **클래스들을 찾아서** Spring Bean으로 등록해줍니다. (컴포넌트 스캔) <br> 3. **`@Configuration`**: 해당 클래스를 설정 파일로 지정합니다. |
| **`@RestController`** | **API 응답을 JSON/XML로 반환** | Spring에서 **RESTful API**를 만들 때 사용됩니다. 기존의 `@Controller`와 `@ResponseBody`의 기능을 **결합**한 형태로, 메서드의 반환 값을 **HTTP 응답 본문(Body)에 직접** 작성하도록 지정합니다. 웹 페이지(HTML)를 반환하는 대신, 주로 **JSON 형식의 데이터**를 반환할 때 쓰여요. |
| **`@Service`** | **비즈니스 로직 계층 정의** | **서비스(Service) 계층**의 클래스임을 나타냅니다. 주로 **핵심 비즈니스 로직**을 처리하며, `@Repository`를 통해 데이터를 받아 가공하거나 트랜잭션을 관리하는 역할을 수행합니다. |
| **`@Repository`** | **데이터 접근 계층 정의** | **데이터베이스(DB) 접근**을 담당하는 클래스임을 나타냅니다. 데이터를 **생성, 조회, 수정, 삭제(CRUD)** 하는 로직을 처리하며, 데이터 접근 예외를 Spring이 관리하는 **표준화된 예외**로 변환해주는 기능도 포함합니다. |
| **`@Entity`** | **DB 테이블과 매핑되는 객체 정의** | **JPA(Java Persistence API)**를 사용할 때, 해당 클래스가 **데이터베이스의 테이블**과 **1:1로 매핑되는 객체**임을 나타냅니다. 이 객체를 통해 데이터베이스의 데이터를 다룰 수 있습니다. |
| **`@Autowired`** | **의존성 주입(DI)** | Spring의 **IoC(Inversion of Control)** 컨테이너에 의해 관리되는 **Bean 객체**를 필요한 곳에 **자동으로 연결(주입)** 해주는 역할을 합니다. 개발자가 직접 객체를 생성하지 않고, Spring이 관리하는 객체를 가져와 사용할 수 있게 하여 코드의 결합도를 낮추고 유연성을 높입니다. |


### 5.5 구조와 애노테이션을 통해 Spring Boot의 “자동 구성 원리”를 직관적으로 설명

Spring Boot의 **자동 구성(Auto-Configuration)**은 다음과 같이 동작합니다.

1.  **시작점:** 
    - 프로젝트의 시작점인 `@SpringBootApplication` 애노테이션이 붙은 메인 클래스가 실행돼요.
2.  **스캔:** 
    - `@SpringBootApplication`에 포함된 `@ComponentScan` 덕분에 Spring은 프로젝트 내에서 `@Service`, `@Repository`, `@RestController` 등으로 표시된 클래스들을 자동으로 찾아 **Spring Bean**으로 등록하고 관리하기 시작합니다.
3.  **자동 설정:** 
    -   `@SpringBootApplication`에 포함된 `@EnableAutoConfiguration`은 클래스패스를 검사합니다. 
    - 예를 들어, `spring-boot-starter-web` 라이브러리가 있다면 **"웹 애플리케이션에 필요한 설정"** (예: 내장 톰캣 서버 설정)을 자동으로 해주고, `spring-boot-starter-data-jpa`가 있다면 **"데이터베이스 접근에 필요한 설정"** (예: JPA 설정)을 알아서 완료해줍니다.
4.  **연결:** 
    - 개발자는 `@Autowired`를 사용해 Spring이 관리하는 (`@Service`, `@Repository` 등으로 등록된) 객체들을 필요한 곳에 **주입**받아 사용하기만 하면 됩니다.

**결론적으로,** Spring Boot는 `@SpringBootApplication`을 중심으로 **"내가 필요한 기능을 담은 라이브러리가 있으면, 알아서 다 설정해줄게\!"** 라는 철학으로 개발자의 반복적인 초기 설정 부담을 획기적으로 줄여줍니다.


## 6. 실무 확장성과 생태계

### 6.1 **Spring Data JPA** 

* SQL 없이 객체 중심으로 DB 접근 가능하며, 이를 통해 개발자가 **반복적인 JDBC 코드 작성**을 줄이고 비즈니스 로직에 집중할 수 있게 합니다. 내부적으로 **하이버네이트(Hibernate)** 같은 **ORM(Object-Relational Mapping)** 기술을 사용하여 객체와 데이터베이스 테이블을 매핑하고, 간단한 **메소드 이름 정의**만으로 기본적인 **CRUD(Create, Read, Update, Delete) 쿼리**를 자동 생성해줍니다.
    * **예시:** `UserRepository` 인터페이스에 `findByUsername(String username)`을 정의하면, Spring Data JPA가 해당 메소드 이름에 기반하여 자동으로 SQL 쿼리를 만들어 실행합니다.

### 6.2 **Spring Security** 

* **로그인(인증 - Authentication)**, **권한(인가 - Authorization)** 기능을 통합적으로 제공하여 애플리케이션의 **보안**을 강력하게 구축할 수 있습니다. **사용자 관리, 비밀번호 암호화, 세션 관리, JWT(JSON Web Token) 기반 인증** 등 복잡하고 중요한 보안 기능을 설정 파일 몇 줄로 쉽게 적용하고 관리할 수 있게 해줍니다. **CSRF(Cross-Site Request Forgery) 방어**와 같은 웹 취약점 대응도 내장되어 있습니다.

### 6.3 **Spring Boot Actuator** 
* **운영 환경**에서 실행 중인 서버의 **상태(Metrics)**, **트래픽(HTTP 추적)**, **헬스 체크(Health Check)** 등의 **모니터링** 정보를 HTTP 엔드포인트(Endpoint)를 통해 제공합니다. 이를 통해 서버가 정상적으로 작동하는지, 메모리 사용량이나 스레드 풀 상태는 어떤지 등을 실시간으로 확인하여 **장애를 진단**하고 **성능을 최적화**하는 데 필수적으로 사용됩니다.

### 6.4 **Spring Cloud** 

* **MSA(Microservice Architecture, 마이크로서비스 아키텍처)**를 지원하는 도구들의 집합입니다. 대규모 분산 시스템을 구축할 때 필요한 **서비스 등록/발견 (Eureka)**, **설정 중앙화 (Config Server)**, **API 게이트웨이 (Gateway/Zuul)**, **로드 밸런싱**, **회로 차단기 (Circuit Breaker - Resilience4j)** 등 복잡한 **분산 환경 문제**를 해결하는 데 도움을 주어, 여러 개의 작은 서비스들이 유기적으로 협력하는 시스템을 효과적으로 구축할 수 있게 합니다.


“Spring Boot는 단순히 서버를 실행하는 도구가 아니라, **기업용 백엔드 생태계의 기반**이다.”

이처럼 Spring Boot는 단순한 웹 서버 실행을 넘어, **데이터베이스 처리, 보안, 시스템 운영 모니터링, 대규모 분산 환경 구축**에 이르기까지 **실무에서 요구되는 거의 모든 핵심 기능**을 **표준화된 방식**으로 제공하며, 개발자가 **고품질의 엔터프라이즈 애플리케이션**을 빠르고 안정적으로 개발할 수 있는 **강력한 프레임워크 생태계**를 완성합니다.


## 7. 요약 정리

이 표는 **Java 웹 개발**의 발전 과정을 보여주며, **Spring Boot**가 어떻게 생산성을 극적으로 향상시켰는지 핵심적으로 요약하고 있어요. 각 항목에 구체적인 설명을 추가하여 Spring Boot의 이점을 더 명확히 이해해 봅시다.

### 7.1  요약 정리 및 구체적 설명

| 구분 | 전통적 Java | Spring | Spring Boot |
| :--- | :--- | :--- | :--- |
| **설정 방식** | **수동(web.xml)** | **Java Config/XML** | **자동 설정 (Auto-Configuration)** |
| **구체적 설명** | 웹 애플리케이션의 구동, 서블릿 등록, 필터 설정 등을 **`web.xml`** 파일에 개발자가 일일이 명시해야 했습니다. | **XML** 파일 또는 **Java 클래스(@Configuration)**를 사용해 빈(Bean)과 의존성 주입(DI) 설정을 직접 정의했습니다. 설정이 간소화되었지만, 여전히 상당한 양의 코드가 필요했습니다. | Spring Boot가 프로젝트에 추가된 **라이브러리(JAR 파일)**를 분석하여 **가장 일반적인 설정**을 **자동으로 처리**해 줍니다. 예를 들어, `spring-boot-starter-web`을 추가하면 웹 관련 설정을 별도로 하지 않아도 됩니다. |
| **서버 실행** | **외부 Tomcat 필요** | **외부 Tomcat 필요** | **내장 Tomcat 포함 (Embedded Server)** |
| **구체적 설명** | 애플리케이션을 실행하려면 **별도의 웹 서버** (예: **Tomcat, Jetty**)를 설치하고, 애플리케이션을 WAR(Web Application Archive) 파일로 빌드하여 서버에 **배포**해야 했습니다. | 여전히 외부 서버가 필요하며, 배포 과정은 동일했습니다. 개발 및 테스트 환경 구축에 번거로움이 있었습니다. | **Tomcat, Jetty** 등의 웹 서버가 **애플리케이션 내부에 포함**되어 있어, 서버 설치나 별도 배포 과정 없이 **단독으로 실행**할 수 있습니다. 이는 개발 환경 구축을 매우 빠르고 쉽게 만듭니다. |
| **의존성 관리** | **수동 버전 지정** | **수동 버전 지정** | **Starter로 통합 관리** |
| **구체적 설명** | 필요한 모든 라이브러리(JAR)와 해당 라이브러리들이 의존하는 다른 라이브러리들의 **버전을 개발자가 직접 명시**하고 관리해야 했습니다. 버전 충돌 위험이 높았습니다. | `pom.xml` (Maven)이나 `build.gradle` (Gradle)에서 의존성을 관리했지만, **호환되는 버전 조합**을 찾는 것은 여전히 개발자의 몫이었습니다. | **Spring Boot Starter** (예: `spring-boot-starter-data-jpa`)는 특정 기능에 필요한 **모든 의존성 라이브러리**와 그들의 **호환되는 버전 정보**를 **하나로 묶어 제공**합니다. 개발자는 Starter 하나만 추가하면 됩니다. |
| **실행 명령** | **복잡한 빌드 및 배포** | **복잡한 빌드 및 배포** | **`java -jar` 한 줄로 실행** |
| **구체적 설명** | 소스코드 컴파일 후 WAR 파일로 빌드하고, 이 파일을 외부 서버의 특정 디렉토리에 **배포하는 과정**이 필요했습니다. 실행 명령이 여러 단계에 걸쳤습니다. | 빌드 과정은 복잡했고, 외부 서버에 배포한 후 서버를 재시작해야 했습니다. | 내장 서버 덕분에 빌드 결과물이 **실행 가능한 JAR** 파일 하나로 생성됩니다. 이 JAR 파일을 **`java -jar 파일명.jar`** 명령 한 줄로 어디서든 쉽게 실행할 수 있어, 배포가 매우 간결해집니다. |
| **생산성** | **낮음** | **중간** | **매우 높음** |
| **구체적 설명** | 반복적인 설정, 서버 관리, 의존성 버전 충돌 해결에 많은 시간이 소요되어 **비즈니스 로직 작성에 집중하기 어려웠습니다.** | 복잡한 설정을 XML이나 Java 코드로 줄였지만, **여전히 초기 설정 시간**이 들었습니다. | **자동 설정**, **내장 서버**, **Starter 의존성** 관리 덕분에 **"Just Run"** 할 수 있는 환경이 갖춰져 **반복적인 작업을 최소화**하고 **핵심 비즈니스 로직 개발**에 **즉시 집중**할 수 있습니다. |

###  7.2 Spring Boot가 자바 개발에 가져온 변화

*   Spring Boot는 Spring의 강력한 기능을 유지하면서도, **복잡한 초기 설정**과 **배포 과정을 대폭 간소화**하여 개발자가 **"설정보다 코드"**에 집중할 수 있도록 만들었습니다. 이는 자바 개발 환경을 **신속한 애플리케이션 개발(RAD, Rapid Application Development)**에 적합하게 변화시킨 핵심 동력입니다.

## 8. Spring Boot 시작하기
Spring Boot의 등장 배경과 구조를 이해하셨다면, 이제 **샘플 소스**를 통해 실습하며 핵심 개념을 익히는 것이 가장 좋습니다. Spring Boot를 시작하는 가장 효과적인 접근 방식 세 가지와 추천되는 다음 단계를 안내해 드립니다.

### 8.1 Spring Boot 시작을 위한 3가지 접근 방식

Spring Boot 애플리케이션의 기본 구조를 이해하고 빠르게 첫걸음을 떼기 위한 세 가지 방법을 제안합니다.

1\. 첫 번째: Spring Initializr 사용 (가장 권장)

Spring Boot 프로젝트를 생성하는 **공식적이고 표준적인 방법**입니다.

1.  **웹 인터페이스:** **[Spring Initializr](https://start.spring.io/)** 웹사이트에 접속합니다.
2.  **프로젝트 설정:**
      * **Project:** `Maven` 또는 `Gradle` 선택 (초보자는 `Maven`으로 시작하는 경우가 많습니다.)
      * **Language:** `Java` 선택
      * **Spring Boot Version:** 최신 안정화 버전 선택
      * **Metadata:** 그룹(Group)과 아티팩트(Artifact) 이름 설정
3.  **의존성 추가 (Dependencies):** 필요한 기능을 담당하는 **Starter** 라이브러리를 추가합니다.
      * 가장 기본적으로 \*\*`Spring Web`\*\*을 추가합니다. (웹 서버, REST API 개발용)
      * 데이터베이스 연결을 위해 \*\*`Spring Data JPA`\*\*나 **`H2 Database`** 등을 추가할 수 있습니다.
4.  **프로젝트 생성:** **Generate** 버튼을 눌러 ZIP 파일을 다운로드하고, 원하는 IDE(IntelliJ IDEA, Eclipse 등)에서 압축을 해제한 후 프로젝트를 엽니다.

2\. 두 번째: IDE 내장 기능 사용
*   IntelliJ IDEA나 Eclipse 같은 주요 개발 환경(IDE)은 Initializr 기능을 내장하고 있어 더 빠르게 프로젝트를 만들 수 있습니다.
* **IntelliJ IDEA (Ultimate/Community):** `File` $\rightarrow$ `New` $\rightarrow$ `Project` $\rightarrow$ 왼쪽 메뉴에서 `Spring Initializr` 선택 $\rightarrow$ 웹과 동일한 설정 진행 후 생성.

3\. 세 번째: 최소 구성 수동 작성 (권장하지 않음)

Spring Boot의 핵심 구조를 깊이 이해하고자 할 때만 시도해 볼 만합니다.

  * `pom.xml` (Maven) 또는 `build.gradle` (Gradle) 파일에 **Spring Boot 부모 프로젝트 의존성**과 **Starter 의존성**을 수동으로 추가합니다.
  * `@SpringBootApplication` 어노테이션이 붙은 **메인 클래스**와 `main` 메서드를 직접 작성하여 프로젝트의 진입점을 만듭니다.

  * Maven과 Gradle 어떤 것을 선택해야 하나?
    - Maven을 선택하면 좋은 경우
        - Spring Boot 처음 배우는 경우 (많은 튜토리얼이 Maven 기준)
        - 전통적인 Java 프로젝트
        - 회사에서 Maven을 사용하는 경우
    - Gradle을 선택하면 좋은 경우
        - 빌드 속도가 중요한 경우
        - 복잡한 빌드 스크립트가 필요한 경우
        - Android 개발
        - 최신

### 8.2 Spring Boot 핵심 구조 및 다음 단계

프로젝트를 생성하면 다음과 같은 핵심 파일과 구조를 중심으로 학습을 시작해야 합니다.

1\. 메인 애플리케이션 클래스 (진입점)

  * **파일:** `DemoApplication.java` (혹은 프로젝트 이름에 따라 다름)
  * **역할:** 프로젝트를 시작하는 진입점입니다.
      * `@SpringBootApplication`: 이 하나의 어노테이션이 **자동 설정(Auto-Configuration)**, **컴포넌트 스캔(Component Scan)**, **설정 파일 읽기** 등의 핵심 기능을 모두 활성화합니다.
      * `SpringApplication.run(DemoApplication.class, args);` : 내장 서버를 띄우고 애플리케이션을 실행합니다.

2\. 설정 파일 및 리소스

  * **파일:** `src/main/resources/application.properties` (또는 `.yml`)
  * **역할:** 데이터베이스 연결 정보, 서버 포트(기본 8080), 로깅 레벨 등 **외부 설정을 중앙 집중식으로 관리**하는 파일입니다.
      * 예시: `server.port=8888` (서버 포트를 8888로 변경)

3\. 기능 구현 (Controller)

웹 애플리케이션의 핵심 기능을 시작하는 곳입니다.

| 파일/클래스 | 어노테이션 | 역할 |
| :--- | :--- | :--- |
| `HelloController.java` | `@RestController` | HTTP 요청을 받아 처리하는 클래스입니다. |
| | `@GetMapping("/hello")` | `/hello` URL로 들어오는 GET 요청을 이 메서드와 연결합니다. |

**실습 예제 (샘플 소스):**

```java
// src/main/java/com/example/demo/HelloController.java
package com.example.demo;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController {

    @GetMapping("/hello")
    public String sayHello() {
        // 이 문자열이 HTTP 응답 본문(Body)으로 클라이언트에 전송됩니다.
        return "Hello, Spring Boot World!";
    }
}
```

4\. 다음 학습 로드맵

1.  **기본 웹 서버 실행:** Initializr로 프로젝트 생성 후, 위 예제 코드(HelloController)를 추가하고 **실행**($\text{Run}$)하여 브라우저에서 `http://localhost:8080/hello`에 접속해 봅니다.
2.  **REST API 학습:** `@GetMapping`, `@PostMapping` 등 HTTP 메서드를 이용한 기본적인 **CRUD** (생성, 읽기, 수정, 삭제) API를 구현해 봅니다.
3.  **데이터베이스 연동:** \*\*`Spring Data JPA`\*\*와 **`H2`** (인메모리 경량 DB) Starter를 추가하여 데이터베이스에 데이터를 저장하고 조회하는 기능을 구현해 봅니다.
4.  **설정 파일 활용:** `application.properties` 파일에 설정값을 넣고, `@Value` 어노테이션을 사용하여 코드 내에서 설정값을 읽어오는 연습을 합니다.


# 2. Spring Boot 사용하기

## 1. 기본 웹 서버 실행

### 1.1 프로젝트 생성
1. **Spring Initializr** 접속: https://start.spring.io/
2. 다음과 같이 설정:
   - Project: **Maven** 또는 **Gradle**
   - Language: **Java**
   - Spring Boot: **3.x.x** (최신 stable 버전)
   - Project Metadata:
     - Group: `com.example`
     - Artifact: `demo`
     - Packaging: **Jar**
     - Java: **17** 이상
   - Dependencies: **Spring Web** 선택
3. **GENERATE** 버튼 클릭하여 zip 파일 다운로드
4. 압축 해제 후 IDE(IntelliJ IDEA, Eclipse 등)로 프로젝트 열기

### 1.2 HelloController 작성

`src/main/java/com/example/demo/controller/HelloController.java` 파일 생성:

```java
package com.example.demo.controller;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController {
    
    @GetMapping("/hello")
    public String hello() {
        return "Hello, Spring Boot!";
    }
}
```

### 1.3 애플리케이션 실행
1. `src/main/java/com/example/demo/DemoApplication.java` 파일을 실행
2. 또는 터미널에서:
   ```bash
   # Maven
   ./mvnw spring-boot:run
   
   # Gradle
   ./gradlew bootRun
   ```
3. 브라우저에서 `http://localhost:8080/hello` 접속
4. "Hello, Spring Boot!" 메시지 확인

## 2. REST API 학습 (CRUD 구현)

### 2.1 User 엔티티 클래스 생성

`src/main/java/com/example/demo/model/User.java`:

```java
package com.example.demo.model;

public class User {
    private Long id;
    private String name;
    private String email;
    
    // 기본 생성자
    public User() {}
    
    // 전체 생성자
    public User(Long id, String name, String email) {
        this.id = id;
        this.name = name;
        this.email = email;
    }
    
    // Getter, Setter
    public Long getId() {
        return id;
    }
    
    public void setId(Long id) {
        this.id = id;
    }
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public String getEmail() {
        return email;
    }
    
    public void setEmail(String email) {
        this.email = email;
    }
}
```

### 2.2 UserController 생성 (CRUD API)

`src/main/java/com/example/demo/controller/UserController.java`:

```java
package com.example.demo.controller;

import com.example.demo.model.User;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

@RestController
@RequestMapping("/api/users")
public class UserController {
    
    private List<User> users = new ArrayList<>();
    private Long nextId = 1L;
    
    // CREATE - 사용자 생성
    @PostMapping
    public ResponseEntity<User> createUser(@RequestBody User user) {
        user.setId(nextId++);
        users.add(user);
        return new ResponseEntity<>(user, HttpStatus.CREATED);
    }
    
    // READ - 모든 사용자 조회
    @GetMapping
    public List<User> getAllUsers() {
        return users;
    }
    
    // READ - 특정 사용자 조회
    @GetMapping("/{id}")
    public ResponseEntity<User> getUserById(@PathVariable Long id) {
        Optional<User> user = users.stream()
            .filter(u -> u.getId().equals(id))
            .findFirst();
        
        return user.map(ResponseEntity::ok)
                   .orElse(ResponseEntity.notFound().build());
    }
    
    // UPDATE - 사용자 수정
    @PutMapping("/{id}")
    public ResponseEntity<User> updateUser(@PathVariable Long id, 
                                          @RequestBody User updatedUser) {
        for (int i = 0; i < users.size(); i++) {
            if (users.get(i).getId().equals(id)) {
                updatedUser.setId(id);
                users.set(i, updatedUser);
                return ResponseEntity.ok(updatedUser);
            }
        }
        return ResponseEntity.notFound().build();
    }
    
    // DELETE - 사용자 삭제
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteUser(@PathVariable Long id) {
        boolean removed = users.removeIf(u -> u.getId().equals(id));
        return removed ? ResponseEntity.noContent().build() 
                      : ResponseEntity.notFound().build();
    }
}
```

### 2.3 API 테스트 (Postman 또는 curl 사용)

```bash
# CREATE - 사용자 생성
curl -X POST http://localhost:8080/api/users \
  -H "Content-Type: application/json" \
  -d '{"name":"홍길동","email":"hong@example.com"}'

# READ - 모든 사용자 조회
curl http://localhost:8080/api/users

# READ - 특정 사용자 조회
curl http://localhost:8080/api/users/1

# UPDATE - 사용자 수정
curl -X PUT http://localhost:8080/api/users/1 \
  -H "Content-Type: application/json" \
  -d '{"name":"김철수","email":"kim@example.com"}'

# DELETE - 사용자 삭제
curl -X DELETE http://localhost:8080/api/users/1
```


## 3. 데이터베이스 연동 (Spring Data JPA + H2)

### 3.1 의존성 추가

**Maven** (`pom.xml`):
```xml
<dependencies>
    <!-- 기존 의존성들... -->
    
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    
    <dependency>
        <groupId>com.h2database</groupId>
        <artifactId>h2</artifactId>
        <scope>runtime</scope>
    </dependency>
</dependencies>
```

**Gradle** (`build.gradle`):
```gradle
dependencies {
    // 기존 의존성들...
    
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    runtimeOnly 'com.h2database:h2'
}
```

### 3.2 application.properties 설정

`src/main/resources/application.properties`:

```properties
# H2 Database 설정
spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=

# JPA 설정
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true

# H2 Console 활성화
spring.h2.console.enabled=true
spring.h2.console.path=/h2-console

# MySQL (운영)로 전환
#spring.datasource.url=jdbc:mysql://localhost:3306/mydb
#spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
```

### 3.3 User 엔티티 수정 (JPA 적용)

`src/main/java/com/example/demo/entity/User.java`:

```java
package com.example.demo.entity;

import jakarta.persistence.*;

@Entity
@Table(name = "users")
public class User {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String name;
    
    @Column(nullable = false, unique = true)
    private String email;
    
    // 기본 생성자
    public User() {}
    
    // 생성자
    public User(String name, String email) {
        this.name = name;
        this.email = email;
    }
    
    // Getter, Setter
    public Long getId() {
        return id;
    }
    
    public void setId(Long id) {
        this.id = id;
    }
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public String getEmail() {
        return email;
    }
    
    public void setEmail(String email) {
        this.email = email;
    }
}
```

### 3.4 UserRepository 생성

`src/main/java/com/example/demo/repository/UserRepository.java`:

```java
package com.example.demo.repository;

import com.example.demo.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByEmail(String email);
}
```

### 3.5 UserService 생성

`src/main/java/com/example/demo/service/UserService.java`:

```java
package com.example.demo.service;

import com.example.demo.entity.User;
import com.example.demo.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Optional;

@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    public User createUser(User user) {
        return userRepository.save(user);
    }
    
    public List<User> getAllUsers() {
        return userRepository.findAll();
    }
    
    public Optional<User> getUserById(Long id) {
        return userRepository.findById(id);
    }
    
    public User updateUser(Long id, User updatedUser) {
        return userRepository.findById(id)
            .map(user -> {
                user.setName(updatedUser.getName());
                user.setEmail(updatedUser.getEmail());
                return userRepository.save(user);
            })
            .orElseThrow(() -> new RuntimeException("User not found"));
    }
    
    public void deleteUser(Long id) {
        userRepository.deleteById(id);
    }
}
```

### 3.6 UserController 수정 (Service 사용)

`src/main/java/com/example/demo/controller/UserController.java`:

```java
package com.example.demo.controller;

import com.example.demo.entity.User;
import com.example.demo.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @Autowired
    private UserService userService;
    
    @PostMapping
    public ResponseEntity<User> createUser(@RequestBody User user) {
        User created = userService.createUser(user);
        return new ResponseEntity<>(created, HttpStatus.CREATED);
    }
    
    @GetMapping
    public List<User> getAllUsers() {
        return userService.getAllUsers();
    }
    
    @GetMapping("/{id}")
    public ResponseEntity<User> getUserById(@PathVariable Long id) {
        return userService.getUserById(id)
            .map(ResponseEntity::ok)
            .orElse(ResponseEntity.notFound().build());
    }
    
    @PutMapping("/{id}")
    public ResponseEntity<User> updateUser(@PathVariable Long id, 
                                          @RequestBody User user) {
        try {
            User updated = userService.updateUser(id, user);
            return ResponseEntity.ok(updated);
        } catch (RuntimeException e) {
            return ResponseEntity.notFound().build();
        }
    }
    
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteUser(@PathVariable Long id) {
        userService.deleteUser(id);
        return ResponseEntity.noContent().build();
    }
}
```

### 3.7 H2 Console 접속
1. 애플리케이션 실행 후 `http://localhost:8080/h2-console` 접속
2. JDBC URL: `jdbc:h2:mem:testdb` 입력
3. Username: `sa`, Password: 빈칸
4. Connect 버튼 클릭하여 데이터베이스 확인


## 4. 설정 파일 활용

### 4.1 application.properties에 설정값 추가

`src/main/resources/application.properties`:

```properties
# 기존 설정들...

# 커스텀 설정값
app.name=My Spring Boot Application
app.version=1.0.0
app.admin.email=admin@example.com
app.max.users=100
```

### 4.2 @Value 어노테이션으로 설정값 읽기

`src/main/java/com/example/demo/controller/ConfigController.java`:

```java
package com.example.demo.controller;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping("/api/config")
public class ConfigController {
    
    @Value("${app.name}")
    private String appName;
    
    @Value("${app.version}")
    private String appVersion;
    
    @Value("${app.admin.email}")
    private String adminEmail;
    
    @Value("${app.max.users}")
    private int maxUsers;
    
    @GetMapping
    public Map<String, Object> getConfig() {
        Map<String, Object> config = new HashMap<>();
        config.put("appName", appName);
        config.put("appVersion", appVersion);
        config.put("adminEmail", adminEmail);
        config.put("maxUsers", maxUsers);
        return config;
    }
}
```

### 4.3 @ConfigurationProperties 사용 (더 나은 방법)

`src/main/java/com/example/demo/config/AppProperties.java`:

```java
package com.example.demo.config;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

@Component
@ConfigurationProperties(prefix = "app")
public class AppProperties {
    
    private String name;
    private String version;
    private Admin admin = new Admin();
    private int maxUsers;
    
    // Getter, Setter
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public String getVersion() {
        return version;
    }
    
    public void setVersion(String version) {
        this.version = version;
    }
    
    public Admin getAdmin() {
        return admin;
    }
    
    public void setAdmin(Admin admin) {
        this.admin = admin;
    }
    
    public int getMaxUsers() {
        return maxUsers;
    }
    
    public void setMaxUsers(int maxUsers) {
        this.maxUsers = maxUsers;
    }
    
    public static class Admin {
        private String email;
        
        public String getEmail() {
            return email;
        }
        
        public void setEmail(String email) {
            this.email = email;
        }
    }
}
```

`src/main/java/com/example/demo/controller/ConfigController.java` 수정:

```java
package com.example.demo.controller;

import com.example.demo.config.AppProperties;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping("/api/config")
public class ConfigController {
    
    @Autowired
    private AppProperties appProperties;
    
    @GetMapping
    public Map<String, Object> getConfig() {
        Map<String, Object> config = new HashMap<>();
        config.put("appName", appProperties.getName());
        config.put("appVersion", appProperties.getVersion());
        config.put("adminEmail", appProperties.getAdmin().getEmail());
        config.put("maxUsers", appProperties.getMaxUsers());
        return config;
    }
}
```

### 4.4 테스트

```bash
# 설정값 조회
curl http://localhost:8080/api/config
```


## 5. 전체 프로젝트 구조

```
demo/
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   └── com/example/demo/
│   │   │       ├── DemoApplication.java
│   │   │       ├── config/
│   │   │       │   └── AppProperties.java
│   │   │       ├── controller/
│   │   │       │   ├── HelloController.java
│   │   │       │   ├── UserController.java
│   │   │       │   └── ConfigController.java
│   │   │       ├── entity/
│   │   │       │   └── User.java
│   │   │       ├── repository/
│   │   │       │   └── UserRepository.java
│   │   │       └── service/
│   │   │           └── UserService.java
│   │   └── resources/
│   │       └── application.properties
│   └── test/
└── pom.xml (또는 build.gradle)
```

이제 각 단계를 순서대로 따라하면서 Spring Boot의 기본 개념을 학습할 수 있습니다!
