---
title: 7차시 9:Spring Boot
layout: single
classes: wide
categories:
  - Spring Boot
toc: true # 이 포스트에서 목차를 활성화
toc_sticky: true # 목차를 고정할지 여부 (선택 사항)
---

# 1. Spring Boot 소개
## 1. 자바 웹 개발의 과거

### 1.1 Servlet & JSP 시대
이 시기에는 자바를 사용해 웹 애플리케이션을 만들 때 **Servlet**과 **JSP (JavaServer Pages)**를 주로 사용했어요.

* **`HttpServlet` 상속, `doGet`/`doPost` 메서드 작성 → 복잡한 코드**
    * 웹 요청을 처리하는 서블릿을 만들려면, 자바 클래스가 **`javax.servlet.http.HttpServlet`** 클래스를 반드시 **상속**해야 했어요.
    * 클라이언트의 **HTTP 요청 방식(GET, POST)**에 따라 각각 **`doGet()`** 또는 **`doPost()`**와 같은 메서드를 **직접 구현**해야 했죠.
    * 이 메서드 안에서 **HTML 응답**을 만들기 위한 코드를 **직접 작성**해야 했기 때문에 코드가 매우 길고 복잡해졌어요.
    * *예시:* 웹 브라우저에 "Hello World"를 출력하기 위해 `PrintWriter`를 이용해 **HTML 태그 전체를 문자열로 출력**하는 코드를 작성해야 했습니다.

* **비즈니스 로직과 UI 코드가 섞여 유지보수 어려움**
    * 데이터베이스에서 정보를 조회하거나 계산하는 **핵심 비즈니스 로직**과, 그 결과를 웹 화면에 보여주는 **UI(HTML) 생성 코드**가 같은 서블릿 클래스 또는 JSP 파일 안에 **뒤섞여** 있었어요.
    * 결과적으로, 웹 디자인을 조금만 바꿔도 비즈니스 로직 코드를 건드려야 했고, 그 반대도 마찬가지여서 **코드의 수정과 확장이 매우 어려웠습니다.** → 이를 **'책임의 분리'**가 제대로 안 된 상태라고 합니다.

### 1.2 설정의 복잡성
개발자가 실제로 코딩하는 시간보다 애플리케이션이 돌아가도록 **환경을 설정**하는 데 더 많은 시간을 써야 했어요.

* **`web.xml`에 URL 매핑, 서블릿 등록, 필터 설정 등 수동 관리**
    * 웹 애플리케이션의 설정 파일인 **`web.xml` (Deployment Descriptor)**을 사용해서 모든 설정을 **XML 형태**로 직접 작성하고 관리해야 했습니다.
    * 특정 URL(예: `/users`)로 요청이 왔을 때 어떤 **서블릿 클래스**가 처리할지 **매핑**하는 작업, 모든 요청 전에 공통 작업을 수행할 **필터(Filter)**를 등록하는 작업 등을 전부 이 파일에 수동으로 명시해야 했죠.
    * 새로운 서블릿이나 기능을 추가할 때마다 이 파일을 수정하고 **WAS (Web Application Server, 톰캣 등)**를 재시작해야 하는 번거로움이 있었습니다.

### 1.3 개발자 경험
이 모든 과정이 개발자에게 큰 부담으로 다가왔습니다.

* **"코딩보다 설정에 더 많은 시간을 쓴다"**
    * 단순히 프로젝트를 시작하고 웹 페이지 하나를 띄우기 위해서도, **수많은 XML 설정 파일**(`web.xml`, Spring 설정 파일 등)을 만들고, **특정 라이브러리**의 버전 호환성을 맞춰야 했으며, 개발 환경(WAS)에 **수동으로 배포**하는 등 부수적인 작업이 너무 많았습니다.
    * 이러한 **번거로운 초기 설정 및 환경 세팅 작업**이 개발의 진입 장벽을 높이고 피로도를 증가시키는 주범이었어요.

## 2. Spring Framework의 등장
### 2.1 **핵심 철학:**
* “객체 간의 의존성을 **느슨하게 만들자**” (IoC, DI) ➡️ 객체들이 서로에게 **직접적으로 묶여있지 않게** 하여, 한 객체를 변경해도 다른 객체에 미치는 영향을 최소화합니다.

### 2.2 **IoC (Inversion of Control) - 제어의 역전**
* 객체 생성 및 의존성 관리를 개발자가 아닌 **프레임워크**가 담당합니다. 💡
* **구체적인 설명:** 개발자가 `new ClassName()`과 같이 직접 객체를 만들거나 다른 객체를 가져다 쓰는 순서와 방식을 **프레임워크에게 맡깁니다**. 프레임워크가 필요할 때 객체를 만들고 관리하는 **"제어권"을 가져가는 것**입니다.

### 2.3 **DI (Dependency Injection) - 의존성 주입**
* 필요한 객체(의존성)를 **외부(프레임워크)**에서 주입받습니다. 💉
* **구체적인 설명:** 예를 들어, `Service` 객체가 `Repository` 객체를 필요로 할 때, `Service` 객체가 직접 `Repository`를 생성하는 대신, **Spring 컨테이너**가 이미 만들어 둔 `Repository` 객체를 `Service` 객체에 넣어주는(주입하는) 방식입니다. 
* 이를 통해 `Service` 코드는 `Repository`를 어떻게 만들지 몰라도 되므로 **코드의 유연성**이 크게 증가합니다.

### 2.4 **AOP (Aspect-Oriented Programming) - 관점 지향 프로그래밍**
* 공통 기능(로깅, 보안, 트랜잭션 등)을 **분리**하여 코드 중복을 감소시킵니다. ✂️
* **구체적인 설명:** 여러 메서드나 클래스에서 반복적으로 사용되는 기능(예: 모든 메서드 실행 시간을 기록하는 **로깅**)을 **하나의 관점(Aspect)**으로 모듈화하여, 실제 비즈니스 로직(핵심 기능) 코드와 분리합니다. 
* 핵심 로직 코드는 **자신의 역할에만 집중**할 수 있게 됩니다.

>  **장점:** **유지보수성** (느슨한 결합 덕분에 변경 용이)과 **확장성** (새 기능 추가 용이)이 크게 향상됩니다.

>  **단점:** 초기 Spring은 **설정 복잡성**이 높았습니다. **XML 설정 파일**에 수많은 **Bean** (Spring이 관리하는 객체)을 일일이 등록하고, 여러 설정 파일들을 관리해야 했기에 **초기 개발 환경 구축에 많은 시간과 노력이 필요**했습니다. **➡️ 이 단점을 극복하기 위해 등장한 것이 바로 Spring Boot입니다!**

## 3. Spring Boot의 등장 배경

* “Spring은 좋지만, 설정이 너무 복잡하다.”

### 3.1 **개발자들이 겪은 불편함**
* **XML 기반 설정 → 환경마다 다름**: 
    *   이전의 Spring 개발에서는 데이터베이스 연결 정보, 트랜잭션 처리, 컴포넌트 스캔 범위 등을 설정하기 위해 방대한 **XML 파일**을 사용했어요. 문제는 개발, 테스트, 운영 환경마다 **다른 설정**이 필요했고, 이 많은 XML 파일을 관리하고 변경하는 것이 **시간이 오래 걸리고 오류를 유발**하기 쉬웠다는 점이에요.
* **WAS(Tomcat) 따로 설치**: 
    *   웹 애플리케이션을 실행하려면 **WAS (Web Application Server)**, 예를 들어 **Tomcat**이나 **Jetty** 같은 서버를 개발 환경에 **별도로 설치**하고 Spring 프로젝트를 이 서버에 배포하는 과정이 필요했어요. 이 과정 자체가 번거롭고, 서버 설정 관리도 복잡했습니다.
* **의존성 버전 충돌 문제**: 
    *   Spring 프로젝트는 여러 외부 라이브러리(의존성)를 사용하는데, 이 라이브러리들 간의 **호환되는 버전**을 일일이 찾아서 설정해줘야 했어요. 만약 특정 라이브러리의 버전이 다른 라이브러리와 맞지 않으면 **버전 충돌**이 발생하여 애플리케이션이 제대로 동작하지 않는 문제가 잦았습니다.

### 3.2 **Spring Boot의 목표**
* “빠르게 실행 가능한 스프링 애플리케이션 만들기”
* **설정보다 관례를 우선 (Convention over Configuration)**: 
    *   개발자가 모든 것을 **명시적으로 설정**하는 대신, **"일반적으로 이렇게 개발할 것이다"**라는 **합리적인 관례(규칙)**를 Spring Boot가 미리 정해두고 **자동으로 적용**해주는 방식을 채택했어요. 개발자는 **핵심 비즈니스 로직**에 집중하고, 복잡한 설정은 Spring Boot에 맡길 수 있게 된 거죠. 마치 **"새 차를 샀을 때 시동만 걸면 바로 운전할 수 있는"** 것처럼요.
* **자동 설정 (Auto-configuration) + 내장 서버 (Embedded Server) + 통합 의존성 관리 (Starter Dependencies)**: 
    * Spring Boot는 개발자가 겪었던 불편함을 해소하기 위해 세 가지 핵심적인 기능을 제공
    * **자동 설정**: 
        *   프로젝트에 특정 라이브러리(예: 데이터베이스 관련 라이브러리)가 추가되면, Spring Boot가 이를 인식하고 **가장 합리적인 기본 설정**을 **자동**으로 처리해줍니다. (예: `spring-boot-starter-web`을 추가하면 Spring MVC, Tomcat 등의 설정이 자동으로 완료됨).
    * **내장 서버**: 
        *   **Tomcat**이나 **Jetty** 같은 WAS가 Spring Boot 애플리케이션 안에 **포함**되어 있어요. 따라서 서버를 **별도로 설치할 필요 없이**, 프로젝트 자체를 **JAR 파일** 형태로 만들어서 바로 실행할 수 있게 되었습니다. 
    * **통합 의존성 관리**: 
        *   **Starter**라는 이름이 붙은 의존성 묶음(`spring-boot-starter-*`)을 사용해요. 이 스타터 하나만 추가하면 해당 기능에 필요한 **모든 라이브러리**와 **호환되는 버전**까지 Spring Boot가 알아서 관리해줍니다. 개발자는 버전 충돌 걱정 없이 필요한 기능의 스타터만 추가하면 돼요. 

## 4. Spring Boot의 핵심 철학과 특징
### 4.1 주요 기능

*   **자동 설정 (Auto Configuration)** :
    *   Spring Boot는 프로젝트에 추가된 **라이브러리(JAR)**를 분석하여 개발자가 설정해야 하는 **Bean (컴포넌트)**들을 **자동으로 등록**하고 구성해줍니다.
    * 예를 들어, `spring-boot-starter-web`이 있다면 **웹 애플리케이션에 필요한 설정(DispatcherServlet 등)**을 자동으로 해줍니다. 덕분에 개발자는 **보일러 플레이트(반복적인 기본 설정)** 코드를 작성할 필요가 없어집니다. 
*   **스타터 의존성 (Starter Dependencies)**:
    *   관련 라이브러리들을 모아놓은 **"꾸러미"**입니다. 
    *  **`spring-boot-starter-web`** 하나만 추가하면, 웹 개발에 필요한 **Spring MVC, Tomcat, JSON 처리 라이브러리** 등 수십 개의 의존성을 한 번에 가져와서 **버전 충돌 없이** 관리할 수 있습니다. 개발자는 필요한 **목적(웹, 데이터베이스, 보안 등)**에 맞는 스타터만 선택하면 됩니다.
*   **내장 서버 (Embedded Tomcat)**:
    * **Tomcat, Jetty, Undertow**와 같은 웹 서버를 **별도로 설치하거나 설정**할 필요 없이, 애플리케이션 **JAR 파일** 안에 포함하여 실행합니다. 
    *   덕분에 `java -jar your-app.jar` 명령 하나로 **어디서든** 즉시 서버를 실행할 수 있어 **배포(Deployment)**가 매우 간단해집니다. 
*   **Actuator**:
    * 애플리케이션의 **"상태를 관찰하는 도구"**입니다. `/health`, `/info`, `/metrics`와 같은 **특정 HTTP 엔드포인트**를 제공하여 애플리케이션의 **헬스 체크, 환경 설정 정보, 성능 지표** 등을 **실행 중**에 확인하고 모니터링할 수 있게 해줍니다. 이는 특히 **운영 환경(Production)**에서 유용합니다.
*   **DevTools (Developer Tools)**: 
    *   개발자가 코드를 **저장(Save)**할 때마다 애플리케이션이 **자동으로 재시작**되어 변경 사항이 즉시 반영되도록 돕습니다. 
    *   서버를 수동으로 껐다 켤 필요가 없어 **개발 속도**를 획기적으로 높여줍니다. 또한, **브라우저에 대한 라이브 리로드** 기능도 일부 제공합니다. 
*   **프로퍼티 기반 설정**: 
    *   복잡한 XML 설정 대신, `application.properties` (키=값 형태) 또는 `application.yml` (계층적 구조의 YAML 형태) 파일에 **단 한 줄**로 데이터베이스 연결 정보(`spring.datasource.url=...`)나 서버 포트(`server.port=8080`)와 같은 설정을 **직관적으로** 정의할 수 있습니다. 

### 4.2 핵심 비유

*   “Spring Boot는 Spring Framework에 자동차 키트 🔑를 붙인 버전이다.
*   **Spring Framework**가 **수많은 부품(엔진, 바퀴, 차체 등)**을 직접 조립해야 하는 **DIY 키트**라면,
*   **Spring Boot**는 핵심 부품들이 **최적의 상태**로 이미 조립되어 **시동만 걸면 (실행만 하면)** 바로 달릴 수 있는 **완성형 자동차**와 같다.”
* **즉, 개발자는 자동차를 '어떻게 만들지'보다 '어디로 달릴지 (비즈니스 로직)'에만 집중**할 수 있게 됩니다.


## 5. Spring Boot 애플리케이션 구조

### 5.1 애플리케이션 구조
*   Spring Boot는 **계층화된 구조 (Layered Architecture)**로 구성되어 있으며, 이는 각 계층의 **역할을 명확히 구분**하여 **유지보수**와 **확장성**을 높입니다. 이 구조는 일반적으로 웹 애플리케이션에서 사용되는 **MVC (Model-View-Controller)** 패턴의 변형으로 이해할 수 있습니다.

```
com.example.demo
├── controller     → 요청(Request) 처리, 응답(Response) 반환
├── service        → 비즈니스 로직 수행
├── repository     → 데이터베이스 접근 (JPA, MyBatis 등)
├── model/entity   → 데이터 구조 정의 (클래스, 테이블 매핑)
└── DemoApplication.java → main() 함수 포함된 진입점
```

### 5.2 주요 패키지 및 역할 상세 설명

| 패키지 | 역할 | 상세 설명 |
| :--- | :--- | :--- |
| `controller` | **요청(Request) 처리, 응답(Response) 반환** | 클라이언트(웹 브라우저, 모바일 앱 등)의 요청을 **가장 먼저** 받아들이고, 처리 후 결과를 클라이언트에게 반환하는 역할을 합니다. 주로 **REST API의 End-point**를 정의하며, **`service` 계층을 호출**하여 비즈니스 로직을 위임합니다. `@RestController` 어노테이션이 사용됩니다. |
| `service` | **비즈니스 로직 수행** | 애플리케이션의 **핵심 기능**을 구현하는 계층입니다. `controller` 계층으로부터 전달받은 요청을 처리하기 위해 **실제 비즈니스 규칙, 연산, 데이터 가공** 등을 수행하며, **`repository` 계층을 호출**하여 데이터를 조회하거나 저장합니다. `@Service` 어노테이션이 사용됩니다. |
| `repository` | **데이터베이스 접근 (JPA, MyBatis 등)** | **데이터 영속성(Persistence)**을 담당하는 계층입니다. **데이터베이스와의 통신**을 전담하며, CRUD (Create, Read, Update, Delete) 작업을 수행합니다. 주로 **Spring Data JPA**의 `JpaRepository` 인터페이스를 상속받거나 **MyBatis**를 사용하여 구현됩니다. `@Repository` 어노테이션이 사용됩니다. |
| `model`/`entity` | **데이터 구조 정의 (클래스, 테이블 매핑)** | **데이터의 형태**를 정의하는 클래스들입니다. 데이터베이스의 **테이블과 1:1로 매핑**되는 `Entity` 클래스(JPA 사용 시)나, 계층 간 데이터 전달에 사용되는 **DTO (Data Transfer Object)** 클래스 등이 이 계층에 위치합니다. `@Entity` 어노테이션이 사용됩니다. |
| `DemoApplication.java` | **main() 함수 포함된 진입점** | Spring Boot 애플리케이션을 **실제로 구동**시키는 **시작점** 클래스입니다. 내부의 `main` 메서드가 실행되면 내장된 **Tomcat** 등의 웹 서버가 시작되고, 애플리케이션의 **자동 설정(Auto-configuration)** 및 **컴포넌트 스캔**이 이루어집니다. `@SpringBootApplication` 어노테이션이 붙어 있습니다. |

### 5.3 왜 계층화 구조를 사용할까요?

이러한 계층 구조를 사용하면 각 계층의 관심사가 분리되어 (Separation of Concerns):

1.  **높은 응집도(High Cohesion)와 낮은 결합도(Low Coupling)**를 가집니다.
2.  특정 계층의 코드가 변경되어도 다른 계층에 미치는 영향이 최소화되어 **유지보수가 용이**합니다.
3.  각 계층별로 **단위 테스트**를 작성하기가 매우 수월해집니다.


### 5.4 Spring Boot 핵심 애노테이션 및 개념 소개

*   Spring Boot는 **스프링 프레임워크**를 더 쉽고 빠르게 사용할 수 있도록 돕는 도구예요. 특히 복잡한 설정을 최소화하고, 개발에 바로 집중할 수 있게 해주는 **자동 구성(Auto-Configuration)** 기능이 핵심입니다. 아래 주요 애노테이션들을 통해 이 자동 구성 원리와 각 계층의 역할을 이해할 수 있어요.

**주요 애노테이션 정리 및 구체적 설명**

| 애노테이션 | 역할 | 구체적 설명 |
| :--- | :--- | :--- |
| **`@SpringBootApplication`** | **Spring Boot 프로젝트의 시작점** | 이 애노테이션은 다음 세 가지 핵심 기능을 **하나로** 묶어 제공하며, 이 파일이 있는 위치부터 설정 및 컴포넌트를 찾기 시작해요. <br> 1. **`@EnableAutoConfiguration`**: 클래스패스에 존재하는 라이브러리 (예: 데이터베이스, 웹 서버 등)를 분석하여 **자동으로 필요한 설정**을 해줍니다. (자동 구성) <br> 2. **`@ComponentScan`**: `@Component`, `@Service`, `@Repository`, `@Controller` 등으로 표시된 **클래스들을 찾아서** Spring Bean으로 등록해줍니다. (컴포넌트 스캔) <br> 3. **`@Configuration`**: 해당 클래스를 설정 파일로 지정합니다. |
| **`@RestController`** | **API 응답을 JSON/XML로 반환** | Spring에서 **RESTful API**를 만들 때 사용됩니다. 기존의 `@Controller`와 `@ResponseBody`의 기능을 **결합**한 형태로, 메서드의 반환 값을 **HTTP 응답 본문(Body)에 직접** 작성하도록 지정합니다. 웹 페이지(HTML)를 반환하는 대신, 주로 **JSON 형식의 데이터**를 반환할 때 쓰여요. |
| **`@Service`** | **비즈니스 로직 계층 정의** | **서비스(Service) 계층**의 클래스임을 나타냅니다. 주로 **핵심 비즈니스 로직**을 처리하며, `@Repository`를 통해 데이터를 받아 가공하거나 트랜잭션을 관리하는 역할을 수행합니다. |
| **`@Repository`** | **데이터 접근 계층 정의** | **데이터베이스(DB) 접근**을 담당하는 클래스임을 나타냅니다. 데이터를 **생성, 조회, 수정, 삭제(CRUD)** 하는 로직을 처리하며, 데이터 접근 예외를 Spring이 관리하는 **표준화된 예외**로 변환해주는 기능도 포함합니다. |
| **`@Entity`** | **DB 테이블과 매핑되는 객체 정의** | **JPA(Java Persistence API)**를 사용할 때, 해당 클래스가 **데이터베이스의 테이블**과 **1:1로 매핑되는 객체**임을 나타냅니다. 이 객체를 통해 데이터베이스의 데이터를 다룰 수 있습니다. |
| **`@Autowired`** | **의존성 주입(DI)** | Spring의 **IoC(Inversion of Control)** 컨테이너에 의해 관리되는 **Bean 객체**를 필요한 곳에 **자동으로 연결(주입)** 해주는 역할을 합니다. 개발자가 직접 객체를 생성하지 않고, Spring이 관리하는 객체를 가져와 사용할 수 있게 하여 코드의 결합도를 낮추고 유연성을 높입니다. |


### 5.5 구조와 애노테이션을 통해 Spring Boot의 “자동 구성 원리”를 직관적으로 설명

Spring Boot의 **자동 구성(Auto-Configuration)**은 다음과 같이 동작합니다.

1.  **시작점:** 
    - 프로젝트의 시작점인 `@SpringBootApplication` 애노테이션이 붙은 메인 클래스가 실행돼요.
2.  **스캔:** 
    - `@SpringBootApplication`에 포함된 `@ComponentScan` 덕분에 Spring은 프로젝트 내에서 `@Service`, `@Repository`, `@RestController` 등으로 표시된 클래스들을 자동으로 찾아 **Spring Bean**으로 등록하고 관리하기 시작합니다.
3.  **자동 설정:** 
    -   `@SpringBootApplication`에 포함된 `@EnableAutoConfiguration`은 클래스패스를 검사합니다. 
    - 예를 들어, `spring-boot-starter-web` 라이브러리가 있다면 **"웹 애플리케이션에 필요한 설정"** (예: 내장 톰캣 서버 설정)을 자동으로 해주고, `spring-boot-starter-data-jpa`가 있다면 **"데이터베이스 접근에 필요한 설정"** (예: JPA 설정)을 알아서 완료해줍니다.
4.  **연결:** 
    - 개발자는 `@Autowired`를 사용해 Spring이 관리하는 (`@Service`, `@Repository` 등으로 등록된) 객체들을 필요한 곳에 **주입**받아 사용하기만 하면 됩니다.

**결론적으로,** Spring Boot는 `@SpringBootApplication`을 중심으로 **"내가 필요한 기능을 담은 라이브러리가 있으면, 알아서 다 설정해줄게\!"** 라는 철학으로 개발자의 반복적인 초기 설정 부담을 획기적으로 줄여줍니다.


## 6. 실무 확장성과 생태계

### 6.1 **Spring Data JPA** 

* SQL 없이 객체 중심으로 DB 접근 가능하며, 이를 통해 개발자가 **반복적인 JDBC 코드 작성**을 줄이고 비즈니스 로직에 집중할 수 있게 합니다. 내부적으로 **하이버네이트(Hibernate)** 같은 **ORM(Object-Relational Mapping)** 기술을 사용하여 객체와 데이터베이스 테이블을 매핑하고, 간단한 **메소드 이름 정의**만으로 기본적인 **CRUD(Create, Read, Update, Delete) 쿼리**를 자동 생성해줍니다.
    * **예시:** `UserRepository` 인터페이스에 `findByUsername(String username)`을 정의하면, Spring Data JPA가 해당 메소드 이름에 기반하여 자동으로 SQL 쿼리를 만들어 실행합니다.

### 6.2 **Spring Security** 

* **로그인(인증 - Authentication)**, **권한(인가 - Authorization)** 기능을 통합적으로 제공하여 애플리케이션의 **보안**을 강력하게 구축할 수 있습니다. **사용자 관리, 비밀번호 암호화, 세션 관리, JWT(JSON Web Token) 기반 인증** 등 복잡하고 중요한 보안 기능을 설정 파일 몇 줄로 쉽게 적용하고 관리할 수 있게 해줍니다. **CSRF(Cross-Site Request Forgery) 방어**와 같은 웹 취약점 대응도 내장되어 있습니다.

### 6.3 **Spring Boot Actuator** 
* **운영 환경**에서 실행 중인 서버의 **상태(Metrics)**, **트래픽(HTTP 추적)**, **헬스 체크(Health Check)** 등의 **모니터링** 정보를 HTTP 엔드포인트(Endpoint)를 통해 제공합니다. 이를 통해 서버가 정상적으로 작동하는지, 메모리 사용량이나 스레드 풀 상태는 어떤지 등을 실시간으로 확인하여 **장애를 진단**하고 **성능을 최적화**하는 데 필수적으로 사용됩니다.

### 6.4 **Spring Cloud** 

* **MSA(Microservice Architecture, 마이크로서비스 아키텍처)**를 지원하는 도구들의 집합입니다. 대규모 분산 시스템을 구축할 때 필요한 **서비스 등록/발견 (Eureka)**, **설정 중앙화 (Config Server)**, **API 게이트웨이 (Gateway/Zuul)**, **로드 밸런싱**, **회로 차단기 (Circuit Breaker - Resilience4j)** 등 복잡한 **분산 환경 문제**를 해결하는 데 도움을 주어, 여러 개의 작은 서비스들이 유기적으로 협력하는 시스템을 효과적으로 구축할 수 있게 합니다.


“Spring Boot는 단순히 서버를 실행하는 도구가 아니라, **기업용 백엔드 생태계의 기반**이다.”

이처럼 Spring Boot는 단순한 웹 서버 실행을 넘어, **데이터베이스 처리, 보안, 시스템 운영 모니터링, 대규모 분산 환경 구축**에 이르기까지 **실무에서 요구되는 거의 모든 핵심 기능**을 **표준화된 방식**으로 제공하며, 개발자가 **고품질의 엔터프라이즈 애플리케이션**을 빠르고 안정적으로 개발할 수 있는 **강력한 프레임워크 생태계**를 완성합니다.


## 7. 요약 정리

이 표는 **Java 웹 개발**의 발전 과정을 보여주며, **Spring Boot**가 어떻게 생산성을 극적으로 향상시켰는지 핵심적으로 요약하고 있어요. 각 항목에 구체적인 설명을 추가하여 Spring Boot의 이점을 더 명확히 이해해 봅시다.

### 7.1  요약 정리 및 구체적 설명

| 구분 | 전통적 Java | Spring | Spring Boot |
| :--- | :--- | :--- | :--- |
| **설정 방식** | **수동(web.xml)** | **Java Config/XML** | **자동 설정 (Auto-Configuration)** |
| **구체적 설명** | 웹 애플리케이션의 구동, 서블릿 등록, 필터 설정 등을 **`web.xml`** 파일에 개발자가 일일이 명시해야 했습니다. | **XML** 파일 또는 **Java 클래스(@Configuration)**를 사용해 빈(Bean)과 의존성 주입(DI) 설정을 직접 정의했습니다. 설정이 간소화되었지만, 여전히 상당한 양의 코드가 필요했습니다. | Spring Boot가 프로젝트에 추가된 **라이브러리(JAR 파일)**를 분석하여 **가장 일반적인 설정**을 **자동으로 처리**해 줍니다. 예를 들어, `spring-boot-starter-web`을 추가하면 웹 관련 설정을 별도로 하지 않아도 됩니다. |
| **서버 실행** | **외부 Tomcat 필요** | **외부 Tomcat 필요** | **내장 Tomcat 포함 (Embedded Server)** |
| **구체적 설명** | 애플리케이션을 실행하려면 **별도의 웹 서버** (예: **Tomcat, Jetty**)를 설치하고, 애플리케이션을 WAR(Web Application Archive) 파일로 빌드하여 서버에 **배포**해야 했습니다. | 여전히 외부 서버가 필요하며, 배포 과정은 동일했습니다. 개발 및 테스트 환경 구축에 번거로움이 있었습니다. | **Tomcat, Jetty** 등의 웹 서버가 **애플리케이션 내부에 포함**되어 있어, 서버 설치나 별도 배포 과정 없이 **단독으로 실행**할 수 있습니다. 이는 개발 환경 구축을 매우 빠르고 쉽게 만듭니다. |
| **의존성 관리** | **수동 버전 지정** | **수동 버전 지정** | **Starter로 통합 관리** |
| **구체적 설명** | 필요한 모든 라이브러리(JAR)와 해당 라이브러리들이 의존하는 다른 라이브러리들의 **버전을 개발자가 직접 명시**하고 관리해야 했습니다. 버전 충돌 위험이 높았습니다. | `pom.xml` (Maven)이나 `build.gradle` (Gradle)에서 의존성을 관리했지만, **호환되는 버전 조합**을 찾는 것은 여전히 개발자의 몫이었습니다. | **Spring Boot Starter** (예: `spring-boot-starter-data-jpa`)는 특정 기능에 필요한 **모든 의존성 라이브러리**와 그들의 **호환되는 버전 정보**를 **하나로 묶어 제공**합니다. 개발자는 Starter 하나만 추가하면 됩니다. |
| **실행 명령** | **복잡한 빌드 및 배포** | **복잡한 빌드 및 배포** | **`java -jar` 한 줄로 실행** |
| **구체적 설명** | 소스코드 컴파일 후 WAR 파일로 빌드하고, 이 파일을 외부 서버의 특정 디렉토리에 **배포하는 과정**이 필요했습니다. 실행 명령이 여러 단계에 걸쳤습니다. | 빌드 과정은 복잡했고, 외부 서버에 배포한 후 서버를 재시작해야 했습니다. | 내장 서버 덕분에 빌드 결과물이 **실행 가능한 JAR** 파일 하나로 생성됩니다. 이 JAR 파일을 **`java -jar 파일명.jar`** 명령 한 줄로 어디서든 쉽게 실행할 수 있어, 배포가 매우 간결해집니다. |
| **생산성** | **낮음** | **중간** | **매우 높음** |
| **구체적 설명** | 반복적인 설정, 서버 관리, 의존성 버전 충돌 해결에 많은 시간이 소요되어 **비즈니스 로직 작성에 집중하기 어려웠습니다.** | 복잡한 설정을 XML이나 Java 코드로 줄였지만, **여전히 초기 설정 시간**이 들었습니다. | **자동 설정**, **내장 서버**, **Starter 의존성** 관리 덕분에 **"Just Run"** 할 수 있는 환경이 갖춰져 **반복적인 작업을 최소화**하고 **핵심 비즈니스 로직 개발**에 **즉시 집중**할 수 있습니다. |

###  7.2 Spring Boot가 자바 개발에 가져온 변화

*   Spring Boot는 Spring의 강력한 기능을 유지하면서도, **복잡한 초기 설정**과 **배포 과정을 대폭 간소화**하여 개발자가 **"설정보다 코드"**에 집중할 수 있도록 만들었습니다. 이는 자바 개발 환경을 **신속한 애플리케이션 개발(RAD, Rapid Application Development)**에 적합하게 변화시킨 핵심 동력입니다.

## 8. Spring Boot 시작하기
Spring Boot의 등장 배경과 구조를 이해하셨다면, 이제 **샘플 소스**를 통해 실습하며 핵심 개념을 익히는 것이 가장 좋습니다. Spring Boot를 시작하는 가장 효과적인 접근 방식 세 가지와 추천되는 다음 단계를 안내해 드립니다.

### 8.1 Spring Boot 시작을 위한 3가지 접근 방식

Spring Boot 애플리케이션의 기본 구조를 이해하고 빠르게 첫걸음을 떼기 위한 세 가지 방법을 제안합니다.

1\. 첫 번째: Spring Initializr 사용 (가장 권장)

Spring Boot 프로젝트를 생성하는 **공식적이고 표준적인 방법**입니다.

1.  **웹 인터페이스:** **[Spring Initializr](https://start.spring.io/)** 웹사이트에 접속합니다.
2.  **프로젝트 설정:**
      * **Project:** `Maven` 또는 `Gradle` 선택 (초보자는 `Maven`으로 시작하는 경우가 많습니다.)
      * **Language:** `Java` 선택
      * **Spring Boot Version:** 최신 안정화 버전 선택
      * **Metadata:** 그룹(Group)과 아티팩트(Artifact) 이름 설정
3.  **의존성 추가 (Dependencies):** 필요한 기능을 담당하는 **Starter** 라이브러리를 추가합니다.
      * 가장 기본적으로 **`Spring Web`**을 추가합니다. (웹 서버, REST API 개발용)
      * 데이터베이스 연결을 위해 **`Spring Data JPA`**나 **`H2 Database`** 등을 추가할 수 있습니다.
4.  **프로젝트 생성:** **Generate** 버튼을 눌러 ZIP 파일을 다운로드하고, 원하는 IDE(IntelliJ IDEA, Eclipse 등)에서 압축을 해제한 후 프로젝트를 엽니다.

2\. 두 번째: IDE 내장 기능 사용
*   IntelliJ IDEA나 Eclipse 같은 주요 개발 환경(IDE)은 Initializr 기능을 내장하고 있어 더 빠르게 프로젝트를 만들 수 있습니다.
* **IntelliJ IDEA (Ultimate/Community):** `File` $\rightarrow$ `New` $\rightarrow$ `Project` $\rightarrow$ 왼쪽 메뉴에서 `Spring Initializr` 선택 $\rightarrow$ 웹과 동일한 설정 진행 후 생성.

3\. 세 번째: 최소 구성 수동 작성 (권장하지 않음)

Spring Boot의 핵심 구조를 깊이 이해하고자 할 때만 시도해 볼 만합니다.

  * `pom.xml` (Maven) 또는 `build.gradle` (Gradle) 파일에 **Spring Boot 부모 프로젝트 의존성**과 **Starter 의존성**을 수동으로 추가합니다.
  * `@SpringBootApplication` 어노테이션이 붙은 **메인 클래스**와 `main` 메서드를 직접 작성하여 프로젝트의 진입점을 만듭니다.

  * Maven과 Gradle 어떤 것을 선택해야 하나?
    - Maven을 선택하면 좋은 경우
        - Spring Boot 처음 배우는 경우 (많은 튜토리얼이 Maven 기준)
        - 전통적인 Java 프로젝트
        - 회사에서 Maven을 사용하는 경우
    - Gradle을 선택하면 좋은 경우
        - 빌드 속도가 중요한 경우
        - 복잡한 빌드 스크립트가 필요한 경우
        - Android 개발
        - 최신

### 8.2 Spring Boot 핵심 구조 및 다음 단계

프로젝트를 생성하면 다음과 같은 핵심 파일과 구조를 중심으로 학습을 시작해야 합니다.

1\. 메인 애플리케이션 클래스 (진입점)

  * **파일:** `DemoApplication.java` (혹은 프로젝트 이름에 따라 다름)
  * **역할:** 프로젝트를 시작하는 진입점입니다.
      * `@SpringBootApplication`: 이 하나의 어노테이션이 **자동 설정(Auto-Configuration)**, **컴포넌트 스캔(Component Scan)**, **설정 파일 읽기** 등의 핵심 기능을 모두 활성화합니다.
      * `SpringApplication.run(DemoApplication.class, args);` : 내장 서버를 띄우고 애플리케이션을 실행합니다.

2\. 설정 파일 및 리소스

  * **파일:** `src/main/resources/application.properties` (또는 `.yml`)
  * **역할:** 데이터베이스 연결 정보, 서버 포트(기본 8080), 로깅 레벨 등 **외부 설정을 중앙 집중식으로 관리**하는 파일입니다.
      * 예시: `server.port=8888` (서버 포트를 8888로 변경)

3\. 기능 구현 (Controller)

웹 애플리케이션의 핵심 기능을 시작하는 곳입니다.

| 파일/클래스 | 어노테이션 | 역할 |
| :--- | :--- | :--- |
| `HelloController.java` | `@RestController` | HTTP 요청을 받아 처리하는 클래스입니다. |
| | `@GetMapping("/hello")` | `/hello` URL로 들어오는 GET 요청을 이 메서드와 연결합니다. |

**실습 예제 (샘플 소스):**

```java
// src/main/java/com/example/demo/HelloController.java
package com.example.demo;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController {

    @GetMapping("/hello")
    public String sayHello() {
        // 이 문자열이 HTTP 응답 본문(Body)으로 클라이언트에 전송됩니다.
        return "Hello, Spring Boot World!";
    }
}
```

4\. 다음 학습 로드맵

1.  **기본 웹 서버 실행:** Initializr로 프로젝트 생성 후, 위 예제 코드(HelloController)를 추가하고 **실행**($\text{Run}$)하여 브라우저에서 `http://localhost:8080/hello`에 접속해 봅니다.
2.  **REST API 학습:** `@GetMapping`, `@PostMapping` 등 HTTP 메서드를 이용한 기본적인 **CRUD** (생성, 읽기, 수정, 삭제) API를 구현해 봅니다.
3.  **데이터베이스 연동:** **`Spring Data JPA`**와 **`H2`** (인메모리 경량 DB) Starter를 추가하여 데이터베이스에 데이터를 저장하고 조회하는 기능을 구현해 봅니다.
4.  **설정 파일 활용:** `application.properties` 파일에 설정값을 넣고, `@Value` 어노테이션을 사용하여 코드 내에서 설정값을 읽어오는 연습을 합니다.


# 2. Spring Boot 사용하기

## 1. 기본 웹 서버 실행

### 1.1 프로젝트 생성
1. **Spring Initializr** 접속: https://start.spring.io/
2. 다음과 같이 설정:
   - Project: **Maven** 또는 **Gradle**
   - Language: **Java**
   - Spring Boot: **3.x.x** (최신 stable 버전)
   - Project Metadata:
     - Group: `com.example`
     - Artifact: `demo`
     - Packaging: **Jar**
     - Java: **17** 이상
   - Dependencies: **Spring Web** 선택
3. **GENERATE** 버튼 클릭하여 zip 파일 다운로드
4. 압축 해제 후 IDE(IntelliJ IDEA, Eclipse 등)로 프로젝트 열기

### 1.2 HelloController 작성

`src/main/java/com/example/demo/controller/HelloController.java` 파일 생성:

```java
package com.example.demo.controller;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController {
    
    @GetMapping("/hello")
    public String hello() {
        return "Hello, Spring Boot!";
    }
}
```

### 1.3 애플리케이션 실행
1. `src/main/java/com/example/demo/DemoApplication.java` 파일을 실행
2. 또는 터미널에서:
   ```bash
   # Maven
   ./mvnw spring-boot:run
   
   # Gradle
   ./gradlew bootRun
   ```
3. 브라우저에서 `http://localhost:8080/hello` 접속
4. "Hello, Spring Boot!" 메시지 확인

## 2. REST API 학습 (CRUD 구현)

### 2.1 User 엔티티 클래스 생성

`src/main/java/com/example/demo/model/User.java`:

```java
package com.example.demo.model;

public class User {
    private Long id;
    private String name;
    private String email;
    
    // 기본 생성자
    public User() {}
    
    // 전체 생성자
    public User(Long id, String name, String email) {
        this.id = id;
        this.name = name;
        this.email = email;
    }
    
    // Getter, Setter
    public Long getId() {
        return id;
    }
    
    public void setId(Long id) {
        this.id = id;
    }
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public String getEmail() {
        return email;
    }
    
    public void setEmail(String email) {
        this.email = email;
    }
}
```

### 2.2 UserController 생성 (CRUD API)

`src/main/java/com/example/demo/controller/UserController.java`:

```java
package com.example.demo.controller;

import com.example.demo.model.User;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

@RestController
@RequestMapping("/api/users")
public class UserController {
    
    private List<User> users = new ArrayList<>();
    private Long nextId = 1L;
    
    // CREATE - 사용자 생성
    @PostMapping
    public ResponseEntity<User> createUser(@RequestBody User user) {
        user.setId(nextId++);
        users.add(user);
        return new ResponseEntity<>(user, HttpStatus.CREATED);
    }
    
    // READ - 모든 사용자 조회
    @GetMapping
    public List<User> getAllUsers() {
        return users;
    }
    
    // READ - 특정 사용자 조회
    @GetMapping("/{id}")
    public ResponseEntity<User> getUserById(@PathVariable Long id) {
        Optional<User> user = users.stream()
            .filter(u -> u.getId().equals(id))
            .findFirst();
        
        return user.map(ResponseEntity::ok)
                   .orElse(ResponseEntity.notFound().build());
    }
    
    // UPDATE - 사용자 수정
    @PutMapping("/{id}")
    public ResponseEntity<User> updateUser(@PathVariable Long id, 
                                          @RequestBody User updatedUser) {
        for (int i = 0; i < users.size(); i++) {
            if (users.get(i).getId().equals(id)) {
                updatedUser.setId(id);
                users.set(i, updatedUser);
                return ResponseEntity.ok(updatedUser);
            }
        }
        return ResponseEntity.notFound().build();
    }
    
    // DELETE - 사용자 삭제
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteUser(@PathVariable Long id) {
        boolean removed = users.removeIf(u -> u.getId().equals(id));
        return removed ? ResponseEntity.noContent().build() 
                      : ResponseEntity.notFound().build();
    }
}
```

### 2.3 API 테스트 (Postman 또는 curl 사용)

```bash
# CREATE - 사용자 생성
curl -X POST http://localhost:8080/api/users \
  -H "Content-Type: application/json" \
  -d '{"name":"홍길동","email":"hong@example.com"}'

# READ - 모든 사용자 조회
curl http://localhost:8080/api/users

# READ - 특정 사용자 조회
curl http://localhost:8080/api/users/1

# UPDATE - 사용자 수정
curl -X PUT http://localhost:8080/api/users/1 \
  -H "Content-Type: application/json" \
  -d '{"name":"김철수","email":"kim@example.com"}'

# DELETE - 사용자 삭제
curl -X DELETE http://localhost:8080/api/users/1
```

### 2.4 어노테이션의 역할과 CRUD 맵핑

1\. 어노테이션은 **'역할을 지정해주는 꼬리표'**나 **'특정 업무를 담당하는 직원'**임.

| 어노테이션 | 비유 (역할) | 핵심 설명 |
| :--- | :--- | :--- |
| **`@RestController`** | **종합 안내 데스크/총괄 매니저** | "이 클래스는 **웹 API 요청(HTTP 요청)을 처리**하는 컨트롤러 역할을 할 거야. 메서드들이 바로 응답을 보낼 거야." (내부에 `@Controller`와 `@ResponseBody` 포함) |
| **`@RequestMapping("/api/users")`** | **전체 건물 주소/구역 표지판** | "이 클래스 내의 모든 메서드들은 기본적으로 **/api/users** 라는 주소로 들어오는 요청을 처리해." (기본 경로 설정) |
| **`@PostMapping`** | **'새 물건 등록' 창구** | "이 메서드는 **POST** 방식으로 들어오는 요청(새로운 데이터 생성)을 처리해." (HTTP 메서드와 매핑) |
| **`@GetMapping`** | **'물건 조회' 창구** | "이 메서드는 **GET** 방식으로 들어오는 요청(데이터 조회)을 처리해." |
| **`@PutMapping`** | **'물건 정보 수정' 창구** | "이 메서드는 **PUT** 방식으로 들어오는 요청(기존 데이터 수정/교체)을 처리해." |
| **`@DeleteMapping`** | **'물건 폐기/제거' 창구** | "이 메서드는 **DELETE** 방식으로 들어오는 요청(데이터 삭제)을 처리해." |
| **`@RequestBody`** | **택배 상자 개봉 담당** | "HTTP 요청의 **본문(Body)**에 담겨온 데이터를 **자동으로 자바 객체(User)**로 변환해줘." (JSON $\rightarrow$ Java Object) |
| **`@PathVariable Long id`** | **주소에 적힌 상세 정보 확인** | "URL 경로(예: `/api/users/10`)에 포함된 **10** 같은 값을 **추출해서 변수(id)**에 넣어줘." |
| **`ResponseEntity`** | **응답/결과 보고서** | "단순히 데이터만 돌려주는 게 아니라, **응답 데이터(Body)**와 **응답 상태 코드(Status Code)**를 함께 담아서 사용자에게 전달해주는 객체." |
| **`HttpStatus.CREATED`** | **응답 상태 스탬프** | "요청 처리가 성공했고, **새로운 리소스(데이터)가 성공적으로 생성되었음**을 의미하는 표준 코드(201)." |

2\. CRUD와 RESTful API 매핑

* **CRUD (Create, Read, Update, Delete)** 기본 개념과 해당 코드가 어떻게 웹의 표준 규칙(HTTP 메서드)에 매핑되는지 보여준다.
**웹 개발은 대부분 이 5가지 동작을 구현하는 것이다**

| CRUD 기능 | HTTP 메서드 | 주소 (URL) | 어노테이션 | 코드 라인 예시 |
| :---: | :---: | :---: | :---: | :--- |
| **C**reate (생성) | **POST** | `/api/users` | `@PostMapping` | `createUser(@RequestBody User user)` |
| **R**ead (모두 조회) | **GET** | `/api/users` | `@GetMapping` | `getAllUsers()` |
| **R**ead (하나 조회) | **GET** | `/api/users/{id}` | `@GetMapping("/{id}")` | `getUserById(@PathVariable Long id)` |
| **U**pdate (수정) | **PUT** | `/api/users/{id}` | `@PutMapping("/{id}")` | `updateUser(@PathVariable Long id, ...)` |
| **D**elete (삭제) | **DELETE** | `/api/users/{id}` | `@DeleteMapping("/{id}")` | `deleteUser(@PathVariable Long id)` |




## 3. 데이터베이스 연동 (Spring Data JPA + H2)

### 3.1 의존성 추가

**Maven** (`pom.xml`):
```xml
<dependencies>
    <!-- 기존 의존성들... -->
    
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    
    <dependency>
        <groupId>com.h2database</groupId>
        <artifactId>h2</artifactId>
        <scope>runtime</scope>
    </dependency>
</dependencies>
```

**Gradle** (`build.gradle`):
```gradle
dependencies {
    // 기존 의존성들...
    
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    runtimeOnly 'com.h2database:h2'
}
```

### 3.2 application.properties 설정

`src/main/resources/application.properties`:

```properties
# H2 Database 설정
spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=

# JPA 설정
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true

# H2 Console 활성화
spring.h2.console.enabled=true
spring.h2.console.path=/h2-console

# MySQL (운영)로 전환
#spring.datasource.url=jdbc:mysql://localhost:3306/mydb
#spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
```

**개발 및 테스트 목적으로 인메모리(In-Memory) 데이터베이스인 H2를 설정**하고, 나중에 **운영 환경의 MySQL 데이터베이스로 쉽게 전환**할 수 있도록 준비하는 것입니다.

1\. H2 Database 설정 (개발/테스트용)

*   이 설정들은 애플리케이션을 실행할 때마다 메모리(RAM)에 임시로 생성되는 **H2 데이터베이스**를 구성

| 속성 | 설명 |
| :--- | :--- |
| `spring.datasource.url=jdbc:h2:mem:testdb` | 데이터베이스 연결 URL을 지정합니다. `jdbc:h2:mem:`은 **메모리(RAM)에 데이터베이스를 생성**한다는 의미입니다. 애플리케이션이 종료되면 데이터도 사라집니다. |
| `spring.datasource.driverClassName=org.h2.Driver` | 데이터베이스와 연결하기 위한 JDBC 드라이버 클래스를 지정합니다. |
| `spring.datasource.username=sa` | 데이터베이스 접속 사용자 이름을 **`sa` (System Administrator)**로 설정합니다. |
| `spring.datasource.password=` | 데이터베이스 접속 비밀번호를 비워둡니다. (H2 인메모리 환경에서 흔히 사용) |

2\. JPA (Hibernate) 설정

*   **JPA(Java Persistence API)**의 구현체인 **Hibernate**가 데이터베이스와 상호작용하는 방식을 정의

| 속성 | 설명 |
| :--- | :--- |
| `spring.jpa.database-platform=org.hibernate.dialect.H2Dialect` | Hibernate가 H2 데이터베이스에 맞게 SQL 방언(Dialect)을 사용하도록 지정합니다. 이는 H2에 최적화된 SQL을 생성하게 합니다. |
| `spring.jpa.hibernate.ddl-auto=update` | **DDL(Data Definition Language)** 자동 실행 방식을 설정합니다. `update`는 애플리케이션 시작 시 엔티티(Java 클래스)를 기반으로 데이터베이스 **테이블을 자동으로 생성하거나 변경**합니다. (개발 단계에서 편리) |
| `spring.jpa.show-sql=true` | JPA가 실행하는 모든 **SQL 쿼리**를 콘솔에 출력하도록 설정합니다. (쿼리 디버깅 및 확인 용이) |

3\. H2 Console 활성화

*   H2 데이터베이스의 내용을 웹 브라우저를 통해 직접 확인할 수 있는 **웹 콘솔(Web Console)** 기능을 활성화

| 속성 | 설명 |
| :--- | :--- |
| `spring.h2.console.enabled=true` | H2 웹 콘솔 사용을 **활성화**합니다. |
| `spring.h2.console.path=/h2-console` | 웹 콘솔에 접근할 수 있는 URL 경로를 지정합니다. 애플리케이션 실행 후 `http://localhost:8080/h2-console` (포트가 8080일 경우)로 접속할 수 있습니다. |

4\. MySQL 전환 준비 (주석 처리됨) 

*   주석(`#`) 처리된 부분은 **운영(Production)** 환경에서 **MySQL 데이터베이스**로 전환할 때 사용하기 위해 미리 준비해 둔 설정입니다.
* H2 설정 대신 이 주석을 풀고 MySQL 정보를 입력하면, Spring Boot는 **H2 대신 MySQL에 연결**하여 애플리케이션을 실행하게 됩니다. 이는 **개발 환경과 운영 환경을 분리**하여 관리하는 일반적인 방법입니다.

5\. 데이터 흐름의 계층
*   데이터를 처리하는 단계 설명
    1.  **자바 코드 (Controller/Service):** 개발자는 **자바 객체 중심**으로 코드를 작성합니다. (예: `userRepository.save(user)`)
    2.  **JPA (규칙):** "객체를 DB에 저장한다"는 행위의 **표준 인터페이스**를 제공합니다.
    3.  **Hibernate (구현체):** JPA 요청을 받아 DB에 맞는 SQL(`INSERT INTO user...`)로 **자동 번역**합니다.
    4.  **JDBC (통신):** Hibernate가 생성한 SQL을 **H2 Database** 또는 **MySQL**로 전송하고 결과를 받아옵니다.

### 3.3 User 엔티티 수정 (JPA 적용)

`src/main/java/com/example/demo/entity/User.java`:

```java
package com.example.demo.entity;

import jakarta.persistence.*;

@Entity
@Table(name = "users")
public class User {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String name;
    
    @Column(nullable = false, unique = true)
    private String email;
    
    // 기본 생성자
    public User() {}
    
    // 생성자
    public User(String name, String email) {
        this.name = name;
        this.email = email;
    }
    
    // Getter, Setter
    public Long getId() {
        return id;
    }
    
    //id는 데이터베이스가 부여하지만 setId()여전히 필요
    //setId()가 없다면, Hibernate는 데이터베이스가 부여한 ID를 해당 자바 객체에 반영할 방법이 없어집니다.
    public void setId(Long id) {
        this.id = id;
    }
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public String getEmail() {
        return email;
    }
    
    public void setEmail(String email) {
        this.email = email;
    }
}
```

User 클래스에 JPA 필수 어노테이션 추가
* `User` 클래스를 데이터베이스의 `USER` 테이블과 연결하려면, 다음 두 가지 핵심 어노테이션을 클래스 레벨에 반드시 추가해야 합니다.

    **1\. `@Entity` (필수)**
    * **역할:** "이 자바 클래스(`User`)는 JPA가 관리하는 **엔티티(Entity)**, 즉 데이터베이스 **테이블**과 매핑되는 객체야." 라고 Spring Boot와 Hibernate에게 알려줍니다.

    **2\. `@Id` 및 `@GeneratedValue` (필수)**
    * **역할:** 엔티티에는 데이터베이스 테이블의 **기본 키(Primary Key)**에 해당하는 필드가 반드시 필요합니다.
        * **`@Id`**: 해당 필드(`id`)가 기본 키임을 지정합니다.
        * **`@GeneratedValue`**: 기본 키의 값이 데이터베이스에 의해 **자동으로 생성**되도록 설정합니다.

### 3.4 UserRepository 생성

`src/main/java/com/example/demo/repository/UserRepository.java`:

```java
package com.example.demo.repository;

import com.example.demo.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByEmail(String email);
}
```

이 인터페이스는 Spring Boot 애플리케이션에서 **User 엔티티**와 관련된 데이터베이스 작업을 처리하는 **저장소(Repository)**입니다.

| 코드 요소 | 역할 및 의미 |
| :--- | :--- |
| `package com.example.demo.repository;` | 이 파일이 `repository`라는 패키지에 속함을 나타냅니다. |
| `@Repository` | **Spring Bean**임을 표시하여, Spring이 이 인터페이스를 **데이터베이스 접근 계층**의 컴포넌트로 자동 인식하고 관리하도록 합니다. |
| `public interface UserRepository` | `UserRepository`라는 이름의 **인터페이스**를 정의합니다. 인터페이스는 기능을 **선언**만 하고 **구현**은 Spring Data JPA가 대신 해줍니다. |
| `extends JpaRepository<User, Long>` | 이 코드가 하는 **가장 중요한 역할**입니다. <br>✅ `JpaRepository`를 상속받아 **기본 CRUD 기능** (생성, 조회, 수정, 삭제)을 **자동으로 상속**받습니다. <br>✅ `<User, Long>`은 이 저장소가 **`User` 엔티티**를 다루고, 해당 엔티티의 **ID 타입이 `Long`**임을 나타냅니다. |
| `Optional<User> findByEmail(String email);` | 개발자가 **직접 정의한 쿼리 메서드**입니다. <br>Spring Data JPA가 메서드 이름(`findByEmail`)을 분석하여 자동으로 **"이메일 필드(email)로 User를 찾는 SQL 쿼리"**를 생성하고 구현해 줍니다. 반환 타입 `Optional`은 검색 결과가 있을 수도, 없을 수도 있음을 나타냅니다. |



* 요약 : `UserRepository`는 개발자가 코드를 **단 한 줄**도 작성하지 않고도 (**상속받은 메서드를 통해**) 다음과 같은 기능을 바로 사용할 수 있게 해줍니다:

  * **`save(User user)`**: 사용자 생성 및 수정
  * **`findById(Long id)`**: ID로 사용자 조회
  * **`findAll()`**: 모든 사용자 조회
  * **`delete(User user)`**: 사용자 삭제
  * **`findByEmail(String email)`**: 이메일로 사용자 조회 (직접 정의한 기능)

### 3.5 UserService 생성

`src/main/java/com/example/demo/service/UserService.java`:

```java
package com.example.demo.service;

import com.example.demo.entity.User;
import com.example.demo.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Optional;

@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    public User createUser(User user) {
        return userRepository.save(user);
    }
    
    public List<User> getAllUsers() {
        return userRepository.findAll();
    }
    
    public Optional<User> getUserById(Long id) {
        return userRepository.findById(id);
    }
    
    public User updateUser(Long id, User updatedUser) {
        return userRepository.findById(id)
            .map(user -> {
                user.setName(updatedUser.getName());
                user.setEmail(updatedUser.getEmail());
                return userRepository.save(user);
            })
            .orElseThrow(() -> new RuntimeException("User not found"));
    }
    
    public void deleteUser(Long id) {
        userRepository.deleteById(id);
    }
}
```

*   **서비스 계층(Service Layer)**을 정의하며, 애플리케이션의 **핵심 비즈니스 로직**을 담당합니다. 이 코드는 앞서 정의한 `UserRepository`를 사용하여 데이터베이스 접근 로직을 분리하고, 컨트롤러(Controller)와 데이터 접근 계층(Repository) 사이에서 **데이터를 가공하고 관리**하는 역할을 수행합니다.


*  코드의 간단 해석 (UserService)

| 코드 요소 | 역할 및 의미 |
| :--- | :--- |
| `package com.example.demo.service;` | 이 파일이 **서비스(`service`)** 패키지에 속함을 나타냅니다. |
| `@Service` | 이 클래스가 **Spring Bean**이며, **핵심 비즈니스 로직**을 담고 있는 서비스 컴포넌트임을 Spring에게 알려줍니다. |
| `@Autowired private UserRepository userRepository;` | **의존성 주입(Dependency Injection)**: Spring이 **`UserRepository` 인스턴스**를 생성하여 이 변수에 자동으로 연결해줍니다. (`UserService`가 DB 접근 기능을 사용하도록 허용) |
| `public User createUser(User user)` | **사용자 생성** 비즈니스 로직. 단순히 `userRepository`의 `save()` 메서드를 호출하여 데이터를 DB에 저장합니다. |
| `public List<User> getAllUsers()` | **모든 사용자 조회**. `userRepository.findAll()`을 호출하여 DB의 모든 사용자 목록을 가져옵니다. |
| `public Optional<User> getUserById(Long id)` | **특정 사용자 조회**. `userRepository.findById(id)`를 호출합니다. 결과가 없을 수도 있으므로 `Optional` 타입으로 반환합니다. |
| `public User updateUser(...)` | **사용자 정보 수정** 비즈니스 로직. <br>1. 먼저 ID로 기존 사용자를 찾고 (`findById(id)`). <br>2. 있다면 (`.map`), 이름과 이메일을 **수정**합니다. <br>3. 수정된 객체를 다시 저장합니다 (`save(user)`). <br>4. 없다면 (`.orElseThrow`), "User not found" 예외를 발생시킵니다. |
| `public void deleteUser(Long id)` | **사용자 삭제** 로직. `userRepository.deleteById(id)`를 호출하여 DB에서 해당 ID의 사용자를 제거합니다. |

* 서비스 계층의 존재 이유: **'역할 분리'**
*   이 `UserService`는 컨트롤러와 리포지토리 사이의 **중간 관리자** 역할을 하며, 코드가 깔끔하게 분리되고 나중에 복잡한 로직을 추가하기 쉽게 만들어줍니다.
    1.  **컨트롤러 (Controller):** 오직 **외부 요청(HTTP)**을 받고, **응답 형식**을 결정하는 역할만 합니다.
    2.  **서비스 (Service):** **"사용자를 수정하기 전에 권한이 있는지 확인한다"**와 같은 **실제 비즈니스 규칙**과 여러 데이터베이스 작업을 조합하는 복잡한 로직을 수행합니다.
    3.  **저장소 (Repository):** 오직 **데이터베이스와 직접 대화**하는 역할만 합니다 (SQL 관리).



### 3.6 UserController 수정 (Service 사용)

`src/main/java/com/example/demo/controller/UserController.java`:

```java
package com.example.demo.controller;

import com.example.demo.entity.User;
import com.example.demo.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @Autowired
    private UserService userService;
    
    @PostMapping
    public ResponseEntity<User> createUser(@RequestBody User user) {
        User created = userService.createUser(user);
        return new ResponseEntity<>(created, HttpStatus.CREATED);
    }
    
    @GetMapping
    public List<User> getAllUsers() {
        return userService.getAllUsers();
    }
    
    @GetMapping("/{id}")
    public ResponseEntity<User> getUserById(@PathVariable Long id) {
        return userService.getUserById(id)
            .map(ResponseEntity::ok)
            .orElse(ResponseEntity.notFound().build());
    }
    
    @PutMapping("/{id}")
    public ResponseEntity<User> updateUser(@PathVariable Long id, 
                                          @RequestBody User user) {
        try {
            User updated = userService.updateUser(id, user);
            return ResponseEntity.ok(updated);
        } catch (RuntimeException e) {
            return ResponseEntity.notFound().build();
        }
    }
    
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteUser(@PathVariable Long id) {
        userService.deleteUser(id);
        return ResponseEntity.noContent().build();
    }
}
```

*   **Spring Boot REST API**의 **컨트롤러 계층(Controller Layer)**을 담당하는 `UserController` 클래스입니다. 이 클래스는 **외부의 HTTP 요청을 받아들이고**, 그 요청을 **서비스 계층**으로 전달한 후, 결과를 받아 **HTTP 응답**으로 변환하여 클라이언트에게 돌려주는 역할

1\. UserController 코드 해석
*   이 컨트롤러는 `/api/users` 경로로 들어오는 모든 사용자(User) 관련 **CRUD** (생성, 조회, 수정, 삭제) 요청을 처리합니다.

| 코드 요소 | 역할 및 의미 |
| :--- | :--- |
| `@RestController` | 이 클래스가 REST API 요청을 처리하는 컨트롤러임을 선언합니다. 이 클래스의 메서드들은 자동으로 HTTP 응답 본문(Body)을 반환하게 됩니다. |
| `@RequestMapping("/api/users")` | 이 컨트롤러의 모든 메서드가 기본적으로 `/api/users`라는 **기본 URL 경로**를 사용하도록 설정합니다. |
| `@Autowired private UserService userService;` | **의존성 주입**: 비즈니스 로직을 처리하는 `UserService`의 인스턴스를 자동으로 가져와 사용합니다. 컨트롤러는 데이터 처리를 서비스에게 위임합니다. |

2\. CRUD 메서드별 해석

| 메서드 | HTTP 요청 | URL 경로 | 주요 기능 해석 |
| :--- | :--- | :--- | :--- |
| **`createUser`** | **`@PostMapping`** | `/api/users` | 1. 요청 본문(`@RequestBody`)의 JSON 데이터를 `User` 객체로 받습니다. 2. `userService.createUser`를 호출하여 **새 사용자**를 생성합니다. 3. 응답 코드 **`201 Created`**와 생성된 사용자 정보를 반환합니다. |
| **`getAllUsers`** | **`@GetMapping`** | `/api/users` | `userService.getAllUsers`를 호출하여 **모든 사용자 목록**을 조회하고 리스트를 반환합니다. (자동으로 응답 본문이 됩니다.) |
| **`getUserById`** | **`@GetMapping("/{id}")`** | `/api/users/123` | 1. URL 경로의 `id` 값(`@PathVariable`)을 받습니다. 2. `userService.getUserById`를 호출하여 사용자를 찾습니다. 3. 사용자가 있으면 **`200 OK`**와 사용자 정보를, 없으면 **`404 Not Found`**를 반환합니다. |
| **`updateUser`** | **`@PutMapping("/{id}")`** | `/api/users/123` | 1. ID와 수정할 사용자 정보(`@RequestBody`)를 받습니다. 2. `userService.updateUser`를 호출하여 사용자를 **수정**합니다. 3. 수정 성공 시 **`200 OK`**를, `User not found` 예외 발생 시 **`404 Not Found`**를 반환합니다. |
| **`deleteUser`** | **`@DeleteMapping("/{id}")`** | `/api/users/123` | 1. ID를 받아 `userService.deleteUser`를 호출하여 사용자를 **삭제**합니다. 2. 성공적으로 삭제되면 **`204 No Content`** (내용 없음) 응답을 반환합니다. |
   

3\.계층별 역할 정리 (통합)
*   이 코드는 Spring 애플리케이션의 3계층 아키텍처를 완성하며, 각 계층의 역할을 명확히 분리합니다.

    1.  **Controller (`UserController`):** 웹 요청 처리 및 응답 포맷 결정. (**API 입구**)
    2.  **Service (`UserService`):** 비즈니스 로직 및 데이터 가공/검증. (**중앙 관리자**)
    3.  **Repository (`UserRepository`):** 데이터베이스와 직접 통신. (**DB 담당자**)

### 3.7 H2 Console 접속
1. 애플리케이션 실행 후 `http://localhost:8080/h2-console` 접속
2. JDBC URL: `jdbc:h2:mem:testdb` 입력
3. Username: `sa`, Password: 빈칸
4. Connect 버튼 클릭하여 데이터베이스 확인


## 4. 설정 파일 활용

### 4.1 application.properties에 설정값 추가

`src/main/resources/application.properties`:

```properties
# 기존 설정들...

# 커스텀 설정값
app.name=My Spring Boot Application
app.version=1.0.0
app.admin.email=admin@example.com
app.max.users=100
```

*   이러한 커스텀 설정값은 주로 다음 두 가지 목적으로 사용됩니다.
    1.  **환경 분리:** 개발 환경, 테스트 환경, 운영 환경에 따라 **변경되어야 하는 값** (예: 관리자 이메일, 최대 사용자 제한 등)을 코드 외부에 분리하여 관리하기 위함입니다.
    2.  **코드 유연성:** 하드코딩(코드 안에 직접 값을 넣는 것) 대신 설정 파일에서 값을 읽어오도록 하여, 코드 변경 없이도 애플리케이션의 동작을 유연하게 조정할 수 있게 합니다.

### 4.2 @Value 어노테이션으로 설정값 읽기

`src/main/java/com/example/demo/controller/ConfigController.java`:

```java
package com.example.demo.controller;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping("/api/config")
public class ConfigController {
    
    @Value("${app.name}")
    private String appName;
    
    @Value("${app.version}")
    private String appVersion;
    
    @Value("${app.admin.email}")
    private String adminEmail;
    
    @Value("${app.max.users}")
    private int maxUsers;
    
    @GetMapping
    public Map<String, Object> getConfig() {
        Map<String, Object> config = new HashMap<>();
        config.put("appName", appName);
        config.put("appVersion", appVersion);
        config.put("adminEmail", adminEmail);
        config.put("maxUsers", maxUsers);
        return config;
    }
}
```

Spring Boot 애플리케이션의 **사용자 정의 설정값**들을 읽어와서 외부(클라이언트)에 **REST API** 형태로 제공하는 `ConfigController` 클래스입니다. 이 컨트롤러는 앞서 `application.properties` 파일에 정의했던 **커스텀 설정값**들을 가져와 JSON 형태로 반환하는 역할을 합니다.

1\.ConfigController 코드 해석

| 코드 요소 | 역할 및 의미 |
| :--- | :--- |
| `@RestController` | 이 클래스가 REST API 요청을 처리하는 컨트롤러임을 선언합니다. |
| `@RequestMapping("/api/config")` | 이 컨트롤러가 `/api/config`라는 **기본 URL 경로**로 들어오는 요청을 처리하도록 설정합니다. |
| `@Value("${...}")` | **값 주입**: `application.properties` 파일에 정의된 **커스텀 설정값**(`app.name`, `app.version` 등)을 읽어와서 해당 필드(변수)에 자동으로 넣어줍니다. |
| **`getConfig()` 메서드** | **HTTP GET 요청 처리**: `/api/config` 경로로 GET 요청이 들어오면 이 메서드가 실행됩니다. |
| `Map<String, Object> config = new HashMap<>();` | 설정값들을 담을 **Map** 객체를 생성합니다. |
| `config.put("appName", appName); ...` | `@Value`로 주입받은 모든 설정값들을 Map에 키-값 쌍으로 담습니다. |
| `return config;` | 이 Map 객체를 반환합니다. `@RestController` 덕분에 이 Map은 자동으로 **JSON 형식**으로 변환되어 HTTP 응답 본문으로 클라이언트에게 전송됩니다. |

2\.코드의 주요 목적
*   이 컨트롤러는 **애플리케이션의 설정 정보**를 외부에 노출하는 API를 제공합니다.
    1.  **설정값 읽기:** `application.properties`의 **커스텀 값**을 `@Value` 어노테이션을 사용하여 자바 변수로 쉽게 가져옵니다.
    2.  **API 노출:** 이 값들을 Map에 담아 반환함으로써, 클라이언트나 다른 시스템이 `/api/config`로 접속하여 현재 애플리케이션의 이름, 버전, 관리자 이메일 등의 **설정 정보를 JSON 형태로 확인**할 수 있게 합니다.

3\.**예상되는 HTTP 응답 (GET /api/config)**

```json
{
    "appName": "My Spring Boot Application",
    "appVersion": "1.0.0",
    "adminEmail": "admin@example.com",
    "maxUsers": 100
}
```

### 4.3 @ConfigurationProperties 사용 (더 나은 방법)

`src/main/java/com/example/demo/config/AppProperties.java`:

```java
package com.example.demo.config;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

@Component
@ConfigurationProperties(prefix = "app")
public class AppProperties {
    
    private String name;
    private String version;
    private Admin admin = new Admin();
    private int maxUsers;
    
    // Getter, Setter
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public String getVersion() {
        return version;
    }
    
    public void setVersion(String version) {
        this.version = version;
    }
    
    public Admin getAdmin() {
        return admin;
    }
    
    public void setAdmin(Admin admin) {
        this.admin = admin;
    }
    
    public int getMaxUsers() {
        return maxUsers;
    }
    
    public void setMaxUsers(int maxUsers) {
        this.maxUsers = maxUsers;
    }
    
    public static class Admin {
        private String email;
        
        public String getEmail() {
            return email;
        }
        
        public void setEmail(String email) {
            this.email = email;
        }
    }
}
```

1\.전체 개요
*   Spring Boot의 **설정 관리(Configuration Management)** 기능을 사용하여 `application.properties` 파일에 있는 **사용자 정의 설정값들을 안전하고 구조적으로 자바 객체로 불러오는 클래스**입니다.
*   이 방식을 사용하면 `@Value` 어노테이션을 여러 번 사용하는 대신, 관련된 설정들을 하나의 객체로 묶어 관리할 수 있어 코드가 훨씬 깔끔해지고 안정적입니다.

2\.AppProperties 코드 해석

| 코드 요소 | 역할 및 의미 |
| :--- | :--- |
| `@Component` | 이 클래스를 Spring의 \*\*컴포넌트(Bean)\*\*로 등록합니다. Spring 컨테이너가 이 객체를 생성하고 관리하도록 합니다. |
| `@ConfigurationProperties(prefix = "app")` | **핵심 기능**: `application.properties` 파일에서 **`app.`** 으로 시작하는 모든 속성들을 이 클래스의 필드에 **자동으로 매핑**하도록 지시합니다. |
| `private String name;` | `app.name` 속성값이 여기에 주입됩니다. |
| `private String version;` | `app.version` 속성값이 여기에 주입됩니다. |
| `private int maxUsers;` | `app.maxUsers` 속성값이 여기에 주입됩니다. |
| `private Admin admin = new Admin();` | **중첩 객체(Nested Object)**: `app.admin` 아래의 속성(예: `app.admin.email`)들을 관리하기 위한 중첩 클래스의 인스턴스입니다. |
| `public static class Admin { ... }` | `app.admin.email` 속성값을 관리하는 내부 클래스입니다. `email` 필드에 `app.admin.email` 값이 주입됩니다. |
| **Getter/Setter** | `@ConfigurationProperties`가 프로퍼티 값을 필드에 주입하려면 **Setter 메서드**가 반드시 필요합니다. 또한, 이 설정값을 다른 서비스 계층에서 사용하려면 **Getter 메서드**가 필요합니다. |

3\.`@Value` 방식과의 차이점 (사용자 관점) 💡

*   이 방식(`@ConfigurationProperties`)은 앞서 학습한 `@Value` 방식의 업그레이드 버전이라고 볼 수 있습니다.

| 구분 | `@Value` 방식 | `@ConfigurationProperties` 방식 |
| :--- | :--- | :--- |
| **사용 위치** | 각 클래스에서 개별 필드에 사용 | 설정 정보를 모아둔 **하나의 클래스**에만 사용 |
| **속성 주입** | 필드 하나당 `@Value` 어노테이션 하나 필요 | `prefix`만 지정하면 하위 속성들이 **자동으로 매핑**됨 |
| **구조** | 관련 없는 필드에 설정이 분산될 수 있음 | 계층적(`app.admin.email`) 설정을 **객체 구조**로 깔끔하게 묶을 수 있음 |
| **장점** | 간단한 설정에 유용 | 복잡하거나 많은 설정값을 **안전하고 구조적으로** 관리할 때 최적 |

<br>

`src/main/java/com/example/demo/controller/ConfigController.java` 수정:

```java
package com.example.demo.controller;

import com.example.demo.config.AppProperties;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping("/api/config")
public class ConfigController {
    
    @Autowired
    private AppProperties appProperties;
    
    @GetMapping
    public Map<String, Object> getConfig() {
        Map<String, Object> config = new HashMap<>();
        config.put("appName", appProperties.getName());
        config.put("appVersion", appProperties.getVersion());
        config.put("adminEmail", appProperties.getAdmin().getEmail());
        config.put("maxUsers", appProperties.getMaxUsers());
        return config;
    }
}
```

### 4.4 테스트

```bash
# 설정값 조회
curl http://localhost:8080/api/config
```


## 5. 전체 프로젝트 구조

```
demo/
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   └── com/example/demo/
│   │   │       ├── DemoApplication.java
│   │   │       ├── config/
│   │   │       │   └── AppProperties.java
│   │   │       ├── controller/
│   │   │       │   ├── HelloController.java
│   │   │       │   ├── UserController.java
│   │   │       │   └── ConfigController.java
│   │   │       ├── entity/
│   │   │       │   └── User.java
│   │   │       ├── repository/
│   │   │       │   └── UserRepository.java
│   │   │       └── service/
│   │   │           └── UserService.java
│   │   └── resources/
│   │       └── application.properties
│   └── test/
└── pom.xml (또는 build.gradle)
```

이제 각 단계를 순서대로 따라하면서 Spring Boot의 기본 개념을 학습할 수 있습니다!
