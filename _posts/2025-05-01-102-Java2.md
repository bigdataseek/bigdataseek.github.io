---
title: 7차시 8:Java 2
layout: single
classes: wide
categories:
  - React
toc: true # 이 포스트에서 목차를 활성화
toc_sticky: true # 목차를 고정할지 여부 (선택 사항)
---

## 2. 객체지향 프로그래밍

### 2.1 1단계: 핵심 기초 (필수)

- [ ]  객체지향 프로그래밍(OOP)

```java
// 클래스와 객체, 캡슐화, 상속, 다형성, 추상화 예제

// 추상화 예시 (Animal 클래스)
abstract class Animal {
    private String name; // 캡슐화
    
    public Animal(String name) {
        this.name = name;
    }

    public String getName() { // Getter
        return name;
    }

    // 추상 메서드
    public abstract void makeSound();
}

// 상속 및 다형성
class Dog extends Animal {
    public Dog(String name) {
        super(name);
    }

    @Override
    public void makeSound() { // 메서드 오버라이딩
        System.out.println(getName() + " says: Woof!");
    }
}

class Cat extends Animal {
    public Cat(String name) {
        super(name);
    }

    @Override
    public void makeSound() {
        System.out.println(getName() + " says: Meow!");
    }
}

public class OOPExample {
    public static void main(String[] args) {
        Animal dog = new Dog("Buddy");
        Animal cat = new Cat("Luna");

        dog.makeSound();
        cat.makeSound();
    }
}
```

1.**추상화 (Abstraction)**
- **정의**: 복잡한 시스템에서 불필요한 세부사항을 숨기고, 핵심적인 특성이나 동작만을 외부에 노출하는 원리.
- **코드 적용**: `Animal` 클래스가 `abstract`로 선언되어 있으며, 구체적인 동작(`makeSound()`)은 하위 클래스에 위임함.  
  → 사용자는 `Animal` 타입의 객체가 어떻게 소리를 내는지 알 필요 없이, `makeSound()` 메서드만 호출하면 됨.

2.**캡슐화 (Encapsulation)**
- **정의**: 객체의 내부 상태(데이터)와 동작(메서드)을 하나의 단위로 묶고, 외부로부터 직접 접근을 제한하여 데이터 무결성을 보장하는 원리.
- **코드 적용**: `name` 필드가 `private`으로 선언되어 외부 접근이 차단되고, `public` getter 메서드(`getName()`)를 통해 제한된 방식으로만 접근 가능.

3.**상속 (Inheritance)**
- **정의**: 기존 클래스(부모/슈퍼클래스)의 속성과 메서드를 새로운 클래스(자식/서브클래스)가 물려받아 재사용하고 확장하는 메커니즘.
- **코드 적용**: `Dog`와 `Cat` 클래스가 `Animal` 클래스를 `extends`하여 `name` 필드와 `getName()` 메서드를 상속받음.

4.**다형성 (Polymorphism)**
- **정의**: 동일한 인터페이스(또는 부모 타입)를 통해 서로 다른 구현(자식 클래스)을 가진 객체들이 각기 다른 동작을 수행할 수 있는 능력.
- **코드 적용**:  
  - `Animal dog = new Dog("Buddy");`  
  - `Animal cat = new Cat("Luna");`  
  → 동일한 `Animal` 타입 변수를 사용하지만, 실제 실행 시점에 각 객체의 **구체적인 타입에 따라 다른 `makeSound()` 메서드가 동적으로 호출됨** (동적 바인딩 / 런타임 다형성).

5.**추상 클래스와 추상 메서드 (Abstract Class & Abstract Method)**
- **정의**:  
  - **추상 클래스**: 인스턴스화될 수 없으며, 공통된 구조를 정의하고 하위 클래스에 구현을 강제하기 위한 설계 도구.  
  - **추상 메서드**: 본문 없이 선언만 존재하며, 하위 클래스에서 반드시 구현되어야 하는 메서드.
- **코드 적용**: `Animal`은 추상 클래스이며, `makeSound()`는 추상 메서드로 선언되어 `Dog`와 `Cat`이 각각 구현하도록 강제함.



- [ ]  생성자와 메서드

```java
class Person {
    String name;
    int age;

    // 기본 생성자
    public Person() {
        this("Unknown", 0);
    }

    // 생성자 오버로딩
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // 메서드 오버로딩
    public void greet() {
        System.out.println("Hello!");
    }

    public void greet(String message) {
        System.out.println(message + ", I'm " + name);
    }
}

public class ConstructorExample {
    public static void main(String[] args) {
        Person p1 = new Person();
        Person p2 = new Person("Alice", 25);

        p1.greet();
        p2.greet("Nice to meet you");
    }
}
```

1.**생성자(Constructor)**
- 객체가 생성될 때 자동으로 호출되는 특수한 메서드.
- 클래스 이름과 동일하며 반환 타입이 없음.
- 객체 초기화를 담당하며, 멤버 변수에 초기 값을 할당할 수 있음.

2.**기본 생성자(Default Constructor)**
- 매개변수가 없는 생성자.
- 사용자가 생성자를 하나도 정의하지 않으면 컴파일러가 자동으로 제공하지만,  
  사용자가 하나라도 정의하면 컴파일러는 기본 생성자를 자동으로 제공하지 않음.
- 이 코드에서는 명시적으로 기본 생성자를 정의하고 있음.

3.**생성자 오버로딩(Constructor Overloading)**
- 동일한 클래스 내에서 **매개변수의 타입, 개수, 순서가 다른 여러 생성자**를 정의하는 것.
- 정적 다형성(Static Polymorphism)의 한 형태로, **컴파일 타임에 결정**됨.
- `Person()`과 `Person(String name, int age)`는 동일한 이름이지만 시그니처가 달라 오버로딩됨.

4.**this()를 이용한 생성자 간 위임(Constructor Chaining)**
- 한 생성자에서 다른 생성자를 호출하여 코드 중복을 줄이는 기법.
- 반드시 **생성자의 첫 번째 문장**에서만 사용 가능.
- 여기서는 기본 생성자에서 `this("Unknown", 0)`을 호출하여 매개변수 있는 생성자로 위임.

5.**메서드 오버로딩(Method Overloading)**
- 동일한 클래스 내에서 **메서드 이름은 같지만 매개변수 목록이 다른 여러 메서드**를 정의하는 것.
- 반환 타입은 오버로딩의 기준이 되지 않음.
- `greet()`와 `greet(String message)`는 시그니처가 달라 오버로딩됨.
- 역시 **정적 다형성**의 예로, 컴파일 시점에 호출할 메서드가 결정됨.

6.**정적 다형성(Static Polymorphism) / 컴파일 타임 바인딩**
- 오버로딩(생성자 및 메서드)은 메서드 시그니처에 따라 컴파일러가 호출할 메서드를 결정함.
- 실행 시점이 아닌 **컴파일 시점에 바인딩**되므로 정적 다형성이라 함.


### 2.2 2단계: 중요 기본 개념

- [ ]   인터페이스

```java
interface Vehicle {
    void move();
}

class Car implements Vehicle {
    public void move() {
        System.out.println("Car is moving");
    }
}

class Bicycle implements Vehicle {
    public void move() {
        System.out.println("Bicycle is moving");
    }
}

public class InterfaceExample {
    public static void main(String[] args) {
        Vehicle car = new Car();
        Vehicle bike = new Bicycle();

        car.move();
        bike.move();
    }
}
```

1.**인터페이스 (Interface)**
- **정의**: 인터페이스는 객체가 어떤 동작(메서드)을 수행할 수 있는지를 명세하는 **계약**(contract)이다.
- **이론적 기반**:  
  - **추상화**(Abstraction): 인터페이스는 구현 세부사항을 숨기고, 외부에 노출할 동작만 정의함으로써 추상화를 구현한다.  
  - **다형성 지원**: 인터페이스를 통해 서로 다른 클래스가 동일한 메서드 시그니처를 구현할 수 있게 하여, 다형성을 가능하게 한다.

2.**다형성**(Polymorphism)
- **정의**: 하나의 인터페이스를 통해 다양한 형태의 객체를 처리할 수 있는 능력.
- **이론적 기반**:  
  - **동적 바인딩**(Dynamic Binding) / **런타임 다형성**: `Vehicle` 타입의 참조 변수가 실제 런타임에 `Car` 또는 `Bicycle` 객체를 가리키며, 호출되는 `move()` 메서드는 실제 객체의 타입에 따라 동적으로 결정된다.  
  - **서브타입 다형성**(Subtype Polymorphism): `Car`와 `Bicycle`은 `Vehicle`의 서브타입이며, 부모 타입(`Vehicle`)의 참조로 자식 객체를 다룰 수 있다.

3.**계약 기반 설계**(Design by Contract)
- **정의**: 인터페이스는 구현 클래스가 반드시 특정 메서드를 제공해야 한다는 **계약**을 정의한다.
- **이론적 기반**:  
  - 인터페이스는 "무엇을 할 수 있는가"만 명시하고, "어떻게 하는가"는 구현 클래스에 위임함으로써 **역할과 책임의 분리**를 실현한다.

4.**Liskov 치환 원칙**(Liskov Substitution Principle, LSP)
- **정의**: 프로그램의 정확성을 깨뜨리지 않고, 부모 타입의 객체를 자식 타입의 객체로 대체할 수 있어야 한다.
- **이론적 기반**:  
  - `Vehicle` 타입의 변수에 `Car`나 `Bicycle` 인스턴스를 대입해도 프로그램이 올바르게 동작함은 LSP를 만족함을 보여준다.


- [ ]   추상 클래스

```java
abstract class Shape {
    abstract double area(); // 추상 메서드

    public void printArea() {
        System.out.println("Area: " + area());
    }
}

class Circle extends Shape {
    double radius;

    Circle(double radius) {
        this.radius = radius;
    }

    @Override
    double area() {
        return Math.PI * radius * radius;
    }
}

public class AbstractExample {
    public static void main(String[] args) {
        Shape c = new Circle(3.0);
        c.printArea();
    }
}
```

1.**추상 클래스**(Abstract Class)
- **정의**: 추상 클래스는 하나 이상의 **추상 메서드**(abstract method)를 포함할 수 있으며, **인스턴스화될 수 없는 클래스**입니다.
- **목적**: 공통된 인터페이스나 부분적인 구현을 제공하면서, 하위 클래스가 특정 메서드를 반드시 구현하도록 강제합니다.
- **이론적 배경**: 객체지향 프로그래밍(OOP)의 **추상화**(Abstraction) 원칙에 기반합니다. 구현 세부사항을 숨기고, 공통된 동작의 틀을 정의합니다.

2.**추상 메서드**(Abstract Method)
- **정의**: 본문(구현부) 없이 선언만 존재하는 메서드로, 하위 클래스에서 **반드시 오버라이드**(override)되어야 합니다.
- **이론적 의미**: "계약"(contract)의 형태로, 모든 하위 클래스가 해당 메서드를 구현해야 한다는 **인터페이스 규약**을 강제합니다.

3.**상속**(Inheritance)
- **정의**: 한 클래스가 다른 클래스의 속성과 메서드를 물려받는 메커니즘입니다.
- **이론적 역할**: 코드 재사용과 계층적 분류를 가능하게 하며, **"is-a" 관계**를 표현합니다. (예: Circle은 Shape이다.)

4.**동적 바인딩**(Dynamic Binding) / **다형성**(Polymorphism)
- **설명**: `Shape c = new Circle(3.0);`에서 변수 `c`는 `Shape` 타입이지만, 실제 객체는 `Circle`입니다.
- **실행 시점 동작**: `c.printArea()` 호출 시, `printArea()`는 `Shape`에 정의되어 있지만, 내부에서 호출되는 `area()`는 **런타임에 실제 객체인 `Circle`의 `area()` 메서드로 동적으로 바인딩**됩니다.
- **이론적 기반**: **다형성**(Polymorphism), 특히 **서브타입 다형성**(Subtype Polymorphism)에 해당하며, **가상 메서드 호출**(Virtual Method Invocation) 메커니즘에 의존합니다.

5.**템플릿 메서드 패턴**(Template Method Pattern) – 암시적 적용
- **설명**: `printArea()`는 알고리즘의 골격(`"Area: " + area()`)을 정의하고, `area()`라는 특정 단계를 하위 클래스에 위임합니다.
- **이론적 분류**: 이는 **행동 디자인 패턴** 중 하나인 **템플릿 메서드 패턴**의 간단한 형태로, 상위 클래스에서 알고리즘 구조를 고정하고, 변하는 부분을 추상 메서드로 위임합니다.


- [ ]   예외 처리

```java
public class ExceptionExample {
    public static void main(String[] args) {
        try {
            int result = divide(10, 0);
            System.out.println(result);
        } catch (ArithmeticException e) {
            System.out.println("오류 발생: " + e.getMessage());
        } finally {
            System.out.println("프로그램 종료");
        }
    }

    static int divide(int a, int b) {
        if (b == 0) throw new ArithmeticException("0으로 나눌 수 없습니다.");
        return a / b;
    }
}
```

1.**예외 처리(Exception Handling) 메커니즘**
- 프로그램 실행 중 발생할 수 있는 **비정상적인 상황**(예: 0으로 나누기)을 **제어 흐름에서 분리**하여 처리하는 구조적 프로그래밍 기법.
- **예외**(Exception)는 프로그램의 정상적인 실행 흐름을 방해하는 이벤트로, 이를 **포착**(catch)하고 **복구**하거나 **보고**할 수 있도록 설계됨.

2.**try-catch-finally 블록 구조**
- **try 블록**: 예외가 발생할 가능성이 있는 코드를 포함.
- **catch 블록**: 특정 타입의 예외를 포착하고 처리. 여기서는 `ArithmeticException`이라는 **체크되지 않은 예외**(unchecked exception)를 처리.
- **finally 블록**: 예외 발생 여부와 무관하게 **항상 실행**되는 코드로, 자원 정리나 종료 로직에 사용됨.  
  → 이는 **예외 안전성**(exception safety) 및 **자원 누출 방지**를 위한 이론적 기반을 제공.

3.**예외의 분류: 체크 예외**(Checked vs. Unchecked Exception)
- `ArithmeticException`은 **RuntimeException**의 하위 클래스로, **런타임 예외**(unchecked exception)에 해당.
- **체크 예외**는 컴파일 시 반드시 처리(try-catch 또는 throws 선언)해야 하지만, **언체크 예외**는 선택적으로 처리 가능.
- 이 구분은 **Java의 예외 계층 구조 이론**에 기반하며, 오류의 **복구 가능성**과 **프로그래머의 책임 범위**를 반영.

4.**예외 발생**(Throwing Exceptions)
- `throw` 키워드를 사용해 **명시적으로 예외 객체를 생성 및 발생**시킴.
- 이는 **실행 시점 오류**(runtime error)를 **의도적으로 유도**하여 호출자에게 오류 상태를 전달하는 **오류 전파**(error propagation) 메커니즘의 일환.

5.**스택 트레이스와 예외 전파**(Exception Propagation)
- `divide()` 메서드에서 발생한 예외는 호출 스택을 따라 `main()` 메서드의 `catch` 블록으로 **자동 전파**됨.
- 이는 **호출 스택 기반의 예외 전파 이론**을 따르며, 예외 처리 지점을 호출자 측에서 유연하게 결정할 수 있게 함.


### 2.3 3단계: 필수 라이브러리와 문법

- [ ]   컬렉션 프레임워크

```java
import java.util.*;

public class CollectionExample {
    public static void main(String[] args) {
        // List
        List<String> fruits = new ArrayList<>();
        fruits.add("Apple");
        fruits.add("Banana");
        fruits.add("Cherry");
        System.out.println("List: " + fruits);

        // Set
        Set<String> set = new HashSet<>(fruits);
        set.add("Apple"); // 중복 무시
        System.out.println("Set: " + set);

        // Map
        Map<String, Integer> scores = new HashMap<>();
        scores.put("Alice", 90);
        scores.put("Bob", 85);
        System.out.println("Map: " + scores);
    }
}
```

1.**컬렉션 프레임워크(Collection Framework)의 자료구조 이론**
*   자바 컬렉션 프레임워크는 **자료구조(Data Structures)** 와 **알고리즘(Algorithms)** 에 기반한 표준화된 인터페이스와 구현체를 제공합니다. 이 코드에서 사용된 `List`, `Set`, `Map`은 각각 다음 이론적 자료구조에 해당

- **List**: **순서가 있는 중복 허용 컬렉션**  
  → 이론적으로 **선형 리스트(Linear List)** 자료구조를 구현.  
  → 인덱스 기반 접근, 삽입/삭제 시 순서 유지.

- **Set**: **순서 없고 중복을 허용하지 않는 컬렉션**  
  → 이론적으로 **수학적 집합(Set)** 개념을 구현.  
  → 집합의 속성: **항등성(Identity)**, **비중복성(Uniqueness)**.

- **Map**: **키-값 쌍(Key-Value Pair)의 연관 배열(Associative Array)**  
  → 이론적으로 **해시 테이블(Hash Table)** 또는 **사전(Dictionary)** 자료구조를 구현.  
  → 각 키는 고유하며, 값은 중복 가능.

2.**해시 기반 자료구조의 이론: 해시 함수와 충돌 처리**
- `HashSet`과 `HashMap`은 내부적으로 **해시 테이블(Hash Table)** 을 사용합니다.
- **해시 함수(Hash Function)** 를 통해 객체의 `hashCode()` 값을 계산하여 저장 위치(버킷)를 결정합니다.
- **중복 방지**는 `equals()`와 `hashCode()`의 일관된 구현에 의존합니다.  
  → 이는 **해시 자료구조의 불변 조건(Invariant)**:  
    > `a.equals(b) == true` 이면 `a.hashCode() == b.hashCode()` 여야 함.

- 해시 충돌(Hash Collision) 발생 시, 자바 8 이후 버전에서는 **체이닝(Chaining)** + **레드-블랙 트리(Red-Black Tree)** 를 조합하여 성능을 최적화합니다.

3.**인터페이스와 구현의 분리 (Abstraction & Polymorphism)**
- 코드는 `List`, `Set`, `Map`이라는 **인터페이스**를 사용하고, 실제 구현체로 `ArrayList`, `HashSet`, `HashMap`을 선택합니다.
- 이는 **추상화(Abstraction)** 와 **다형성(Polymorphism)** 원칙에 기반한 설계로,  
  → **Liskov 치환 원칙(LSP)** 을 따르며,  
  → **의존 역전 원칙(DIP)** 에 따라 구현보다 인터페이스에 의존합니다.

4.**집합 이론(Set Theory)의 적용**
- `Set`은 수학적 **집합 이론**을 프로그래밍에 적용한 예시입니다:
  - 원소의 **비중복성**
  - **순서 무관성** (단, `LinkedHashSet`이나 `TreeSet`은 예외)
  - 집합 연산(교집합, 합집합 등)을 지원 가능 (이 코드에선 사용 안 함)

<br>

- [ ]  제네릭 (Generics)

```java
class Box<T> {
    private T item;

    public void setItem(T item) {
        this.item = item;
    }

    public T getItem() {
        return item;
    }
}

public class GenericExample {
    public static void main(String[] args) {
        Box<String> box1 = new Box<>();
        box1.setItem("Hello");
        System.out.println(box1.getItem());

        Box<Integer> box2 = new Box<>();
        box2.setItem(123);
        System.out.println(box2.getItem());
    }
}
```

1.**제너릭(Generics)**
- **정의**: 타입을 코드 작성 시점이 아니라 **사용 시점에 지정**할 수 있도록 하는 프로그래밍 기법.
- **목적**:  
  - **타입 안정성(Type Safety)**: 컴파일 시점에 타입 오류를 검출하여 런타임 오류를 방지.  
  - **코드 재사용성**: 동일한 로직을 다양한 타입에 대해 중복 없이 사용 가능.
- **이론적 배경**:  
  - **매개변수화된 타입(Parameterized Types)**: 클래스나 메서드가 특정 타입이 아닌 **타입 매개변수**를 통해 동작하도록 설계됨.  
  - **불변성(Invariance)**: `Box<String>`과 `Box<Object>`는 서로 다른 타입으로 간주되며, 상속 관계가 없음 (Java 제너릭은 공변/반공변이 아님).

2.**타입 소거(Type Erasure)**
- **정의**: Java 컴파일러가 제너릭 타입 정보를 **런타임에 제거**하고, 원시 타입(예: `Object`)으로 변환하는 메커니즘.
- **의미**:  
  - 런타임에는 `Box<String>`과 `Box<Integer>` 모두 `Box`로 동일하게 취급됨.  
  - 제너릭은 **컴파일 시점에만 유효**하며, 런타임 성능에 영향을 주지 않음.
- **제약**:  
  - 런타임에 제너릭 타입 정보를 알 수 없으므로, `new T()`와 같은 인스턴스 생성이 불가능.

3.**정적 타입 검사(Static Type Checking)**
- **정의**: 컴파일러가 코드의 타입 일관성을 **컴파일 시점에 검증**하는 과정.
- **제너릭과의 관계**:  
  - `Box<String>`에 `Integer`를 저장하려 하면 **컴파일 오류** 발생.  
  - 캐스트 없이 타입 안정성을 보장함으로써 **런타임 예외**(e.g., `ClassCastException`)를 방지.

4.**추상화(Abstraction)**
- **정의**: 구체적인 타입을 숨기고, **일반화된 인터페이스**를 제공하는 설계 원칙.
- **제너릭에서의 적용**:  
  - `Box<T>`는 `T`의 구체적 타입을 몰라도 동작하도록 설계됨.  
  - 클라이언트 코드는 `T`가 `String`인지 `Integer`인지 신경 쓰지 않고 동일한 API 사용 가능.


- [ ] 람다식 (Java 8+)

```java
import java.util.function.Consumer;

public class LambdaExample {
    public static void main(String[] args) {
        Consumer<String> printer = message -> System.out.println("Message: " + message);
        printer.accept("Hello Lambda!");
    }
}
```

1.**람다 표현식(Lambda Expression)**  
- 함수형 프로그래밍의 핵심 개념으로, **익명 함수**(anonymous function)를 정의하는 문법입니다.  
- Java에서는 **SAM**(Single Abstract Method) 인터페이스(오직 하나의 추상 메서드만 가진 인터페이스)에 대해 람다 표현식을 사용할 수 있습니다.  
- 람다 표현식은 **first-class function**의 개념을 부분적으로 구현하며, 함수를 값처럼 다룰 수 있게 해줍니다.

2.**함수형 인터페이스**(Functional Interface)  
- `java.util.function.Consumer<T>`는 **함수형 인터페이스**의 표준 예시입니다.  
- 함수형 인터페이스는 **하나의 추상 메서드만**을 가지며, `@FunctionalInterface` 어노테이션으로 명시될 수 있습니다.  
- 이 인터페이스는 **입력은 받지만 반환값은 없는**(void) 동작을 표현합니다.

3.**고차 함수**(Higher-Order Function)의 간접적 활용  
- `Consumer` 인터페이스의 인스턴스를 변수(`printer`)에 할당하고, 이를 다른 메서드(`accept`)를 통해 실행하는 방식은 **함수를 인자로 전달하거나 반환하는 고차 함수**의 개념과 연결됩니다.  
- Java는 함수를 직접적인 값으로 취급하지 않지만, 함수형 인터페이스를 통해 유사한 동작을 구현합니다.

4.**클로저**(Closure)의 제한적 형태  
- 람다 표현식 내에서 외부 변수를 참조할 수 있으며, 이는 **클로저** 개념과 관련됩니다.  
- 다만 Java에서는 람다 내에서 참조하는 외부 지역 변수는 **effectively final**이어야 하므로, 완전한 클로저는 아닙니다.

- [ ] Stream API (Java 8+)

```java
import java.util.*;
import java.util.stream.*;

public class StreamExample {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1,2,3,4,5,6);

        int sum = numbers.stream()
                .filter(n -> n % 2 == 0)
                .mapToInt(n -> n * n)
                .sum();

        System.out.println("짝수 제곱의 합: " + sum);
    }
}
```

1.**함수형 프로그래밍 (Functional Programming)**
- Java의 Stream API는 함수형 프로그래밍 패러다임을 기반으로 설계되었습니다.
- 데이터를 **불변(immutable)** 상태로 처리하며, **순수 함수**(pure function)를 사용해 부작용(side effect)을 최소화합니다.
- `filter`, `map`, `sum` 등의 연산은 고차 함수(higher-order function)의 형태로, 함수를 인자로 받아 처리합니다.

2.**지연 평가**(Lazy Evaluation)
- Stream의 중간 연산(intermediate operation)인 `filter`와 `mapToInt`는 **지연 평가**됩니다.
- 즉, 최종 연산(terminal operation, 여기선 `sum()`)이 호출되기 전까지는 실제 데이터 처리가 이루어지지 않습니다.
- 이는 성능 최적화와 파이프라인(pipeline) 구성에 유리합니다.

3.**내부 반복**(Internal Iteration)
- 전통적인 외부 반복(for, while)과 달리, Stream은 **내부 반복**을 사용합니다.
- 컬렉션 요소에 대한 반복 제어를 라이브러리가 담당하며, 사용자는 **무엇을 할 것인가**(what)만 명시하고 **어떻게 할 것인가**(how)는 추상화됩니다.

4.**불변성**(Immutability)
- Stream은 원본 컬렉션(`numbers`)을 변경하지 않고, **새로운 스트림 또는 결과**를 생성합니다.
- 이는 병렬 처리와 스레드 안전성(thread safety)을 보장하는 데 중요한 원칙입니다.

5.**파이프라이닝**(Pipelining)
- 여러 스트림 연산(`filter` → `mapToInt` → `sum`)이 **연속된 파이프라인**으로 구성됩니다.
- 각 단계는 이전 단계의 출력을 입력으로 받아 처리하며, 중간 결과는 명시적으로 저장되지 않습니다.

6.**형 변환과 특수화된 스트림**(Specialized Streams)
- `mapToInt`는 `Stream<Integer>`를 **`IntStream`** 으로 변환합니다.
- 이는 **박싱/언박싱 오버헤드**를 줄이기 위한 **프리미티브 특화 스트림**(primitive-specialized stream) 기법입니다.
- 일반 `Stream<T>` 대신 `IntStream`, `LongStream`, `DoubleStream`을 사용해 성능을 향상시킵니다.


### 2.4 4단계: 구조와 설계

- [ ] 패키지

```java
// 파일 상단에 선언
package com.example.utils;

public class MathUtils {
    public static int square(int x) {
        return x * x;
    }
}

// 다른 파일
import com.example.utils.MathUtils;

public class PackageExample {
    public static void main(String[] args) {
        System.out.println(MathUtils.square(5));
    }
}
```

1.**패키지(Package) 시스템**  
- 자바는 **네임스페이스(namespace) 관리**를 위해 패키지 구조를 사용합니다.  
- 패키지는 클래스 이름 충돌을 방지하고, 관련 클래스들을 논리적으로 그룹화하는 **모듈화(Modularity)** 메커니즘입니다.  
- `package com.example.utils;` 선언은 이 클래스가 `com.example.utils`라는 **계층적 네임스페이스**에 속함을 명시합니다.

2.**정적 메서드(Static Method)**  
- `public static int square(int x)`는 **클래스 메서드**(class method)로, 인스턴스 생성 없이 클래스 이름을 통해 직접 호출됩니다.  
- 정적 메서드는 **객체 지향 프로그래밍**(OOP)에서 **유틸리티 함수**(utility function)를 구현할 때 자주 사용되며, 상태를 유지하지 않는 순수 함수(pure function)의 특성을 가집니다.

3.**캡슐화와 접근 제어**(Encapsulation & Access Control)  
- `public` 접근 제어자는 해당 클래스와 메서드가 **다른 패키지에서도 접근 가능**함을 의미합니다.  
- 이는 자바의 **접근 제어 이론**(access control theory)에 기반하며, 정보 은닉과 모듈 간의 인터페이스 정의를 지원합니다.

4.**클래스 경로**(Classpath)  
- 컴파일 및 실행 시 자바는 **패키지 구조에 따라 디렉터리 경로를 매핑**합니다(`com/example/utils/MathUtils.class`).  
- 이는 자바의 **클래스 로딩 메커니즘**(class loading mechanism)의 일부로, **논리적 이름**(fully qualified name)과 **물리적 파일 위치**를 연결하는 이론적 기반을 따릅니다.

<br>

- [ ] static 멤버

```java
public class StaticExample {
    static int count = 0;

    StaticExample() {
        count++;
    }

    static void printCount() {
        System.out.println("객체 수: " + count);
    }

    public static void main(String[] args) {
        new StaticExample();
        new StaticExample();
        StaticExample.printCount();
    }
}
```

1.**정적 멤버(Static Member)**
- **정적 변수(static variable)**: 클래스 변수라고도 하며, 클래스 자체에 속하며 **모든 인스턴스가 공유**하는 변수
- 메모리 상에서 **클래스가 로드될 때 한 번만 생성**되며, 객체가 생성될 때마다 새로 생성되지 않습니다.
- 이론적 배경: **클래스 레벨 데이터**(class-level data) 개념으로, 객체 지향 프로그래밍(OOP)에서 **공유 상태**(shared state)를 표현하는 수단입니다.

2.**정적 메서드(Static Method)**
- **정적 메서드**는 클래스에 속하며, **인스턴스 없이도 호출**할 수 있습니다.
- 정적 메서드 내에서는 **인스턴스 변수나 인스턴스 메서드에 접근할 수 없습니다** (this 참조 불가).
- 이론적 배경: **클래스 메서드**(class method) 개념으로, 객체의 상태와 무관하게 동작하는 유틸리티 기능이나 클래스 수준의 동작을 제공합니다.

3.**클래스 초기화와 객체 생성 시점의 분리**
- 정적 변수는 **클래스 로딩 시점**(class loading time)에 초기화됩니다.
- 반면, 생성자는 **객체 인스턴스 생성 시점**(instantiation time)에 실행됩니다.
- 이론적 배경: **클래스 초기화 단계**(static initialization)와 **객체 초기화 단계**(instance initialization)의 구분은 JVM의 클래스 로딩 및 초기화 메커니즘에 기반합니다.

4.**객체 수 카운팅 패턴(Object Counting Pattern)**

- 정적 변수를 사용해 생성된 객체의 수를 추적하는 기법입니다.
- 이론적 배경: **싱글턴 패턴**, **팩토리 패턴** 등과 유사하게, **인스턴스 수 제어 또는 모니터링**을 위한 설계 패턴의 기초 개념입니다.

<br>

- [ ] 내부 클래스

```java
public class OuterClass {
    private String message = "Hello";

    // 멤버 내부 클래스
    class Inner {
        void showMessage() {
            System.out.println("Inner says: " + message);
        }
    }

    // 정적 내부 클래스
    static class StaticInner {
        void display() {
            System.out.println("Static Inner");
        }
    }

    public static void main(String[] args) {
        OuterClass outer = new OuterClass();
        OuterClass.Inner inner = outer.new Inner();
        inner.showMessage();

        OuterClass.StaticInner staticInner = new OuterClass.StaticInner();
        staticInner.display();
    }
}
```


1.**내부 클래스 (Inner Class)**
- **멤버 내부 클래스**(Member Inner Class):  
  외부 클래스의 인스턴스 멤버처럼 선언되며, **외부 클래스의 인스턴스에 종속**된다.  
  → 이론적 근거: **캡슐화**(Encapsulation)와 **접근 제어**(Access Control)  
  - 내부 클래스는 외부 클래스의 **private 멤버에 직접 접근**할 수 있음  
  - 외부 클래스의 인스턴스가 존재해야 내부 클래스의 인스턴스를 생성 가능  
  - 자바 언어 명세(JLS, Java Language Specification)에서 정의된 **중첩 클래스**(Nested Class)의 한 형태

2.**정적 내부 클래스**(Static Nested Class)
- **정적 중첩 클래스**(Static Nested Class):  
  `static` 키워드로 선언된 내부 클래스로, **외부 클래스의 인스턴스와 독립**적으로 존재  
  → 이론적 근거: **정적 바인딩**(Static Binding)과 **클래스 레벨 구성 요소** 개념  
  - 외부 클래스의 **정적 멤버만 접근 가능** (인스턴스 멤버 접근 불가)  
  - 외부 클래스 인스턴스 없이도 인스턴스화 가능  
  - 자바에서 **정적 중첩 클래스는 외부 클래스의 정적 멤버로 간주**됨

3.**중첩 클래스의 분류 이론**(Nested Class Taxonomy)
- 자바는 중첩 클래스를 두 가지로 구분:
  - **Non-static nested classes **(Inner classes): 외부 인스턴스에 묶임
  - **Static nested classes**: 외부 인스턴스와 무관  
  → 이는 **객체 지향 설계 원칙 중 응집도**(Cohesion)와 **결합도**(Coupling)를 조절하기 위한 언어적 장치

4.**렉시컬 스코프와 캡처**(Lexical Scoping and Capture)
- 멤버 내부 클래스가 외부 클래스의 `private String message`에 접근할 수 있는 이유는:
  → **렉시컬 스코프**(Lexical Scoping)에 기반한 **외부 변수 캡처**(Capture) 메커니즘  
  - 컴파일러가 내부 클래스에 **외부 클래스 인스턴스에 대한 숨겨진 참조**(synthetic field)를 삽입  
  - 이는 **클로저**(Closure) 개념의 제한된 형태로 볼 수 있음 (자바는 완전한 클로저 미지원)

5.**객체 생성 시 인스턴스 의존성**
- `outer.new Inner()` 구문은:
  → **내부 클래스 인스턴스가 외부 클래스 인스턴스에 대한 암시적 참조를 유지**해야 함을 반영  
  - 이는 **컴포지션**(Composition) 관계의 구현적 표현  
  - 객체 지향에서 **has-a 관계**를 코드로 구현하는 방식 중 하나


### 2.5 5단계: 기타 중요 개념

- [ ] 불변 객체 (Immutable)

```java
final class ImmutablePerson {
    private final String name;
    private final int age;

    public ImmutablePerson(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() { return name; }
    public int getAge() { return age; }
}

public class ImmutableExample {
    public static void main(String[] args) {
        ImmutablePerson p = new ImmutablePerson("John", 30);
        System.out.println(p.getName() + " - " + p.getAge());
    }
}
```


1.**불변성**(Immutability)
- **정의**: 객체가 생성된 이후 그 상태(필드 값)를 외부에서 변경할 수 없는 성질.
- **목적**: 스레드 안전성(Thread Safety), 부작용 방지, 객체의 일관성 보장, 캐시 가능성 향상 등.
- **핵심 조건**:
  - 클래스가 `final`이거나 상속을 방지해야 함 (서브클래스에서 상태 변경 가능성을 차단).
  - 모든 필드가 `private`이고 `final`이어야 함.
  - 생성자를 통해 상태를 완전히 초기화해야 하며, 이후 수정 메서드(setter 등)를 제공하지 않음.
  - 참조 타입 필드가 있다면, 해당 객체도 불변이거나 방어적 복사(defensive copying)를 해야 함.

- 본 코드에서는 `ImmutablePerson` 클래스가 `final`이며, 모든 필드가 `private final`이고, setter 없이 오직 getter만 제공함으로써 위 조건을 충족합니다.

2.**객체 상태의 캡슐화**(Encapsulation)
- 불변 객체는 캡슐화의 극단적 형태로, 내부 상태를 외부에 노출하지 않으며(직접 접근 차단), 읽기 전용 인터페이스만 제공합니다.
- 이는 정보 은닉(Information Hiding) 원칙과 일치합니다.

3.**참조 투명성**(Referential Transparency)
- 불변 객체는 동일한 입력에 대해 항상 동일한 출력을 반환하며, 부작용(side effect)이 없으므로 함수형 프로그래밍에서 중요한 **참조 투명성**을 만족합니다.
- 이는 코드의 예측 가능성과 테스트 용이성을 높입니다.

4.**스레드 안전성**(Thread Safety)
- 불변 객체는 상태 변경이 불가능하므로, 여러 스레드가 동시에 접근해도 동기화(synchronization)가 불필요합니다.
- Java 메모리 모델(JMM)에 따르면, `final` 필드는 객체 생성 완료 시점에 다른 스레드에게 안전하게 공개(guaranteed visibility)됩니다.

<br>

- [ ] equals()와 hashCode()

```java
import java.util.Objects;

class Student {
    String name;
    int id;

    Student(String name, int id) {
        this.name = name;
        this.id = id;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Student)) return false;
        Student s = (Student) o;
        return id == s.id && Objects.equals(name, s.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, id);
    }
}

public class EqualsExample {
    public static void main(String[] args) {
        Student s1 = new Student("Alice", 1);
        Student s2 = new Student("Alice", 1);
        System.out.println(s1.equals(s2)); // true
    }
}
```

1.**동치 관계(Equivalence Relation)**
- `equals()` 메서드는 **동치 관계**를 구현해야 하며, 이는 다음 세 가지 수학적 속성을 만족해야 합니다:
  - **반사성(Reflexivity)**: 모든 객체 `x`에 대해 `x.equals(x)`는 `true`.
  - **대칭성(Symmetry)**: `x.equals(y)`가 `true`이면 `y.equals(x)`도 `true`.
  - **추이성(Transitivity)**: `x.equals(y)`와 `y.equals(z)`가 모두 `true`이면 `x.equals(z)`도 `true`.
- 추가로 **일관성(Consistency)**과 **null-비교 안정성**도 요구됨.

2.**해시 코드 계약(Hash Code Contract)**
- `hashCode()` 메서드는 다음 계약을 따라야 함:
  - **동일한 객체에 대해 `equals()`가 `true`이면, `hashCode()` 값도 반드시 동일해야 함.**
  - `hashCode()`의 반환값은 객체가 변경되지 않는 한 동일한 실행 내에서 일관되게 유지되어야 함.
- 이는 해시 기반 자료구조(예: `HashMap`, `HashSet`)에서 **올바른 작동을 보장**하기 위함.

3.**논리적 동등성(Logical Equality) vs 참조 동등성(Reference Equality)**
- 기본 `Object.equals()`는 **참조 동등성**(메모리 주소 비교)을 사용하지만,
- 이 코드는 **논리적 동등성**(객체의 내용이 같은지 비교)을 구현하여 의미 있는 비교를 가능하게 함.

4.**불변성(Immutability)과 해시 코드의 안정성**
- 해시 코드는 객체가 해시 기반 컬렉션에 저장된 후 **변경되지 않아야** 안정적인 동작을 보장함.
- 여기서는 `name`과 `id`가 변경 가능하지만, **불변 객체로 설계되지 않았음에도 불구하고**, `equals`/`hashCode`의 일관성을 위해 **변경 시 주의가 필요**하다는 이론적 전제가 내포됨.

5.**`Objects.equals()`와 `Objects.hash()`의 역할**
- `Objects.equals(a, b)`는 **null-safe 동등성 비교**를 제공:  
  → `a == null ? b == null : a.equals(b)`와 동일한 동작.
- `Objects.hash(Object... values)`는 **입력 필드들의 해시 코드를 조합**하여 단일 해시 값을 생성함.  
  → 내부적으로 **31을 기반으로 한 다항식 해시**(Polynomial Rolling Hash)를 사용함:  
  `result = 31 * result + (value == null ? 0 : value.hashCode())`


- [ ] Enum (열거형)

```java
enum Status {
    READY, RUNNING, DONE;

    public boolean isFinished() {
        return this == DONE;
    }
}

public class EnumExample {
    public static void main(String[] args) {
        Status s = Status.RUNNING;

        System.out.println("현재 상태: " + s);
        System.out.println("작업 완료 여부: " + s.isFinished());
    }
}
```

1.**열거형(Enum) 자료형 이론**
- **열거형**(Enumeration Type)은 **사전에 정의된 유한한 상수 집합**을 표현하는 자료형입니다.
- 열거형은 **타입 안전성**(type safety)을 제공하며, 변수가 가질 수 있는 값이 미리 정해져 있어 **불법 상태를 컴파일 타임에 방지**할 수 있습니다.
- Java의 `enum`은 단순한 정수 상수가 아니라 **클래스 기반의 객체 지향 열거형**(class-based enum)으로, 각 상수는 해당 열거형 클래스의 **싱글턴 인스턴스**입니다.

2.**객체 지향 열거형**(Object-Oriented Enum
- Java의 `enum`은 내부적으로 **final 클래스**로 컴파일되며, 각 열거 상수는 해당 클래스의 **정적 final 인스턴스**입니다.
- 따라서 열거형은 **메서드**, **필드**, **생성자** 등을 포함할 수 있으며, 일반 클래스처럼 동작할 수 있습니다.
- 이 예제에서 `isFinished()` 메서드는 열거형 상수에 동작을 부여하는 **객체 지향적 특성**을 활용한 것입니다.

3.**싱글턴 패턴**(Singleton Pattern)
- Java의 열거형 상수는 JVM에 의해 **자동으로 싱글턴으로 관리**됩니다.
- 즉, `Status.DONE`은 항상 동일한 객체 참조를 가지며, **인스턴스가 유일하게 보장**됩니다.
- 이는 `==` 연산자를 사용해 열거형 상수 간의 동등 비교가 **안전하고 효율적**임을 의미합니다 (`equals()` 대신 `==` 사용 가능).

4.**상태 패턴**(State Pattern)의 단순화된 표현
- `Status` 열거형은 시스템의 **상태**(state)를 모델링하고 있으며, 각 상태(`READY`, `RUNNING`, `DONE`)는 고유한 의미를 가집니다.
- `isFinished()` 메서드는 상태에 따라 **동작**(behavior)을 제공함으로써, **상태 기반 로직**을 캡슐화하는 **상태 패턴의 기본 아이디어**를 반영합니다.
