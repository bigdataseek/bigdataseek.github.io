---
title: 1차시 5(빅데이터 분석):Numpy 2
layout: single
classes: wide
categories:
  - Numpy
toc: true # 이 포스트에서 목차를 활성화
toc_sticky: true # 목차를 고정할지 여부 (선택 사항)
---

## 1. NumPy, 더 깊이 파고들기: 데이터 과학 전문가가 되기 위한 고급 기술
- 출처: [Advanced NumPy Course - Vectorization, Masking, Broadcasting & More](https://www.youtube.com/watch?v=pQt8yQuPOGo&t=2792s)

> 브인정반 마뷰백행
>
> (브인)의 (정)책에 (반)대하고, (마)을의 (뷰)와 (백)성의 (행)복을 추구했다.

### 1.1 (브)로드캐스팅 (Broadcasting): 다른 모양의 배열끼리도 척척 계산

**쉽게 말하면**: 크기가 다른 배열끼리도 NumPy가 알아서 크기를 맞춰서 계산해주는 기능이에요. 마치 작은 배열을 늘려서 큰 배열에 맞추는 것과 같아요.
>두 배열 중 하나의 해당 축(axis)의 크기가 1이어야 합니다

**예시**:
숫자 하나를 배열에 더하면 배열의 모든 요소에 그 숫자가 더해져요. 이게 바로 브로드캐스팅이에요\!

```python
import numpy as np

# 1차원 배열
arr = np.array([1, 2, 3])
print("원래 배열:", arr) # [1 2 3]

# 배열에 숫자 10을 더하기 (브로드캐스팅!)
# NumPy가 숫자 10을 [10, 10, 10]처럼 늘려서 계산해요.
result_scalar_add = arr + 10
print("숫자 더하기 결과:", result_scalar_add) # [11 12 13]

# 2차원 배열과 1차원 배열의 연산
matrix = np.array([[1, 2, 3],
                   [4, 5, 6]]) # 모양: (2, 3)

vector = np.array([10, 20, 30]) # 모양: (3,)

# matrix의 각 행에 vector를 더하기 (브로드캐스팅!)
# vector가 [[10, 20, 30], [10, 20, 30]] 처럼 늘어나는 효과
result_matrix_vector_add = matrix + vector
print("\n행렬 + 벡터 결과:\n", result_matrix_vector_add)
# 결과:
# [[11 22 33]
#  [14 25 36]]
```

### 1.2 고급 (인)덱싱 (Advanced Indexing): 원하는 데이터만 쏙쏙 뽑아내기

인덱싱은 배열에서 데이터를 선택하는 방법이에요. 더 복잡한 방법들을 살펴볼게요.

  * **리스트로 인덱싱하기**: 숫자나 슬라이스 대신 **리스트**를 사용해서 여러 개의 행이나 열을 한 번에 선택할 수 있어요.

    ```python
    import numpy as np
    arr = np.array([[1, 2, 3],
                    [4, 5, 6],
                    [7, 8, 9]])
    print("원본 배열:\n", arr)

    # 0번째 행과 2번째 행 선택
    selected_rows = arr[[0, 2]]
    print("\n0번째 행과 2번째 행 선택:\n", selected_rows)
    # 결과:
    # [[1 2 3]
    #  [7 8 9]]

    # 1번째 행의 0번째 열과 2번째 열 선택
    selected_cols = arr[1, [0, 2]]
    print("\n1번째 행의 0번째 열과 2번째 열 선택:\n", selected_cols)
    # 결과:
    #  [4 6]
    
    ```

  * **차원 인덱싱 (`:` 사용)**: 콜론(`:`)을 사용하면 특정 차원의 **모든** 요소를 선택할 수 있어요.

    ```python
    import numpy as np
    arr = np.array([[1, 2, 3],
                    [4, 5, 6],
                    [7, 8, 9]])

    # 모든 행에서 두 번째(인덱스 1) 열 선택
    second_column = arr[:, 1]
    print("모든 행의 두 번째 열:", second_column) # [2 5 8]

    # 두 번째(인덱스 1) 행의 모든 열 선택
    second_row = arr[1, :]
    print("두 번째 행의 모든 열:", second_row) # [4 5 6]
    ```

  * **새로운 축 추가 (`np.newaxis`)**: `np.newaxis`를 사용하면 배열에 **새로운 차원**을 추가할 수 있어요.

    ```python
    import numpy as np

    vec = np.array([1, 2, 3])
    print("원본 벡터 모양:", vec.shape)      # (3,)

    # 벡터를 행 방향으로 늘려서 2차원 배열 만들기 (행 차원 추가)
    row_vector = vec[np.newaxis, :]
    print("행 벡터로 변환 후 모양:", row_vector.shape) # (1, 3)
    print("행 벡터:\n", row_vector)
    # 결과:
    # [[1 2 3]]

    # 벡터를 열 방향으로 늘려서 2차원 배열 만들기 (열 차원 추가)
    col_vector = vec[:, np.newaxis]
    print("열 벡터로 변환 후 모양:", col_vector.shape) # (3, 1)
    print("열 벡터:\n", col_vector)
    # 결과:
    # [[1]
    #  [2]
    #  [3]]
    ```

  * **결합 인덱싱**: 행과 열에 동시에 고급 인덱싱을 적용해서 원하는 데이터 덩어리를 정확히 선택할 수 있어요.
    * 넘파이에서 $$matrix[[row\_indices], [col\_indices]]$$와 같이 배열을 인덱싱하면, 넘파이는 $$(row\_indices[0], col\_indices[0]), (row\_indices[1], col\_indices[1])$$ 이런 식으로 해당 인덱스 쌍이 가리키는 요소들을 선택합니다.

    ```python
    import numpy as np

    matrix = np.array([[10, 11, 12, 13],
                       [20, 21, 22, 23],
                       [30, 31, 32, 33],
                       [40, 41, 42, 43]])
    print("원본 행렬:\n", matrix)

    selected_elements = matrix[[0, 2], [1, 3]]
    print("\n결합 인덱싱 결과 (matrix[0,1], matrix[2,3]):", selected_elements)
    # 결과: 결합 인덱싱 결과 (matrix[0,1], matrix[2,3]): [11 33]
    # (주의: 이 예제는 [행1, 행2], [열1, 열2]로 (행1,열1)과 (행2,열2)를 선택합니다.
    # 만약 matrix[0,1], matrix[0,3], matrix[2,1], matrix[2,3]을 원한다면 불리언 인덱싱이나 슬라이싱 조합을 사용하세요.)

    selected_slicing = matrix[[0, 2], 1:3]
    print("슬라이싱 조합을 이용한 결과 \n", selected_slicing)
    #[[11 12]
    # [31 32]]

    # 원하는 덩어리 선택 예시 (슬라이싱과 리스트 인덱싱 조합)
    # 0, 2번째 행의 모든 열을 가져온 다음, 그 중에서 1, 3번째 열만 선택
    sub_matrix = matrix[[0, 2]][:, [1, 3]]
    print("\n특정 행들과 특정 열들의 교차점 (부분 행렬):\n", sub_matrix)
    # 결과:
    # [[11 13]
    #  [31 33]]
    ```

  * **불리언 인덱싱 (Boolean Indexing)**: `True`/`False` 값으로 이루어진 **불리언 배열**을 사용해서 특정 조건을 만족하는 요소만 선택하거나 숨길 수 있어요.

    ```python
    import numpy as np

    data = np.array([10, 20, 5, 30, 15, 25])

    # 15보다 큰 값을 찾는 조건 (True/False 배열 생성)
    mask = data > 15
    print("마스크 배열:", mask) # [False  True False  True False  True]

    # 마스크를 사용하여 조건에 맞는 값만 선택
    filtered_data = data[mask]
    print("15보다 큰 값들:", filtered_data) # [20 30 25]

    # 짝수만 선택
    even_mask = (data % 2 == 0)
    even_numbers = data[even_mask]
    print("짝수 값들:", even_numbers) # [10 20 30]
    ```


### 1.3 (정)렬 및 검색 (Sorting and Searching): 데이터를 정리하고 필요한 값 찾기

데이터를 분석하기 전에 특정 순서로 정렬하거나, 원하는 값을 찾아야 할 때가 많아요.

  * **정렬 (Sorting)**

      * **`np.sort(배열)`**: 원본 배열은 그대로 두고, **정렬된 새 배열**을 만들어줘요.
        ```python
        import numpy as np

        arr_original = np.array([3, 1, 4, 1, 5, 9, 2])
        sorted_copy = np.sort(arr_original)
        print("원본 배열:", arr_original)    # [3 1 4 1 5 9 2]
        print("정렬된 복사본:", sorted_copy) # [1 1 2 3 4 5 9]
        ```
      * **`배열.sort()`**: **원본 배열 자체**를 정렬해서 바꿔버려요.
        ```python
        import numpy as np

        arr_in_place = np.array([3, 1, 4, 1, 5, 9, 2])
        print("정렬 전 원본:", arr_in_place) # [3 1 4 1 5 9 2]
        arr_in_place.sort() # 원본 배열을 직접 정렬
        print("정렬 후 원본:", arr_in_place) # [1 1 2 3 4 5 9]
        ```
      * **축(axis)별 정렬**: `axis` 옵션을 사용해서 행(`axis=1`) 또는 열(`axis=0`)을 기준으로 정렬할 수 있어요.
        * 기본값은 axis=-1 이다. 이건 최안쪽 축 즉 2차원 배열에서는 axis=1 임을 뜻한다.

        ```python
        import numpy as np

        matrix = np.array([[5, 2, 8],
                           [1, 9, 3]])
        print("원본 행렬:\n", matrix)

        # 각 행을 오름차순으로 정렬 (axis=1)
        sorted_by_rows = np.sort(matrix, axis=1)
        print("\n각 행별 정렬:\n", sorted_by_rows)
        # 결과:
        # [[2 5 8]
        #  [1 3 9]]

        # 각 열을 오름차순으로 정렬 (axis=0)
        sorted_by_cols = np.sort(matrix, axis=0)
        print("\n각 열별 정렬:\n", sorted_by_cols)
        # 결과:
        # [[1 2 3]
        #  [5 9 8]]
        ```

  * **값 검색 및 인덱스 찾기 (Searching)**

      * **`np.argmax(배열)`**: 배열에서 **가장 큰 값의 위치(인덱스)**를 알려줘요.
        ```python
        import numpy as np
        data = np.array([10, 50, 20, 90, 30])
        max_index = np.argmax(data)
        print("가장 큰 값의 인덱스:", max_index) # 3 (90은 인덱스 3에 있음)
        ```
      * **`np.argmin(배열)`**: 배열에서 **가장 작은 값의 위치**를 알려줘요.
        ```python
        import numpy as np
        data = np.array([10, 50, 20, 90, 30])
        min_index = np.argmin(data)
        print("가장 작은 값의 인덱스:", min_index) # 0 (10은 인덱스 0에 있음)
        ```
      * **`np.nonzero(배열)`**: 배열에서 **0이 아닌 값들의 위치**를 알려줘요.
        ```python
        import numpy as np
        data = np.array([0, 5, 0, 10, 0, 15])
        nonzero_indices = np.nonzero(data)
        print("0이 아닌 값들의 인덱스:", nonzero_indices)
        # 결과: (array([1, 3, 5]),) -> 인덱스 1, 3, 5에 0이 아닌 값이 있음
        ```
      * **`np.where(조건, 값1, 값2)`**: 조건에 따라 `값1` 또는 `값2`를 선택해서 새로운 배열을 만들어줘요.
        ```python
        import numpy as np
        scores = np.array([85, 92, 60, 75, 40, 98])

        # 70점 이상이면 '합격', 아니면 '불합격'으로 새 배열 만들기
        results = np.where(scores >= 70, '합격', '불합격')
        print("시험 결과:", results)
        # 결과: 시험 결과: ['합격' '합격' '불합격' '합격' '불합격' '합격']

        # 70점 이상이면 점수 그대로, 아니면 0으로 바꾸기
        adjusted_scores = np.where(scores >= 70, scores, 0)
        print("조정된 점수:", adjusted_scores)
        # 결과: 조정된 점수: [85 92  0 75  0 98]
        ```


### 1.4 (반)복 (Iteration): 배열의 모든 요소에 쉽게 접근하기

다차원 배열의 모든 요소를 하나씩 살펴보려면 `np.nditer`를 사용하면 편리해요.

  * **`np.nditer`**: `np.nditer`는 배열의 차원에 상관없이 모든 요소를 효율적으로 반복할 수 있게 해주는 특별한 도구예요.
    ```python
    import numpy as np

    my_2d_array = np.array([[1, 2, 3],
                            [4, 5, 6]])

    print("nditer를 이용한 요소 반복:")
    for x in np.nditer(my_2d_array):
        print(x, end=' ')
    # 결과: 1 2 3 4 5 6
    ```
  * **반복 중 값 변경**: `op_flags=['readwrite']` 옵션을 `np.nditer`에 추가하면 반복하면서 배열의 요소 값을 직접 변경할 수도 있어요.
    ```python
    import numpy as np

    arr = np.array([[1, 2], [3, 4]])
    print("원본 배열:\n", arr)

    # 짝수 요소에 10을 더하기
    for x in np.nditer(arr, op_flags=['readwrite']):
        x[...] = x + 10 if x%2 ==0 else x # 반드시 x[...] 형태로 값을 할당해야 함
    print("\n값 변경 후 배열:\n", arr)
    # 결과:
    # [[11 12]
    #  [13 14]]
    ```


### 1.5 (마)스킹 (Masking): 특정 데이터를 임시로 숨기거나 제외하기

데이터 분석 시, 특정 값을 계산에서 제외하고 싶을 때 마스킹을 사용하면 데이터를 아예 삭제하지 않고도 숨길 수 있어요.

  * **개념**: 마스킹은 데이터를 '제거'하는 대신 '가려버리는' 거예요. 마치 가면을 씌워서 보이지 않게 하는 것과 같죠.
  * **`numpy.ma.MaskedArray`**: `numpy.ma` 모듈을 사용해서 마스킹된 배열을 만들 수 있어요.
    ```python
    import numpy.ma as ma
    import numpy as np

    data = np.array([1, 2, 3, 4, 5])
    # 인덱스 1 (값 2)과 인덱스 3 (값 4)을 가리고 싶어요 (1이 가림)
    mask = [False, True, False, True, False] # True인 부분이 가려짐

    masked_array = ma.masked_array(data, mask=mask)
    print("마스킹된 배열:", masked_array)
    # 결과: 마스킹된 배열: [1 -- 3 -- 5] (--는 가려진 값)

    # 마스킹된 배열로 평균 계산 -> 가려진 값은 계산에서 제외됨
    print("마스킹된 배열의 평균:", masked_array.mean())
    # 결과: 마스킹된 배열의 평균: 3.0 (1, 3, 5만 가지고 계산)

    # 원본 배열의 평균 (가려진 값 포함)
    print("원본 배열의 평균:", data.mean())
    # 결과: 원본 배열의 평균: 3.0 (1,2,3,4,5 모두 가지고 계산. 우연히 같은 값이지만 다르게 작동)
    ```
  * **자동 마스킹 함수**: 특정 조건에 따라 자동으로 마스킹해주는 편리한 함수들도 많아요.
    ```python
    import numpy.ma as ma
    import numpy as np

    data_with_invalid = np.array([1.0, 2.0, np.nan, 4.0, np.inf, 6.0])

    # NaN이나 Inf 같은 유효하지 않은 값을 자동으로 가려줘요.
    masked_invalid_data = ma.masked_invalid(data_with_invalid)
    print("유효하지 않은 값 마스킹 후:\n", masked_invalid_data)
    # 결과: 유효하지 않은 값 마스킹 후: [1.0 2.0 -- 4.0 -- 6.0]

    # 마스킹된 배열의 합계 (가려진 값은 무시)
    print("마스킹된 데이터의 합계:", masked_invalid_data.sum())
    # 결과: 마스킹된 데이터의 합계: 2.0 (1+2+4+6)
    ```


### 1.6 (뷰) (View) vs. 복사 (Copy): 데이터 변경의 함정

NumPy에서 배열을 다룰 때, 원본 데이터를 직접 바꾸는지 아니면 복사본을 만들어서 작업하는지 이해하는 것이 정말 중요해요.

  * **뷰 (View)**: 배열의 일부를 선택했는데, 이게 **원본 데이터와 연결된 다른 이름** 같은 거예요. 뷰를 변경하면 **원본 배열의 데이터도 함께 변경**돼요. 주로 **슬라이싱**(`배열[시작:끝]`)을 할 때 뷰가 만들어져요.
    * 리스트의 슬라이싱은 새로운 리스트를 생성

    ```python
    import numpy as np

    original_array = np.array([1, 2, 3, 4, 5])
    print("원본 배열:", original_array) # [1 2 3 4 5]

    # 슬라이싱으로 뷰 만들기
    view_of_array = original_array[1:4] # 2, 3, 4에 해당하는 부분
    print("뷰:", view_of_array) # [2 3 4]

    # 뷰의 값을 변경
    view_of_array[0] = 99 # 뷰의 첫 번째 값 (원래 2)을 99로 변경

    print("뷰 변경 후 원본 배열:", original_array)
    # 결과: 뷰 변경 후 원본 배열: [ 1 99  3  4  5] (원본도 2가 99로 바뀜!)
    print("뷰 변경 후 뷰:", view_of_array)
    # 결과: 뷰 변경 후 뷰: [99  3  4]
    ```
  * **복사 (Copy)**: 원본 데이터와는 **완전히 독립적인 새로운 데이터 덩어리**를 만드는 거예요. 복사본을 변경해도 **원본 배열은 전혀 바뀌지 않아요**. **고급 인덱싱**을 사용하거나, `배열.copy()`를 사용하면 복사본이 만들어져요.
    ```python
    import numpy as np

    original_array_copy_test = np.array([10, 20, 30, 40, 50])
    print("원본 배열 (복사 테스트):", original_array_copy_test) # [10 20 30 40 50]

    # .copy() 메서드를 사용해서 복사본 만들기
    copy_of_array = original_array_copy_test.copy()
    print("복사본:", copy_of_array) # [10 20 30 40 50]

    # 복사본의 값을 변경
    copy_of_array[0] = 999 # 복사본의 첫 번째 값 (원래 10)을 999로 변경

    print("복사본 변경 후 원본 배열:", original_array_copy_test)
    # 결과: 복사본 변경 후 원본 배열: [10 20 30 40 50] (원본은 그대로!)
    print("복사본 변경 후 복사본:", copy_of_array)
    # 결과: 복사본 변경 후 복사본: [999  20  30  40  50]
    ```
  * **확인 방법 (`.base` 속성)**: 배열의 `.base` 속성이 `None`이면 원본이거나 복사본이에요. 만약 `None`이 아니면, 이 배열은 다른 배열의 '뷰'라는 뜻이고, `.base`가 가리키는 것이 원본 배열이에요.
    ```python
    import numpy as np

    arr = np.array([1, 2, 3])
    arr_copy = arr.copy()
    arr_view = arr[:] # 슬라이싱으로 뷰 생성

    print("arr.base:", arr.base) # None (원본)
    print("arr_copy.base:", arr_copy.base) # None (복사본)
    print("arr_view.base:", arr_view.base) # <numpy.ndarray object at 0x...> (arr을 가리킴)
    ```


### 1.7 (벡)터화 (Vectorization): 파이썬 반복문 대신 NumPy의 힘 활용하기

파이썬 `for` 반복문으로 배열의 각 요소를 처리하는 것은 느릴 수 있어요. NumPy는 이런 작업을 훨씬 빠르게 처리하는 `벡터화`라는 강력한 기능을 제공해요.

  * **개념**: NumPy는 내부적으로 C언어로 구현되어 있어서, `for` 반복문 없이 배열 전체에 연산을 한 번에 적용하는 것이 가능해요. 이걸 `벡터화`라고 불러요.
    ```python
    import numpy as np
    import time

    size = 1000000 # 100만 개의 숫자
    python_list = list(range(size))
    numpy_array = np.arange(size)

    # 파이썬 반복문으로 계산 (느린 방법)
    start_time = time.time()
    result_list = [x * 2 for x in python_list]
    end_time = time.time()
    print(f"파이썬 리스트 계산 시간: {end_time - start_time:.6f} 초")

    # NumPy 벡터화 계산 (빠른 방법)
    start_time = time.time()
    result_array = numpy_array * 2 # 벡터화 연산!
    end_time = time.time()
    print(f"NumPy 배열 계산 시간: {end_time - start_time:.6f} 초")
    # 보통 NumPy가 훨씬 빠르게 나옵니다.
    ```
  * **`np.vectorize`**: 만약 직접 만든 파이썬 함수를 NumPy 배열에 적용하고 싶다면, `np.vectorize`를 사용해서 그 함수를 NumPy와 호환되도록 '포장'할 수 있어요.
    ```python
    import numpy as np

    # 간단한 파이썬 함수 (NumPy 배열에 직접 적용 불가)
    def my_custom_function(x):
        if x % 2 == 0:
            return x * 10
        else:
            return x / 2

    # 일반 파이썬 리스트에 적용
    py_list = [1, 2, 3, 4, 5]
    py_result = [my_custom_function(item) for item in py_list]
    print("파이썬 함수 결과:", py_result) # [0.5, 20, 1.5, 40, 2.5]

    # NumPy 배열에 적용하기 위해 vectorize 사용
    vectorized_func = np.vectorize(my_custom_function)

    numpy_arr = np.array([1, 2, 3, 4, 5])
    np_result = vectorized_func(numpy_arr)
    print("벡터화 함수 결과:", np_result) # [ 0.5 20.   1.5 40.   2.5]
    ```


### 1.8 (행)렬 곱셈 연산자 (`@`): 

* `@` 연산자는 NumPy에서 **행렬 곱셈**을 수행하는 편리한 방법이에요. 예전에는 `np.matmul()` 함수를 사용해야 했지만, 이제는 `@` 기호 하나로 더 직관적으로 사용할 수 있어요.

**예시**:

```python
import numpy as np

matrix_a = np.array([[1, 2],
                     [3, 4]])

matrix_b = np.array([[5, 6],
                     [7, 8]])

# 행렬 곱셈 (matrix_a와 matrix_b)
# 1*5 + 2*7 = 19
# 1*6 + 2*8 = 22
# 3*5 + 4*7 = 43
# 3*6 + 4*8 = 50
result_matrix_mul = matrix_a @ matrix_b
print("행렬 곱셈 (@ 연산자):\n", result_matrix_mul)
# 결과:
# [[19 22]
#  [43 50]]

# np.matmul()과 동일
result_matmul = np.matmul(matrix_a, matrix_b)
print("\nnp.matmul() 결과:\n", result_matmul)
# 결과:
# [[19 22]
#  [43 50]]
```

**NumPy 행렬/벡터 연산 함수 비교**

| 연산자/함수 | 입력 차원 | 의미 | 결과 차원 | 주요 특징 |
|------------|----------|------|-----------|-----------|
| **`@`** | 2D 이상 | **행렬 곱셈** | (m×n) @ (n×p) = (m×p) | Python 3.5+, `np.matmul()`과 유사 |
| **`np.dot(a, b)`** | 1D/2D/ND | **점곱/내적** | 다양한 결과 | 가장 일반적인 내적 연산 |
| **`np.matmul(a, b)`** | 2D 이상 | **행렬 곱셈** | (m×n) @ (n×p) = (m×p) | 브로드캐스팅에 `np.dot()`과 다름 |
| **`np.outer(a, b)`** | 1D | **외적** | (m×n) | 모든 조합의 곱, 1차원만 입력 |
| **`np.cross(a, b)`** | 1D/2D | **벡터 외적** | 입력과 동일 | 3차원 공간에서 수직 벡터 |

<br>
**구체적인 예시 비교**

1.1D 배열 (벡터) 입력시:

```python
import numpy as np

a = np.array([1, 2, 3])
b = np.array([4, 5, 6])

print("dot():", np.dot(a, b))        # 1*4 + 2*5 + 3*6 = 32 (스칼라)
print("outer():", np.outer(a, b))    # 3x3 행렬: [[4,5,6],[8,10,12],[12,15,18]]
print("cross():", np.cross(a, b))    # 3D 외적 벡터: [-3, 6, -3]
# @, matmul(): 1D에서는 사용 어려움
```

2.2D 배열 (행렬) 입력시:

```python
A = np.array([[1, 2], [3, 4]])
B = np.array([[5, 6], [7, 8]])

print("A @ B:", A @ B)               # 행렬 곱: [[19,22],[43,50]]
print("np.dot(A, B):", np.dot(A, B)) # 동일: [[19,22],[43,50]]  
print("np.matmul(A, B):", np.matmul(A, B)) # 동일: [[19,22],[43,50]]
# outer(), cross(): 2D에서는 다른 의미
```

3.주요 차이점 요약
- **`@` vs `np.dot()`**: `@`는 행렬 전용, `np.dot()`은 더 일반적
- **`np.dot()` vs `np.matmul()`**: 고차원 배열에서 브로드캐스팅 방식이 다름
- **`np.outer()`**: 모든 가능한 곱 조합을 생성 (1D만)
- **`np.cross()`**: 3차원 공간에서의 수직 벡터 계산



<!-- 
### 2.9 사용자 정의 데이터 타입 (Custom Data Types): 메모리를 효율적으로

NumPy는 배열의 요소에 따라 데이터 타입을 자동으로 추론하지만, 우리가 직접 지정해서 메모리 사용을 최적화할 수 있어요.

  * **명시적 지정**: `np.dtype`을 사용해서 `np.int32`(4바이트 정수)처럼 특정 데이터 타입을 명확하게 지정할 수 있어요.
    ```python
    import numpy as np

    # 기본적으로 파이썬 정수는 int64로 처리될 수 있어요.
    arr_default = np.array([1, 2, 3])
    print("기본 데이터 타입:", arr_default.dtype) # int64 (혹은 시스템에 따라 int32)

    # 4바이트 정수 (int32)로 명시적 지정
    arr_int32 = np.array([1, 2, 3], dtype=np.int32)
    print("int32 데이터 타입:", arr_int32.dtype) # int32

    # 2바이트 정수 (int16)로 명시적 지정
    arr_int16 = np.array([1, 2, 3], dtype=np.int16)
    print("int16 데이터 타입:", arr_int16.dtype) # int16
    ```
  * **문자열 표기법**: `'U10'` (최대 10자 유니코드 문자열), `'I4'` (4바이트 정수)처럼 간결한 문자열로도 데이터 타입을 지정할 수 있어요.
    ```python
    import numpy as np

    # 최대 5글자 유니코드 문자열 배열
    arr_str_u5 = np.array(['apple', 'banana', 'kiwi'], dtype='U5')
    print("U5 문자열 배열:", arr_str_u5)
    print("U5 문자열 배열의 데이터 타입:", arr_str_u5.dtype)
    # 결과:
    # U5 문자열 배열: ['apple' 'banan' 'kiwi'] (banana는 5글자로 잘림!)
    # U5 문자열 배열의 데이터 타입: <U5

    # 4바이트 정수 (I4) 배열
    arr_int_i4 = np.array([100, 200, 300], dtype='i4')
    print("I4 정수 배열:", arr_int_i4.dtype) # int32 (i4는 int32의 약자)
    ```
  * **왜 중요할까요?**: NumPy가 데이터를 자동으로 추론할 때, 실제 필요한 것보다 더 많은 메모리를 할당할 수 있어요. 이때 `U10`처럼 정확히 지정해주면 **메모리를 훨씬 효율적으로 사용**하고, 연산 속도도 빨라져요. 예를 들어, 1000개의 짧은 이름(최대 5글자)을 저장할 때, `U100`으로 자동 할당되면 각 이름당 100글자 공간이 예약되지만, `U5`로 지정하면 5글자 공간만 예약되어 20배의 메모리를 절약할 수 있어요. -->
