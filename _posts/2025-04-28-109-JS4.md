---
title: 7차시 6:JavaScript 4
layout: single
classes: wide
categories:
  - JS
toc: true # 이 포스트에서 목차를 활성화
toc_sticky: true # 목차를 고정할지 여부 (선택 사항)
---

## 6. 종합 실전 예제

### 6.1 사용자 대시보드

```js
async function loadDashboard(userId) {
  try {
    console.log('대시보드 로딩 시작...');
    
    // 1. 사용자 정보 가져오기
    const user = await getUser(userId);
    console.log('✓ 사용자 정보 로드');
    
    // 2. 사용자의 게시물과 통계를 동시에 가져오기 (병렬)
    const [posts, stats] = await Promise.all([
      getPosts(userId),
      getStats(userId)
    ]);
    console.log('✓ 게시물 & 통계 로드');
    
    // 3. 최근 게시물의 댓글 가져오기
    if (posts.length > 0) {
      const recentPost = posts[0];
      const comments = await getComments(recentPost.id);
      console.log('✓ 댓글 로드');
      
      return {
        user,
        posts,
        stats,
        recentComments: comments
      };
    }
    
    return { user, posts, stats };
    
  } catch (error) {
    console.error('대시보드 로딩 실패:', error);
    throw error;
  }
}

// 사용
loadDashboard(1)
  .then(dashboard => {
    console.log('대시보드 데이터:', dashboard);
  })
  .catch(error => {
    console.log('페이지를 불러올 수 없습니다.');
  });
```



### 6.2 검색 기능 (디바운싱)

```js
// 디바운스: 연속된 호출을 하나로 묶기
function debounce(func, delay) {
  let timeoutId;
  return function(...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => func(...args), delay);
  };
}

// 검색 함수
async function searchUsers(keyword) {
  if (!keyword) return [];
  
  try {
    console.log(`"${keyword}" 검색 중...`);
    const response = await fetch(`https://api.example.com/users?search=${keyword}`);
    const users = await response.json();
    return users;
  } catch (error) {
    console.error('검색 실패:', error);
    return [];
  }
}

// 디바운스 적용 (300ms 후에 검색)
const debouncedSearch = debounce(async (keyword) => {
  const results = await searchUsers(keyword);
  console.log('검색 결과:', results);
}, 300);

// 사용자가 타이핑할 때마다 호출
// 하지만 실제로는 타이핑을 멈춘 후 300ms 후에만 검색됨
debouncedSearch('철수'); // 검색 안됨
debouncedSearch('철수ㅇ'); // 검색 안됨
debouncedSearch('철수이'); // 300ms 후 검색!
```



### 6.3 이미지 업로드 진행률

```js
async function uploadImage(file) {
  const formData = new FormData();
  formData.append('image', file);
  
  try {
    console.log('업로드 시작...');
    
    const response = await fetch('https://api.example.com/upload', {
      method: 'POST',
      body: formData
    });
    
    if (!response.ok) {
      throw new Error('업로드 실패');
    }
    
    const result = await response.json();
    console.log('업로드 완료!', result);
    return result;
    
  } catch (error) {
    console.error('업로드 에러:', error);
    throw error;
  }
}

// 사용 (가상의 파일)
const fakeFile = new Blob(['이미지 데이터'], { type: 'image/png' });
uploadImage(fakeFile);
```



### 6.4 데이터 캐싱

```js
class DataCache {
  constructor() {
    this.cache = new Map();
    this.expirationTime = 5 * 60 * 1000; // 5분
  }
  
  // 캐시에서 가져오기
  get(key) {
    const item = this.cache.get(key);
    
    if (!item) return null;
    
    // 만료 확인
    if (Date.now() - item.timestamp > this.expirationTime) {
      this.cache.delete(key);
      return null;
    }
    
    console.log('캐시에서 가져옴:', key);
    return item.data;
  }
  
  // 캐시에 저장
  set(key, data) {
    this.cache.set(key, {
      data,
      timestamp: Date.now()
    });
  }
  
  // 캐시 지우기
  clear() {
    this.cache.clear();
  }
}

// 사용
const cache = new DataCache();

async function getUserWithCache(id) {
  // 1. 캐시 확인
  const cached = cache.get(`user-${id}`);
  if (cached) {
    return cached;
  }
  
  // 2. 없으면 API 호출
  console.log('API에서 가져옴:', id);
  const user = await getUser(id);
  
  // 3. 캐시에 저장
  cache.set(`user-${id}`, user);
  
  return user;
}

// 테스트
await getUserWithCache(1); // API 호출
await getUserWithCache(1); // 캐시에서 가져옴 (빠름!)
await getUserWithCache(1); // 캐시에서 가져옴 (빠름!)
```



### 6.5 무한 스크롤 데이터 로딩

```js
class InfiniteLoader {
  constructor(fetchFunction) {
    this.fetchFunction = fetchFunction;
    this.page = 1;
    this.isLoading = false;
    this.hasMore = true;
    this.allData = [];
  }
  
  async loadMore() {
    if (this.isLoading || !this.hasMore) {
      return;
    }
    
    this.isLoading = true;
    console.log(`페이지 ${this.page} 로딩 중...`);
    
    try {
      const data = await this.fetchFunction(this.page);
      
      if (data.length === 0) {
        this.hasMore = false;
        console.log('더 이상 데이터 없음');
      } else {
        this.allData.push(...data);
        this.page++;
        console.log(`로드 완료! 총 ${this.allData.length}개`);
      }
      
    } catch (error) {
      console.error('로딩 실패:', error);
    } finally {
      this.isLoading = false;
    }
  }
  
  getData() {
    return this.allData;
  }
}

// 페이지별 데이터 가져오기 함수
async function fetchPosts(page) {
  const response = await fetch(`https://jsonplaceholder.typicode.com/posts?_page=${page}&_limit=10`);
  return await response.json();
}

// 사용
const loader = new InfiniteLoader(fetchPosts);

// 여러 번 호출하여 데이터 계속 로드
await loader.loadMore(); // 페이지 1
await loader.loadMore(); // 페이지 2
await loader.loadMore(); // 페이지 3

console.log('모든 게시물:', loader.getData());
```





## 7. 비동기 처리 베스트 프랙티스 💡

### 7.1 항상 에러 처리하기
```js
// ❌ 나쁜 예
async function badExample() {
  const data = await fetch('/api/data');
  // 에러가 나면 앱이 멈춤!
}

// ✅ 좋은 예
async function goodExample() {
  try {
    const data = await fetch('/api/data');
    return data;
  } catch (error) {
    console.error('에러 발생:', error);
    return null; // 기본값 반환
  }
}
```



### 7.2 Promise.all로 병렬 처리
```js
// ❌ 느림: 순차 실행 (3초)
async function slow() {
  const a = await fetch('/api/a'); // 1초
  const b = await fetch('/api/b'); // 1초
  const c = await fetch('/api/c'); // 1초
}

// ✅ 빠름: 병렬 실행 (1초)
async function fast() {
  const [a, b, c] = await Promise.all([
    fetch('/api/a'),
    fetch('/api/b'),
    fetch('/api/c')
  ]);
}
```



### 7.3 불필요한 await 피하기
```js
// ❌ 불필요한 await
async function unnecessary() {
  return await getData(); // await 불필요
}

// ✅ 간단하게
async function better() {
  return getData(); // 이미 Promise 반환
}

// ✅ 하지만 에러 처리가 필요하면 await 사용
async function withErrorHandling() {
  try {
    return await getData();
  } catch (error) {
    console.error(error);
    return null;
  }
}
```



### 7.4 타임아웃 설정
```js
// 타임아웃 유틸리티
function timeout(ms) {
  return new Promise((_, reject) => {
    setTimeout(() => reject(new Error('타임아웃!')), ms);
  });
}

// 사용: 5초 안에 응답 없으면 에러
async function fetchWithTimeout(url) {
  try {
    const response = await Promise.race([
      fetch(url),
      timeout(5000) // 5초 제한
    ]);
    return await response.json();
  } catch (error) {
    console.error('요청 실패 또는 타임아웃:', error);
    return null;
  }
}
```



### 7.5 로딩 상태 관리 패턴
```js
async function fetchData() {
  const state = {
    loading: true,
    data: null,
    error: null
  };
  
  try {
    state.data = await fetch('/api/data').then(r => r.json());
  } catch (error) {
    state.error = error.message;
  } finally {
    state.loading = false;
  }
  
  return state;
}

// 사용
const result = await fetchData();
if (result.loading) {
  console.log('로딩 중...');
} else if (result.error) {
  console.log('에러:', result.error);
} else {
  console.log('데이터:', result.data);
}
```



## 8. 자주 하는 실수와 해결법 ⚠️

### 8.1 실수 1: await 없이 Promise 사용
```js
// ❌ 잘못된 코드
async function wrong() {
  const data = fetch('/api/data'); // Promise 객체가 반환됨!
  console.log(data); // Promise { <pending> }
  console.log(data.name); // undefined
}

// ✅ 올바른 코드
async function correct() {
  const response = await fetch('/api/data');
  const data = await response.json();
  console.log(data); // 실제 데이터
  console.log(data.name); // 제대로 된 값
}
```



### 8.2 실수 2: 반복문에서 잘못된 비동기 처리
```js
// ❌ 잘못된 코드: forEach에서 await
async function wrong(ids) {
  ids.forEach(async (id) => {
    const user = await getUser(id);
    console.log(user);
  });
  // forEach는 await를 기다려주지 않음!
}

// ✅ 올바른 코드 1: for...of 사용 (순차)
async function correct1(ids) {
  for (const id of ids) {
    const user = await getUser(id);
    console.log(user);
  }
}

// ✅ 올바른 코드 2: Promise.all 사용 (병렬)
async function correct2(ids) {
  const users = await Promise.all(
    ids.map(id => getUser(id))
  );
  users.forEach(user => console.log(user));
}
```



### 8.3 실수 3: async 함수 밖에서 await 사용
```js
// ❌ 에러: await는 async 함수 안에서만!
function wrong() {
  const data = await fetch('/api/data'); // SyntaxError!
}

// ✅ 해결법 1: async 함수로 만들기
async function correct1() {
  const data = await fetch('/api/data');
}

// ✅ 해결법 2: 즉시 실행 함수 (최상위 레벨)
(async () => {
  const data = await fetch('/api/data');
  console.log(data);
})();

// ✅ 해결법 3: .then() 사용
function correct3() {
  fetch('/api/data')
    .then(response => response.json())
    .then(data => console.log(data));
}
```



### 8.4 실수 4: 에러를 무시함
```js
// ❌ 위험한 코드
async function dangerous() {
  const data = await fetch('/api/data');
  // 에러가 나면 앱이 죽음!
  return data;
}

// ✅ 안전한 코드
async function safe() {
  try {
    const data = await fetch('/api/data');
    return data;
  } catch (error) {
    console.error('데이터 로딩 실패:', error);
    return null; // 또는 기본값
  }
}
```



### 8.5 실수 5: Promise를 기다리지 않음
```js
// ❌ 잘못된 코드
async function wrong() {
  const promise1 = getUser(1);
  const promise2 = getUser(2);
  
  // Promise 객체 자체를 사용하려고 함
  console.log(promise1.name); // undefined!
}

// ✅ 올바른 코드
async function correct() {
  const [user1, user2] = await Promise.all([
    getUser(1),
    getUser(2)
  ]);
  
  console.log(user1.name); // 정상 작동
}
```



## 9. 실습 문제 🎯

### 9.1 기본 Promise
```js
// TODO: 2초 후에 "안녕하세요!"를 반환하는 Promise를 만드세요
function greet() {
  // 여기에 코드 작성
}

// 테스트
greet().then(message => console.log(message)); // 2초 후: "안녕하세요!"
```

*   정답보기
    ```js
    function greet() {
        return new Promise((resolve) => {
            setTimeout(() => {
            resolve("안녕하세요!");
            }, 2000);
        });
    }
    ```




### 9.2 사용자 데이터 가져오기
```js
// TODO: 다음 함수를 완성하세요
// 1. 사용자 정보를 가져옵니다
// 2. 사용자의 게시물을 가져옵니다
// 3. { user, posts }를 반환합니다
// 4. 에러 처리를 포함하세요

async function getUserData(userId) {
  // 여기에 코드 작성
}

// 테스트
getUserData(1).then(data => console.log(data));
```

*   정답보기
    ```js
    async function getUserData(userId) {
        try {
            const user = await getUser(userId);
            const posts = await getPosts(userId);
            return { user, posts };
        } catch (error) {
            console.error('데이터 가져오기 실패:', error);
            return null;
        }
    }
    ```



### 9.3 병렬 처리
```js
// TODO: 세 명의 사용자 정보를 동시에 가져오는 함수를 작성하세요
// ID: 1, 2, 3

async function getThreeUsers() {
  // 여기에 코드 작성
}

// 테스트
getThreeUsers().then(users => console.log(users));
```

*   정답보기
    ```js
    async function getThreeUsers() {
        try {
                const [user1, user2, user3] = await Promise.all([
                getUser(1),
                getUser(2),
                getUser(3)
                ]);
            return [user1, user2, user3];
        } catch (error) {
            console.error('사용자 가져오기 실패:', error);
            return [];
        }
    }
    ```

### 9.4 fetch API
```js
// TODO: JSONPlaceholder API를 사용하여
// 모든 게시물을 가져오는 함수를 작성하세요
// URL: https://jsonplaceholder.typicode.com/posts

async function getAllPosts() {
  // 여기에 코드 작성
}

// 테스트
getAllPosts().then(posts => console.log(`게시물 ${posts.length}개`));
```

*   정답보기
    ```js
    async function getAllPosts() {
        try {
            const response = await fetch('https://jsonplaceholder.typicode.com/posts');
            
            if (!response.ok) {
            throw new Error(`HTTP 에러: ${response.status}`);
            }
            
            const posts = await response.json();
            return posts;
        } catch (error) {
            console.error('게시물 가져오기 실패:', error);
            return [];
        }
    }
    ```


### 9.5 재시도 로직 (도전!)
```js
// TODO: 실패하면 3번까지 재시도하는 함수를 작성하세요
// 각 재시도 사이에 1초 대기

async function fetchWithRetry(url, maxRetries = 3) {
  // 여기에 코드 작성
}

// 테스트
fetchWithRetry('https://jsonplaceholder.typicode.com/posts/1')
  .then(data => console.log('성공!', data))
  .catch(error => console.log('실패:', error));
```

*   정답보기
    ```js
    async function fetchWithRetry(url, maxRetries = 3) {
        for (let i = 0; i < maxRetries; i++) {
            try {
            const response = await fetch(url);
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }
            
            return await response.json();
            
            } catch (error) {
            console.log(`시도 ${i + 1}/${maxRetries} 실패`);
            
            // 마지막 시도에서도 실패하면 에러 던지기
            if (i === maxRetries - 1) {
                throw new Error('최대 재시도 횟수 초과');
            }
            
            // 1초 대기
            await new Promise(resolve => setTimeout(resolve, 1000));
            }
        }
    }
    ```

## 10. React에서 사용하기 (미리보기)

비동기 처리가 React에서 어떻게 사용되는지 간단히 살펴봅시다.

```js
import { useState, useEffect } from 'react';

function UserList() {
  // 상태 관리
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  // 컴포넌트 마운트 시 데이터 가져오기
  useEffect(() => {
    async function fetchUsers() {
      try {
        const response = await fetch('https://jsonplaceholder.typicode.com/users');
        const data = await response.json();
        setUsers(data);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    }
    
    fetchUsers();
  }, []); // 빈 배열: 마운트 시 1번만 실행
  
  // 로딩 중
  if (loading) return <div>로딩 중...</div>;
  
  // 에러 발생
  if (error) return <div>에러: {error}</div>;
  
  // 데이터 표시
  return (
    <ul>
      {users.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

**핵심 포인트:**
- `useState`: 데이터, 로딩, 에러 상태 관리
- `useEffect`: 컴포넌트 마운트 시 API 호출
- `async/await`: 비동기 데이터 가져오기
- 로딩/에러/성공 상태에 따른 UI 렌더링



## 11. 마무리 및 핵심 정리 ✨

### 11.1 꼭 기억해야 할 것들

1. **비동기란?** 시간이 걸리는 작업을 기다리는 동안 다른 일을 할 수 있게 하는 것

2. **Promise** = 미래에 완료될 작업의 약속
   - `.then()`: 성공 시
   - `.catch()`: 실패 시
   - `.finally()`: 항상

3. **async/await** = Promise를 더 쉽게 쓰는 문법 (최신, 권장!)
   - `async function`으로 선언
   - `await`로 Promise 기다리기
   - `try-catch`로 에러 처리

4. **fetch** = 서버와 통신하는 API
   - GET: 데이터 가져오기
   - POST: 데이터 보내기
   - PUT/PATCH: 데이터 수정
   - DELETE: 데이터 삭제

5. **Promise.all** = 여러 비동기 작업을 동시에 실행 (빠름!)



### 11.2 학습 로드맵

```
1. 콜백 함수 이해 (setTimeout)
   ↓
2. Promise 기초 (.then, .catch)
   ↓
3. async/await 마스터 ⭐⭐⭐
   ↓
4. fetch API 실전 사용
   ↓
5. 에러 처리 및 베스트 프랙티스
   ↓
6. React에서 활용 (useEffect + async/await)
```



### 11.3 다음 단계

이제 JavaScript의 비동기 처리를 이해했다면:
- ✅ React의 `useEffect`에서 API 호출 가능
- ✅ 사용자 데이터를 서버에서 가져와 화면에 표시 가능
- ✅ 로딩 상태와 에러 처리 가능
- ✅ 실시간 데이터 업데이트 구현 가능

**React 학습을 시작할 준비가 되었습니다!** 🚀



## 12. 부록: 유용한 패턴 모음

### 12.1 패턴 1: API 응답 래퍼
```js
async function apiCall(url, options = {}) {
  try {
    const response = await fetch(url, options);
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    
    const data = await response.json();
    return { success: true, data };
    
  } catch (error) {
    return { success: false, error: error.message };
  }
}

// 사용
const result = await apiCall('/api/users');
if (result.success) {
  console.log(result.data);
} else {
  console.error(result.error);
}
```



### 12.2 패턴 2: 순차 vs 병렬 선택
```js
async function smartFetch(urls, parallel = true) {
  if (parallel) {
    // 병렬 실행 (빠름)
    return await Promise.all(
      urls.map(url => fetch(url).then(r => r.json()))
    );
  } else {
    // 순차 실행 (안전)
    const results = [];
    for (const url of urls) {
      const response = await fetch(url);
      const data = await response.json();
      results.push(data);
    }
    return results;
  }
}
```



### 12.3 패턴 3: 조건부 fetch
```js
async function conditionalFetch(useCache = true) {
  const cacheKey = 'userData';
  
  if (useCache) {
    const cached = localStorage.getItem(cacheKey);
    if (cached) {
      console.log('캐시 사용');
      return JSON.parse(cached);
    }
  }
  
  console.log('서버에서 가져오기');
  const response = await fetch('/api/user');
  const data = await response.json();
  
  localStorage.setItem(cacheKey, JSON.stringify(data));
  return data;
}
```
