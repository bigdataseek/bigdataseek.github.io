---
title: 7차시 10:Swift3
layout: single
classes: wide
categories:
  - Swift
toc: true # 이 포스트에서 목차를 활성화
toc_sticky: true # 목차를 고정할지 여부 (선택 사항)
---

## 12. Subscripts

### **12.1 Subscripts란?**
- Subscripts는 인스턴스의 특정 값을 간편하게 설정하거나 조회할 수 있는 단축 문법을 제공합니다.
- 예를 들어, 배열이나 딕셔너리를 사용할 때 `array[index]` 또는 `dictionary[key]`와 같은 방식으로 데이터에 접근하는 것이 가능합니다.
- 사용자 정의 타입(클래스, 구조체, 열거형)에서도 Subscripts를 정의하여 비슷한 방식으로 데이터를 조작할 수 있습니다.

### **12.2 Subscripts의 기본 문법**
Subscripts는 `subscript` 키워드를 사용하여 정의됩니다. 기본적인 형식은 다음과 같습니다:

```swift
subscript(index: Int) -> Int {
    get {
        // subscript를 통해 값을 반환하는 코드
    }
    set(newValue) {
        // subscript를 통해 값을 설정하는 코드
    }
}
```

- **읽기 전용 Subscripts**: 만약 Subscripts가 읽기만 가능하다면 `get`과 `set`을 생략하고 바로 값을 반환하도록 구현할 수 있습니다.

```swift
subscript(index: Int) -> Int {
    return someArray[index]
}
```

### **12.3 Subscripts의 매개변수**
- Subscripts는 하나 이상의 매개변수를 가질 수 있으며, 매개변수의 타입은 제한이 없습니다.
- 매개변수 이름은 외부 이름과 내부 이름을 모두 가질 수 있습니다. 외부 이름은 호출 시 사용되고, 내부 이름은 구현 내부에서 사용됩니다.

예시:
```swift
struct Matrix {
    var grid: [[Int]]

    subscript(row: Int, column: Int) -> Int {
        get {
            return grid[row][column]
        }
        set {
            grid[row][column] = newValue
        }
    }
}
```

위의 예시에서는 행(`row`)과 열(`column`) 두 개의 매개변수를 사용하여 2차원 배열의 값을 접근하거나 수정할 수 있습니다.

### **12.4 Subscripts의 활용 예시**
1\.읽기/쓰기 가능한 Subscripts
```swift
struct TimesTable {
    let multiplier: Int

    subscript(index: Int) -> Int {
        return multiplier * index
    }
}

let threeTimesTable = TimesTable(multiplier: 3)
print(threeTimesTable[6]) // 출력: 18
```

2\.읽기 전용 Subscripts
```swift
struct FibonacciSequence {
    private var sequence: [Int] = [0, 1]

    subscript(index: Int) -> Int {
        while sequence.count <= index {
            let nextValue = sequence[sequence.count - 1] + sequence[sequence.count - 2]
            sequence.append(nextValue)
        }
        return sequence[index]
    }
}

let fib = FibonacciSequence()
print(fib[7]) // 출력: 13
```

### **12.5 Subscripts의 특징**
- **다양한 매개변수 타입 지원**: Subscripts는 정수뿐만 아니라 문자열, 부동소수점 등 다양한 타입의 매개변수를 사용할 수 있습니다.
- **오버로딩 가능**: 동일한 타입 내에서 여러 개의 Subscripts를 정의할 수 있습니다. 이때 매개변수의 개수나 타입에 따라 적절한 Subscripts가 선택됩니다.
- **타입 프로퍼티에도 적용 가능**: `static` 키워드를 사용하여 타입 자체에 Subscripts를 정의할 수도 있습니다.

```swift
struct LevelTracker {
    static var highestUnlockedLevel = 1

    static subscript(level: Int) -> Bool {
        get {
            return level <= highestUnlockedLevel
        }
        set {
            if newValue && level > highestUnlockedLevel {
                highestUnlockedLevel = level
            }
        }
    }
}

LevelTracker[3] = true
print(LevelTracker.highestUnlockedLevel) // 출력: 3
```

### **12.6 주의사항**
- Subscripts는 단순히 데이터를 접근하거나 설정하기 위한 단축 문법일 뿐, 복잡한 로직을 포함시키는 것은 피해야 합니다.
- Subscripts의 목적은 직관적이고 간결한 인터페이스를 제공하는 것이므로, 과도하게 많은 매개변수를 사용하거나 복잡한 연산을 수행하는 것은 권장되지 않습니다.

## 13. Inheritance

### **13.1 상속(Inheritance)이란?**
- **상속**은 클래스가 다른 클래스의 속성(property), 메서드(method), 기타 특성을 물려받는 메커니즘입니다.
- Swift에서는 **클래스**와 **프로토콜**에서 상속을 지원합니다. (구조체(struct)와 열거형(enum)은 상속을 지원하지 않음)
- 상속을 통해 코드의 재사용성을 높이고, 계층적 구조를 설계할 수 있습니다.

**주요 용어**
- **슈퍼클래스(Superclass)**: 다른 클래스에게 자신의 특성을 물려주는 클래스.
- **서브클래스(Subclass)**: 슈퍼클래스로부터 특성을 물려받는 클래스.
- **재정의(Override)**: 서브클래스가 슈퍼클래스의 메서드, 프로퍼티, 또는 서브스크립트를 변경하여 사용하는 것.

### **13.2 기본 문법**
1\.**클래스 상속 선언**
```swift
class 슈퍼클래스 {
    // 슈퍼클래스의 속성 및 메서드
}

class 서브클래스: 슈퍼클래스 {
    // 서브클래스의 추가 속성 및 메서드
}
```

2\.**예시**
```swift
class Vehicle {
    var currentSpeed = 0.0
    
    func description() -> String {
        return "현재 속도는 \(currentSpeed) km/h 입니다."
    }
}

class Bicycle: Vehicle {
    var hasBasket = false
}
```
- `Bicycle` 클래스는 `Vehicle` 클래스를 상속받아 `currentSpeed`와 `description()` 메서드를 사용할 수 있습니다.
- `Bicycle` 클래스는 자체적으로 `hasBasket`이라는 새로운 프로퍼티를 추가했습니다.

### **13.3 재정의(Overriding)**
서브클래스는 슈퍼클래스의 메서드, 프로퍼티, 서브스크립트를 재정의하여 동작을 변경할 수 있습니다. 재정의 시에는 반드시 `override` 키워드를 사용해야 합니다.

1\.**메서드 재정의**
```swift
class Car: Vehicle {
    override func description() -> String {
        return "자동차의 현재 속도는 \(currentSpeed) km/h 입니다."
    }
}
```
- `Car` 클래스는 `Vehicle` 클래스의 `description()` 메서드를 재정의하여 새로운 반환값을 제공합니다.

2\.Getter/Setter 재정의
```swift
class Car: Vehicle {
    override var currentSpeed: Double {
        willSet {
            print("속도가 \(newValue)로 변경됩니다.")
        }
    }
}
```
- `willSet`과 `didSet`을 사용하여 프로퍼티 값이 변경되기 전/후에 특정 작업을 수행할 수 있습니다.

3\.프로퍼티 감시자(Property Observer)
```swift
class Car: Vehicle {
    override var currentSpeed: Double {
        didSet {
            if currentSpeed > 100 {
                print("속도가 너무 빠릅니다!")
            }
        }
    }
}
```

### **13.4 Super 키워드**
- 서브클래스에서 슈퍼클래스의 메서드나 프로퍼티를 호출하려면 `super` 키워드를 사용합니다.
- 예: `super.description()` 또는 `super.currentSpeed`.

1\.**예시**
```swift
class Car: Vehicle {
    override func description() -> String {
        let superDescription = super.description()
        return "\(superDescription) (자동차)"
    }
}
```

### **13.5 Final 키워드**
- `final` 키워드를 사용하면 특정 메서드나 클래스를 더 이상 상속하거나 재정의할 수 없도록 제한할 수 있습니다.
- 예: `final class`, `final func`.

```swift
final class FinalClass {
    // 이 클래스는 상속될 수 없습니다.
}
```

### **13.6 Deinitialization**
- 클래스 인스턴스가 메모리에서 해제될 때 호출되는 `deinit` 메서드를 정의할 수 있습니다.
- 서브클래스에서 `deinit`을 정의할 경우, 슈퍼클래스의 `deinit`도 자동으로 호출됩니다.

```swift
class Vehicle {
    deinit {
        print("Vehicle 인스턴스가 해제되었습니다.")
    }
}

class Car: Vehicle {
    deinit {
        print("Car 인스턴스가 해제되었습니다.")
    }
}
```

### **13.7 상속과 관련된 주요 규칙**
1. **클래스만 상속 가능**: Swift에서는 클래스만 상속할 수 있으며, 구조체와 열거형은 상속을 지원하지 않습니다.
2. **단일 상속**: Swift는 다중 상속을 지원하지 않습니다. 즉, 한 클래스는 단 하나의 슈퍼클래스만 가질 수 있습니다.
3. **프로토콜 다중 준수**: 클래스는 여러 프로토콜을 동시에 채택할 수 있습니다.

### **13.8 요약**
- **상속**은 클래스 간의 계층적 관계를 형성하며, 코드 재사용성을 높이는 중요한 개념입니다.
- **재정의**를 통해 서브클래스는 슈퍼클래스의 동작을 수정하거나 확장할 수 있습니다.
- `super` 키워드를 사용하여 슈퍼클래스의 메서드나 프로퍼티에 접근할 수 있습니다.
- `final` 키워드를 사용하여 상속이나 재정의를 제한할 수 있습니다.

## 14. Initialization

### **14.1 초기화(Initialization)란?**
초기화는 클래스, 구조체 또는 열거형의 새 인스턴스를 준비하는 과정입니다. 초기화를 통해 저장 프로퍼티에 초기값을 설정하거나, 인스턴스 사용 전 필요한 설정 작업을 수행할 수 있습니다.

Swift에서는 초기화를 위해 **이니셜라이저(initializer)**라는 특별한 메서드를 사용합니다. 이니셜라이저는 `init` 키워드로 정의됩니다.

### **14.2 초기화의 기본 규칙**
1. **저장 프로퍼티 초기화 필수**  
   모든 저장 프로퍼티는 초기화가 끝날 때까지 반드시 값을 가져야 합니다. 이를 위해:
   - 저장 프로퍼티에 기본값을 할당하거나,
   - 이니셜라이저에서 명시적으로 값을 설정해야 합니다.

2. **옵셔널(Optional) 프로퍼티**  
   옵셔널 타입의 프로퍼티는 초기화 시 기본값을 할당하지 않아도 됩니다. 자동으로 `nil`로 초기화됩니다.

3. **지연 저장 프로퍼티(Lazy Stored Property)**  
   `lazy` 키워드를 사용한 프로퍼티는 초기화 시점에 값을 할당하지 않고, 처음 접근할 때 초기화됩니다.

### **14.3 이니셜라이저의 종류**
1\. **디자인 이니셜라이저(Designated Initializer)**
- 클래스의 주요 이니셜라이저입니다.
- 모든 저장 프로퍼티를 초기화하며, 클래스의 전체 초기화 과정을 담당합니다.
- 클래스에는 하나 이상의 디자인 이니셜라이저가 있을 수 있습니다.

```swift
class Person {
    var name: String
    var age: Int

    // 디자인 이니셜라이저
    init(name: String, age: Int) {
        self.name = name
        self.age = age
    }
}
```

2\. **편의 이니셜라이저(Convenience Initializer)**
- 보조적인 역할을 하며, 디자인 이니셜라이저를 호출하여 간단히 초기화를 완료합니다.
- `convenience` 키워드로 선언합니다.

```swift
class Person {
    var name: String
    var age: Int

    init(name: String, age: Int) {
        self.name = name
        self.age = age
    }

    // 편의 이니셜라이저
    convenience init(name: String) {
        self.init(name: name, age: 0)
    }
}
```

3\. **구조체 멤버와이즈 이니셜라이저(Memberwise Initializer)**
- 구조체는 자동으로 멤버와이즈 이니셜라이저를 제공합니다.
- 저장 프로퍼티 이름을 매개변수로 받아 초기화를 수행합니다.

```swift
struct Point {
    var x: Double
    var y: Double
}

// 자동으로 제공되는 멤버와이즈 이니셜라이저
let point = Point(x: 3.0, y: 4.0)
```

### **14.4 클래스 상속과 초기화**
클래스는 상속 관계에서 초기화 규칙을 따라야 합니다.

1\. **디자인 이니셜라이저 상속**
- 서브클래스는 슈퍼클래스의 디자인 이니셜라이저를 상속받을 수 있습니다.
- 서브클래스에서 새로운 저장 프로퍼티를 추가하면, 이를 초기화해야 합니다.

```swift
class Vehicle {
    var numberOfWheels = 0
}

class Bicycle: Vehicle {
    override init() {
        super.init()
        numberOfWheels = 2
    }
}
```

2\. **자동 상속 규칙**
- 서브클래스가 추가 이니셜라이저를 정의하지 않으면, 슈퍼클래스의 디자인 이니셜라이저와 편의 이니셜라이저를 자동으로 상속받습니다.

### **14.5 실패 가능한 이니셜라이저(Failable Initializer)**
- 초기화 과정에서 실패 가능성을 표현하기 위해 사용합니다.
- `init?` 키워드로 정의하며, 실패 시 `nil`을 반환합니다.

```swift
struct Animal {
    let species: String

    init?(species: String) {
        if species.isEmpty {
            return nil
        }
        self.species = species
    }
}

let animal = Animal(species: "") // nil
```

### **14.6 필수 이니셜라이저(Required Initializer)**
- 서브클래스에서 반드시 구현해야 하는 이니셜라이저입니다.
- `required` 키워드로 표시합니다.

```swift
class Shape {
    required init() {
        // 공통 초기화 로직
    }
}

class Circle: Shape {
    required init() {
        super.init()
        // 추가 초기화 로직
    }
}
```

### **14.7 Deinitialization (역초기화)**
- 클래스 인스턴스가 메모리에서 해제되기 직전에 호출되는 `deinit` 메서드를 정의할 수 있습니다.
- 주로 리소스 정리 작업에 사용됩니다.

```swift
class File {
    var filename: String

    init(filename: String) {
        self.filename = filename
    }

    deinit {
        print("\(filename) 파일이 닫혔습니다.")
    }
}
```

### **14.8 핵심 포인트 요약**
1. **초기화는 모든 저장 프로퍼티를 초기화하는 과정이다.**
2. **디자인 이니셜라이저와 편의 이니셜라이저는 각각 주요 및 보조 초기화를 담당한다.**
3. **상속 관계에서는 슈퍼클래스의 초기화 규칙을 따라야 한다.**
4. **실패 가능한 이니셜라이저(`init?`)는 초기화 실패 시 `nil`을 반환한다.**
5. **`deinit`은 인스턴스가 메모리에서 해제될 때 호출된다.**

## 15.**Deinitialization**

### **15.1 개요**
- **Deinitializer**는 클래스 인스턴스가 메모리에서 해제되기 직전에 호출되는 특별한 메서드입니다.
- Swift에서는 자동 메모리 관리(Automatic Reference Counting, ARC)를 통해 메모리를 관리하므로, 대부분의 경우 수동으로 메모리를 해제할 필요가 없습니다.
- 하지만 특정 리소스(예: 파일 핸들, 네트워크 연결 등)를 해제하거나 정리해야 하는 경우 Deinitializer를 사용할 수 있습니다.

### 15.2 **Deinitializer의 특징**
1. **클래스 전용**: Deinitializer는 클래스 타입에만 정의할 수 있습니다. 구조체나 열거형에는 사용할 수 없습니다.
2. **자동 호출**: Deinitializer는 인스턴스가 더 이상 참조되지 않아 ARC에 의해 메모리에서 해제될 때 자동으로 호출됩니다.
3. **파라미터 없음**: Deinitializer는 파라미터를 받지 않습니다.
4. **명시적 호출 불가**: 프로그래머가 직접 호출할 수 없으며, 시스템이 자동으로 관리합니다.

### 15.3 **Deinitializer의 문법**
```swift
deinit {
    // 정리 코드 작성
}
```
- `deinit` 키워드를 사용하여 정의합니다.
- 중괄호 `{}` 안에 필요한 정리 작업을 작성합니다.

### 15.4 **예제 코드**
다음은 Deinitializer를 사용한 간단한 예제입니다:

```swift
class Bank {
    static var coinsInBank = 10_000
    static func distribute(coins: Int) -> Int {
        let coinsToDistribute = min(coins, coinsInBank)
        coinsInBank -= coinsToDistribute
        return coinsToDistribute
    }
    
    static func receive(coins: Int) {
        coinsInBank += coins
    }
}

class Player {
    var coinsInPurse: Int
    
    init(coins: Int) {
        coinsInPurse = Bank.distribute(coins: coins)
    }
    
    func win(coins: Int) {
        coinsInPurse += Bank.distribute(coins: coins)
    }
    
    deinit {
        Bank.receive(coins: coinsInPurse)
        print("Player deinitialized. Returned \(coinsInPurse) coins to the bank.")
    }
}

// Player 인스턴스 생성 및 사용
var playerOne: Player? = Player(coins: 100)
playerOne?.win(coins: 50)

// 인스턴스 해제
playerOne = nil
// 출력: "Player deinitialized. Returned 150 coins to the bank."
```

### 15.5 **설명**
1. **Bank 클래스**:
   - 은행의 코인을 관리하는 클래스입니다.
   - `distribute` 메서드로 코인을 분배하고, `receive` 메서드로 코인을 회수합니다.

2. **Player 클래스**:
   - 플레이어가 소유한 코인을 관리합니다.
   - `init`에서 은행으로부터 코인을 분배받고, `deinit`에서 소유한 코인을 은행에 반환합니다.

3. **Deinitializer 동작**:
   - `playerOne` 변수가 `nil`로 설정되면서 참조 카운트가 0이 되고, ARC에 의해 메모리에서 해제됩니다.
   - 이때 `deinit`이 호출되어 플레이어가 소유한 코인이 은행으로 반환됩니다.

### 15.6 **주의사항**
1. **순환 참조(Circular Reference)**:
   - 두 개 이상의 객체가 서로를 강하게 참조하면 메모리 누수가 발생할 수 있습니다.
   - 이를 방지하기 위해 `weak` 또는 `unowned` 키워드를 사용하여 참조를 약하게 설정하세요.

2. **Deinitializer 호출 순서**:
   - 상속된 클래스의 경우, 자식 클래스의 `deinit`이 먼저 호출되고, 그 후 부모 클래스의 `deinit`이 호출됩니다.

### 15.7 **정리**
Deinitializer는 클래스 인스턴스가 메모리에서 해제되기 전에 필요한 정리 작업을 수행하는 데 사용됩니다. Swift의 ARC 덕분에 대부분의 메모리 관리는 자동으로 처리되지만, 특정 리소스를 명시적으로 해제해야 할 때 유용하게 활용할 수 있습니다.

## 16.Optional Chaining

### 16.1 **옵셔널 체이닝(Optional Chaining)이란?**
옵셔널 체이닝은 옵셔널 값에 접근하거나 메서드를 호출할 때, 해당 옵셔널이 `nil`인지 아닌지를 확인하면서 안전하게 작업을 수행할 수 있는 방법입니다. 만약 옵셔널 값이 `nil`이라면, 옵셔널 체이닝은 실패하지만 앱이 크래시되지 않습니다. 대신 결과값으로 `nil`을 반환합니다.

옵셔널 체이닝은 특히 복잡한 객체 계층 구조에서 유용합니다. 예를 들어, 여러 단계의 프로퍼티나 메서드를 연속적으로 호출해야 하는 경우, 각 단계마다 `nil`을 확인하지 않고도 안전하게 작업을 수행할 수 있습니다.

### 16.2 **옵셔널 체이닝의 기본 문법**
옵셔널 체이닝은 물음표(`?`)를 사용하여 표현합니다. 이는 "이 값이 `nil`이 아니라면 다음 작업을 수행하라"는 의미입니다.

```swift
let result = someOptional?.someProperty
```

- `someOptional`이 `nil`이 아니면 `someProperty`에 접근합니다.
- `someOptional`이 `nil`이면 전체 표현식의 결과는 `nil`이 됩니다.

### 16.3 **옵셔널 체이닝의 주요 사용 사례**

1\. **프로퍼티 접근**
옵셔널 체이닝을 사용하여 옵셔널 타입의 인스턴스가 가지고 있는 프로퍼티에 접근할 수 있습니다.

```swift
class Person {
    var residence: Residence?
}

class Residence {
    var numberOfRooms = 1
}

let john = Person()

// 옵셔널 체이닝을 사용한 프로퍼티 접근
if let roomCount = john.residence?.numberOfRooms {
    print("John's residence has \(roomCount) room(s).")
} else {
    print("Unable to retrieve the number of rooms.")
}
```

위 예제에서 `john.residence`가 `nil`이므로, `numberOfRooms`에 접근하지 못하고 `else` 블록이 실행됩니다.

2\. **메서드 호출**
옵셔널 체이닝을 사용하여 옵셔널 값의 메서드를 호출할 수도 있습니다. 메서드가 성공적으로 호출되었는지 여부를 확인할 수 있습니다.

```swift
func printNumberOfRooms() {
    print("Number of rooms printed.")
}

let john = Person()
john.residence?.printNumberOfRooms() // residence가 nil이므로 메서드 호출이 실행되지 않음
```

3\. **서브스크립트(Subscript) 접근**
옵셔널 체이닝을 사용하여 서브스크립트에도 접근할 수 있습니다.

```swift
class Residence {
    var rooms = ["Living Room", "Bedroom"]
    subscript(index: Int) -> String? {
        return rooms.indices.contains(index) ? rooms[index] : nil
    }
}

let john = Person()
if let firstRoom = john.residence?[0] {
    print("The first room is \(firstRoom).")
} else {
    print("Unable to access the room.")
}
```

4\. **다중 옵셔널 체이닝**
여러 단계의 옵셔널 체이닝을 연결할 수 있습니다. 이는 깊이 중첩된 객체 구조에서 유용합니다.

```swift
class Address {
    var buildingName: String?
}

class Residence {
    var address: Address?
}

class Person {
    var residence: Residence?
}

let john = Person()
if let buildingName = john.residence?.address?.buildingName {
    print("John's building name is \(buildingName).")
} else {
    print("Unable to retrieve the building name.")
}
```

### 16.4 **옵셔널 체이닝과 강제 언래핑의 차이**
옵셔널 체이닝은 안전하게 값을 접근하거나 메서드를 호출하는 반면, 강제 언래핑(`!`)은 옵셔널 값이 반드시 존재한다고 가정합니다. 만약 강제 언래핑 시도 시 값이 `nil`이라면 런타임 에러가 발생합니다.

```swift
let roomCount = john.residence!.numberOfRooms // residence가 nil이면 크래시 발생
```

따라서, 가능하다면 강제 언래핑보다는 옵셔널 체이닝을 사용하는 것이 안전합니다.

### 16.5 **옵셔널 체이닝의 결과 타입**
옵셔널 체이닝의 결과는 항상 옵셔널 타입입니다. 따라서 결과값을 사용하기 전에 반드시 옵셔널 바인딩이나 다른 방식으로 언래핑해야 합니다.

```swift
let roomCount: Int? = john.residence?.numberOfRooms
```

### 16.6 **옵셔널 체이닝의 장점**
1. **안전성**: `nil` 값으로 인한 런타임 에러를 방지합니다.
2. **간결성**: 복잡한 조건문 없이도 간단히 옵셔널 값을 처리할 수 있습니다.
3. **유연성**: 여러 단계의 객체 계층 구조에서도 쉽게 접근할 수 있습니다.

### 16.7 **요약**
옵셔널 체이닝은 Swift에서 옵셔널 값에 접근하거나 메서드를 호출할 때 매우 유용한 기능입니다. 이를 통해 `nil` 값을 안전하게 처리할 수 있으며, 코드를 더 간결하고 읽기 쉽게 만들 수 있습니다. 옵셔널 체이닝은 다음과 같은 상황에서 사용됩니다:
- 프로퍼티 접근
- 메서드 호출
- 서브스크립트 접근
- 다중 체이닝

## 17.Error Handling

오류 처리는 프로그램 실행 중 발생할 수 있는 예외 상황을 적절히 처리하는 방법입니다. Swift에서는 오류를 던지고(throw), 잡고(catch), 전파하고(propagate) 처리하는 강력한 메커니즘을 제공합니다.

### **17.1 오류 표현하기**
Swift에서는 `Error` 프로토콜을 준수하는 타입을 사용하여 오류를 표현합니다. 일반적으로 열거형(enum)을 사용하여 오류 유형을 정의합니다.

```swift
enum FileError: Error {
    case fileNotFound
    case fileCorrupted
    case insufficientPermissions
}
```

- 위의 예시에서 `FileError`는 파일 관련 오류를 나타내는 열거형입니다.
- 각 케이스는 특정 오류 상황을 나타냅니다.

### **17.2 오류 던지기 (Throwing Errors)**
함수나 메서드에서 오류가 발생할 가능성이 있다면, 해당 함수의 반환 타입 앞에 `throws` 키워드를 추가합니다. 이 함수는 오류를 던질 수 있습니다.

```swift
func readFile(named filename: String) throws -> String {
    if filename.isEmpty {
        throw FileError.fileNotFound
    }
    // 파일 읽기 로직
    return "File content"
}
```

- `throws` 키워드는 함수가 오류를 던질 수 있음을 나타냅니다.
- `throw` 키워드를 사용하여 특정 오류를 던집니다.

### **17.3 오류 처리하기**
오류가 발생할 수 있는 함수를 호출할 때는 `do-catch` 구문을 사용하여 오류를 처리합니다.

1\.**예제: do-catch 사용**
```swift
do {
    let content = try readFile(named: "example.txt")
    print("File content: \(content)")
} catch FileError.fileNotFound {
    print("Error: File not found.")
} catch FileError.fileCorrupted {
    print("Error: File is corrupted.")
} catch {
    print("An unexpected error occurred: \(error).")
}
```

- `try` 키워드는 오류가 발생할 수 있는 코드를 호출할 때 사용합니다.
- `catch` 블록은 발생한 오류를 처리합니다. 특정 오류 유형을 처리하거나, 기본적인 `catch` 블록으로 모든 오류를 처리할 수 있습니다.

### **17.4 오류 전파 (Propagating Errors)**
함수 내부에서 오류가 발생하면, 이를 호출자에게 전파할 수 있습니다. 호출자는 다시 오류를 처리하거나 더 상위로 전파할 수 있습니다.

1\.**예제: 오류 전파**
```swift
func processFile(named filename: String) throws {
    let content = try readFile(named: filename)
    print("Processing content: \(content)")
}
```

- `processFile` 함수는 `readFile` 함수에서 발생한 오류를 호출자에게 전파합니다.
- 호출자는 `try`와 함께 이 함수를 호출해야 합니다.

### **17.5 오류 변환 (Converting Errors to Optional Values)**
오류를 무시하고 결과를 옵셔널 값으로 변환하려면 `try?`를 사용할 수 있습니다.

1\.**예제: try? 사용**
```swift
if let content = try? readFile(named: "example.txt") {
    print("File content: \(content)")
} else {
    print("Failed to read the file.")
}
```

- `try?`는 오류가 발생하면 `nil`을 반환합니다.

### **17.6 강제 오류 처리 (Forced Try)**
오류가 절대 발생하지 않을 것이라고 확신할 때는 `try!`를 사용할 수 있습니다. 하지만 오류가 발생하면 런타임 오류가 발생합니다.

1\.**예제: try! 사용**
```swift
let content = try! readFile(named: "example.txt")
print("File content: \(content)")
```

- `try!`는 신중하게 사용해야 합니다.

### **17.7 defer를 사용한 정리 작업**
`defer` 키워드는 함수가 종료되기 직전에 실행될 코드를 정의합니다. 오류가 발생하더라도 `defer` 블록은 항상 실행됩니다.

1\.**예제: defer 사용**
```swift
func openFile(named filename: String) throws {
    print("Opening file...")
    defer {
        print("Closing file...")
    }
    if filename.isEmpty {
        throw FileError.fileNotFound
    }
    print("File opened successfully.")
}
```

- `defer`는 리소스 해제 또는 정리 작업에 유용합니다.

### **17.8 오류 처리의 장점**
- **안정성**: 예상치 못한 상황에서도 프로그램이 안정적으로 동작하도록 보장합니다.
- **명확성**: 오류 유형과 처리 방식을 명확히 정의할 수 있습니다.
- **유연성**: 다양한 오류 처리 패턴(`do-catch`, `try?`, `try!`)을 지원합니다.

### **17.9 요약**
Swift의 오류 처리는 다음과 같은 주요 요소로 구성됩니다:
1. `Error` 프로토콜을 준수하는 타입으로 오류를 정의합니다.
2. `throws` 키워드를 사용하여 오류를 던질 수 있는 함수를 정의합니다.
3. `do-catch` 구문을 사용하여 오류를 처리합니다.
4. `try?` 또는 `try!`를 사용하여 간단히 처리하거나 강제로 실행합니다.
5. `defer`를 사용하여 정리 작업을 보장합니다.


## 18.Concurrency
### **18.1 동시성의 기본 개념**
- **비동기 작업(Asynchronous Tasks)**: 특정 작업이 완료될 때까지 기다리는 동안 다른 작업을 수행할 수 있는 방식입니다.
- **병렬 처리(Parallelism)**: 여러 작업을 동시에 실행하여 처리 속도를 높이는 방식입니다.
- **스레드(Thread)**: 운영 체제에서 제공하는 실행 단위로, Swift에서는 직접 스레드를 관리하지 않고 고수준 추상화를 사용합니다.

### **18.2 Swift 동시성의 핵심 구성 요소**

1\.**`async`와 `await`**
- **`async`**: 함수 또는 메서드가 비동기적으로 실행됨을 나타냅니다.
- **`await`**: 비동기 함수의 결과를 기다리는 키워드입니다. `await`은 비동기 작업이 완료될 때까지 현재 코드의 실행을 일시 중단합니다.
  
**예시:**
```swift
func fetchData() async throws -> Data {
    let url = URL(string: "https://example.com/data")!
    let (data, _) = try await URLSession.shared.data(from: url)
    return data
}
```

- 위 코드에서 `await`은 네트워크 요청이 완료될 때까지 기다립니다.

2\.**Task와 Task Group**
- **Task**: 비동기 작업을 실행하는 단위입니다. 독립적으로 실행되며, 필요에 따라 취소할 수 있습니다.
- **Task Group**: 여러 개의 비동기 작업을 그룹화하여 관리할 수 있습니다.

**예시:**
```swift
Task {
    do {
        let data = try await fetchData()
        print("데이터 로드 성공: \(data)")
    } catch {
        print("에러 발생: \(error)")
    }
}
```

3\.**Actor**
- **Actor**: 데이터 경쟁(Data Race)을 방지하기 위해 설계된 동시성 모델입니다. Actor 내부의 상태는 한 번에 하나의 작업만 접근할 수 있습니다.
  
**예시:**
```swift
actor Counter {
    private var count = 0
    
    func increment() {
        count += 1
    }
    
    func getCount() -> Int {
        return count
    }
}

let counter = Counter()
Task {
    await counter.increment()
    print(await counter.getCount()) // 출력: 1
}
```

- Actor는 스레드 안전성을 보장하며, 상태 변경 시 충돌을 방지합니다.

4\.**AsyncSequence**
- **AsyncSequence**: 비동기적으로 값을 생성하는 시퀀스입니다. 일반적인 `for-in` 루프처럼 사용할 수 있습니다.
  
**예시:**
```swift
import Foundation

let url = URL(string: "https://example.com/stream")!
let stream = URLSession.shared.bytes(from: url)

Task {
    for try await byte in stream {
        print(byte)
    }
}
```

### **18.3 동시성의 장점**
1. **코드 간결성**: `async/await`을 사용하면 콜백 지옥(Callback Hell)을 피할 수 있습니다.
2. **스레드 안전성**: Actor와 같은 도구를 통해 데이터 경쟁을 방지할 수 있습니다.
3. **성능 향상**: 비동기 작업을 통해 애플리케이션이 더 효율적으로 리소스를 활용할 수 있습니다.

### **18.4 주의사항**
- **에러 처리**: 비동기 함수는 `throws`를 사용하여 에러를 던질 수 있으므로, 적절한 에러 처리가 필요합니다.
- **작업 취소**: `Task`는 취소될 수 있으므로, 작업이 취소되었는지 확인하고 적절히 대응해야 합니다.
  
**예시:**
```swift
Task {
    try? await Task.sleep(nanoseconds: 1_000_000_000)
    if Task.isCancelled {
        print("작업이 취소되었습니다.")
        return
    }
    print("작업 완료")
}
```

### **18.5 실무에서의 활용**
- **네트워크 요청**: API 호출과 같은 네트워크 작업은 비동기적으로 처리해야 합니다.
- **파일 I/O**: 파일 읽기/쓰기는 시간이 걸릴 수 있으므로 비동기 처리가 적합합니다.
- **UI 업데이트**: UI 관련 작업은 메인 스레드에서 실행되어야 하며, 비동기 작업 후 메인 스레드로 전환해야 합니다.

**예시:**
```swift
Task {
    let data = try await fetchData()
    await MainActor.run {
        updateUI(with: data)
    }
}
```

## 19.Macros

### **19.1 Macros란?**
Swift의 **Macros**는 소스 코드를 컴파일하기 전에 프로그램이 자동으로 코드를 생성하거나 변환할 수 있도록 해주는 기능입니다. 이를 통해 반복적인 코드를 줄이고, 더 안전하고 효율적인 코드를 작성할 수 있습니다. 

Macros는 크게 두 가지 유형으로 나뉩니다:
- **Freestanding Macros**: 독립적으로 사용되는 매크로.
- **Attached Macros**: 특정 선언(예: 함수, 구조체 등)에 연결되어 동작하는 매크로.

### **19.2 Macros의 동작 원리**
Macros는 다음과 같은 방식으로 동작합니다:
1. **소스 코드 분석**: 개발자가 작성한 코드에서 Macro를 식별합니다.
2. **코드 변환**: Macro가 지정된 위치에서 추가적인 코드를 생성하거나 수정합니다.
3. **컴파일**: 변환된 코드가 최종적으로 컴파일됩니다.

Swift의 Macros는 **플러그인 시스템**을 통해 확장 가능하며, 이를 통해 사용자 정의 매크로도 만들 수 있습니다.

### **19.3 Freestanding Macros**
Freestanding Macros는 함수처럼 호출되며, 코드 내에서 독립적으로 사용됩니다. 예를 들어, `#warning` 또는 `#error`와 같은 기존의 Swift 디렉티브도 Freestanding Macro의 일종입니다.

1\.**예시**
```swift
#warning("이 부분은 추후 수정이 필요합니다.")
```
위 코드는 컴파일 시 경고 메시지를 출력합니다.

사용자 정의 Freestanding Macro를 만들기 위해서는 다음 단계를 따릅니다:
1. Macro 타입을 정의합니다.
2. Macro가 실행될 때 수행할 작업을 구현합니다.

### **19.4 Attached Macros**
Attached Macros는 특정 선언(예: 함수, 구조체, 클래스 등)에 연결되어 동작합니다. 이는 선언에 추가적인 기능을 부여하거나, 코드를 자동으로 생성하는 데 사용됩니다.

1\.**예시**
다음은 `@AddLogging`이라는 가상의 Attached Macro를 사용한 예입니다:
```swift
@AddLogging
func fetchData() {
    // 데이터를 가져오는 로직
}
```
위 코드에서 `@AddLogging` Macro는 `fetchData()` 함수에 로깅 기능을 자동으로 추가할 수 있습니다.

### **19.5 Macro의 장점**
1. **코드 간결화**: 반복적인 코드를 줄이고, 핵심 로직에 집중할 수 있습니다.
2. **유지보수성 향상**: 코드가 자동으로 생성되므로 일관성을 유지할 수 있습니다.
3. **안전성 강화**: Macro를 통해 컴파일 시점에서 오류를 방지할 수 있습니다.

### **19.6 Macro의 제한 사항**
- **복잡성 증가**: 잘못 사용하면 코드의 가독성이 떨어질 수 있습니다.
- **디버깅 어려움**: Macro가 생성한 코드는 직접 보이지 않으므로 디버깅이 어려울 수 있습니다.
- **지원 환경 제한**: Swift 5.9 이상에서만 사용 가능하며, 모든 플랫폼에서 지원되지 않을 수 있습니다.

### **19.7 실습 예제**
아래는 간단한 Custom Macro를 만드는 예제입니다:

1\.**Custom Freestanding Macro**
```swift
// Macro 정의
@freestanding(expression)
macro square(_ value: Int) -> Int = #externalMacro(module: "MyMacros", type: "SquareMacro")

// 사용 예시
let result = #square(5) // 결과: 25
```

2\.**Custom Attached Macro**
```swift
// Macro 정의
@attached(member, names: named(description))
macro AddDescription(_ text: String) = #externalMacro(module: "MyMacros", type: "DescriptionMacro")

// 사용 예시
@AddDescription("이것은 테스트 구조체입니다.")
struct TestStruct {
    var name: String
}

// 생성된 코드
extension TestStruct {
    var description: String {
        return "이것은 테스트 구조체입니다."
    }
}
```

## 20.Type Casting
### **20.1 Type Casting이란?**
- **Type casting**은 인스턴스의 타입을 확인하거나, 특정 클래스나 서브클래스의 인스턴스를 참조할 수 있도록 타입을 변환하는 과정입니다.
- Swift에서는 `is`와 `as` 연산자를 사용하여 type casting을 수행합니다.

### **20.2 Type Checking (`is` 연산자)**
- `is` 연산자는 인스턴스가 특정 클래스의 인스턴스인지 또는 특정 클래스의 서브클래스인지 확인합니다.
- 예시:
  ```swift
  class Media {
      var name: String
      init(name: String) {
          self.name = name
      }
  }

  class Movie: Media {
      var director: String
      init(name: String, director: String) {
          self.director = director
          super.init(name: name)
      }
  }

  class Song: Media {
      var artist: String
      init(name: String, artist: String) {
          self.artist = artist
          super.init(name: name)
      }
  }

  let library: [Media] = [
      Movie(name: "Inception", director: "Christopher Nolan"),
      Song(name: "Bohemian Rhapsody", artist: "Queen")
  ]

  for item in library {
      if item is Movie {
          print("Movie: \(item.name)")
      } else if item is Song {
          print("Song: \(item.name)")
      }
  }
  ```
  - 출력:
    ```
    Movie: Inception
    Song: Bohemian Rhapsody
    ```

### **20.3 Downcasting (`as?`, `as!` 연산자)**
- **Downcasting**은 상위 클래스 타입의 인스턴스를 하위 클래스 타입으로 변환하는 작업입니다.
- 안전한 downcasting을 위해 `as?`를 사용하며, 실패 가능성을 처리할 수 있습니다.
- 강제 downcasting인 `as!`는 변환이 실패하면 런타임 오류가 발생하므로 신중히 사용해야 합니다.

1\.**예시:**
```swift
for item in library {
    if let movie = item as? Movie {
        print("Movie: \(movie.name), directed by \(movie.director)")
    } else if let song = item as? Song {
        print("Song: \(song.name), by \(song.artist)")
    }
}
```
- 출력:
  ```
  Movie: Inception, directed by Christopher Nolan
  Song: Bohemian Rhapsody, by Queen
  ```

### **20.4 Any와 AnyObject의 Type Casting**
Swift에서는 두 가지 특별한 타입이 존재합니다:
- **Any**: 모든 타입(클래스, 구조체, 열거형, 함수 등)을 나타낼 수 있는 타입.
- **AnyObject**: 클래스 타입만 나타낼 수 있는 타입.

1\.**예시:**
```swift
let someObjects: [AnyObject] = [
    Movie(name: "Inception", director: "Christopher Nolan"),
    Song(name: "Bohemian Rhapsody", artist: "Queen") as AnyObject
]

for object in someObjects {
    if let movie = object as? Movie {
        print("Movie: \(movie.name), directed by \(movie.director)")
    } else if let song = object as? Song {
        print("Song: \(song.name), by \(song.artist)")
    }
}
```

### **20.5 Type Casting과 Switch 문**
- `switch` 문을 사용하여 다양한 타입을 효율적으로 처리할 수 있습니다.
- `case` 내부에서 타입 캐스팅을 동시에 수행할 수 있습니다.

1\.**예시:**
```swift
for item in library {
    switch item {
    case let movie as Movie:
        print("Movie: \(movie.name), directed by \(movie.director)")
    case let song as Song:
        print("Song: \(song.name), by \(song.artist)")
    default:
        print("Unknown media type")
    }
}
```

### **20.6 요약**
- **`is` 연산자**: 인스턴스의 타입을 확인합니다.
- **`as?` 연산자**: 안전하게 타입을 변환합니다(옵셔널 반환).
- **`as!` 연산자**: 강제로 타입을 변환합니다(실패 시 런타임 오류).
- **`Any`와 `AnyObject`**: 다양한 타입을 처리할 때 유용합니다.
- **`switch` 문**: 복잡한 타입 캐스팅 로직을 간결하게 작성할 수 있습니다.


