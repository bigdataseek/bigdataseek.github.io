---
title: 7차시 6:JavaScript 2
layout: single
classes: wide
categories:
  - JS
toc: true # 이 포스트에서 목차를 활성화
toc_sticky: true # 목차를 고정할지 여부 (선택 사항)
---

## 4. 배열 메서드 마스터 ⭐⭐⭐

이제 배열을 더 쉽고 강력하게 다루는 메서드들을 배워봅시다!

### 4.1 왜 메서드를 사용하나?
반복문보다 **더 간결하고, 읽기 쉽고, 실수가 적습니다**.

```js
const numbers = [1, 2, 3, 4, 5];

// 옛날 방식: for 문으로 2배 만들기
const doubled1 = [];
for (let i = 0; i < numbers.length; i++) {
  doubled1.push(numbers[i] * 2);
}

// 메서드 방식: .map() 사용
const doubled2 = numbers.map(num => num * 2);
// 훨씬 간단하죠? 😊
```

### 4.2 `.map()` - 리스트 렌더링 (React에서 최중요!)
배열의 각 요소를 **변환**하여 새 배열을 만듭니다.

```js
const numbers = [1, 2, 3, 4, 5];

// 각 숫자를 2배로
const doubled = numbers.map(num => num * 2);
console.log(doubled); // [2, 4, 6, 8, 10]

// 각 숫자를 문자열로
const strings = numbers.map(num => `숫자 ${num}`);
console.log(strings); // ['숫자 1', '숫자 2', '숫자 3', '숫자 4', '숫자 5']
```

* 객체 배열에서 사용
    ```js
    const students = [
    { name: '철수', score: 85 },
    { name: '영희', score: 92 },
    { name: '민수', score: 78 }
    ];

    // 이름만 추출
    const names = students.map(student => student.name);
    console.log(names); // ['철수', '영희', '민수']

    // 점수에 5점 보너스
    const bonus = students.map(student => ({
    name: student.name,
    score: student.score + 5
    }));
    console.log(bonus);
    // [{ name: '철수', score: 90 }, { name: '영희', score: 97 }, ...]
    ```

* React에서 사용 예시
    ```js
    // 과일 리스트를 HTML로 변환
    const fruits = ['사과', '바나나', '딸기'];
    const fruitList = fruits.map(fruit => `<li>${fruit}</li>`);
    // React에서는: fruits.map(fruit => <li key={fruit}>{fruit}</li>)
    ```

### 4.3 `.filter()` - 조건에 맞는 항목만 선택
조건을 만족하는 요소들만 **걸러냅니다**.

```js
const numbers = [1, 2, 3, 4, 5, 6, 7, 8];

// 짝수만 선택
const evenNumbers = numbers.filter(num => num % 2 === 0);
console.log(evenNumbers); // [2, 4, 6, 8]

// 5보다 큰 수만 선택
const bigNumbers = numbers.filter(num => num > 5);
console.log(bigNumbers); // [6, 7, 8]
```

* 객체 배열에서 사용
    ```js
    const todos = [
    { id: 1, text: '공부하기', done: true },
    { id: 2, text: '운동하기', done: false },
    { id: 3, text: '청소하기', done: true },
    { id: 4, text: '쇼핑하기', done: false }
    ];

    // 완료된 할일만
    const completedTodos = todos.filter(todo => todo.done);
    console.log(completedTodos);
    // [{ id: 1, text: '공부하기', done: true }, { id: 3, text: '청소하기', done: true }]

    // 미완료 할일만
    const incompleteTodos = todos.filter(todo => !todo.done);
    ```

* 실전: 검색 기능
    ```js
    const products = [
    { id: 1, name: '노트북', price: 1500000 },
    { id: 2, name: '마우스', price: 30000 },
    { id: 3, name: '키보드', price: 80000 },
    { id: 4, name: '모니터', price: 400000 }
    ];

    // 100,000원 이하 상품만
    const affordable = products.filter(product => product.price <= 100000);
    console.log(affordable);
    // [{ id: 2, name: '마우스', ... }, { id: 3, name: '키보드', ... }]

    // 이름에 '노트'가 들어간 상품
    const laptops = products.filter(product => product.name.includes('노트'));
    ```

### 4.4 `.find()` - 특정 항목 찾기
조건을 만족하는 **첫 번째 요소 하나**만 반환합니다.

```js
const users = [
  { id: 1, name: '철수', age: 25 },
  { id: 2, name: '영희', age: 30 },
  { id: 3, name: '민수', age: 28 }
];

// ID가 2인 사용자 찾기
const user = users.find(u => u.id === 2);
console.log(user); // { id: 2, name: '영희', age: 30 }

// 이름이 '민수'인 사용자
const minsu = users.find(u => u.name === '민수');
console.log(minsu); // { id: 3, name: '민수', age: 28 }

// 못 찾으면 undefined
const notFound = users.find(u => u.id === 999);
console.log(notFound); // undefined
```

* .filter()와의 차이
    ```js
    const numbers = [1, 2, 3, 4, 5, 6];

    // filter: 조건에 맞는 모든 요소 (배열 반환)
    const evens = numbers.filter(n => n % 2 === 0);
    console.log(evens); // [2, 4, 6]

    // find: 조건에 맞는 첫 번째 요소 (값 하나만 반환)
    const firstEven = numbers.find(n => n % 2 === 0);
    console.log(firstEven); // 2
    ```

### 4.5 `.reduce()` - 데이터 가공/집계
배열을 순회하면서 **하나의 값**으로 축약합니다.
* reduce()의 인자는 콜백함수와 initialValue
* 콜백함수는 4가지 인자를 가질수 있으며, 순서가 중요, 이름은 임의적일 수 있음.
* 콜백 함수란, 다른 함수에 ‘인자로 전달되어 나중에 호출되는 함수’입니다.
* 콜백 함수의 반환값이 누적기(accumulator)의 역할을 하여 다음 호출로 전달되는 것이 reduce() 메서드의 핵심 동작 원리

```js
// array.reduce((accumulator, currentValue, currentIndex, array) => {
//   // ...
// }, initialValue);

// 기본: 합계 구하기
const numbers = [1, 2, 3, 4, 5];
const sum = numbers.reduce((accumulator, current) => {
  return accumulator + current;
}, 0); // 0은 초기값

console.log(sum); // 15

// 간단하게
const sum2 = numbers.reduce((acc, num) => acc + num, 0);
```

* 동작 과정 이해하기
    ```js
    const prices = [1000, 2000, 3000];
    const total = prices.reduce((sum, price) => {
    console.log(`누적: ${sum}, 현재: ${price}`);
    return sum + price;
    }, 0);

    // 출력:
    // 누적: 0, 현재: 1000
    // 누적: 1000, 현재: 2000
    // 누적: 3000, 현재: 3000
    // 결과: 6000
    ```

* 실전 예시들
    ```js
    // 1. 최댓값 찾기
    const scores = [85, 92, 78, 95, 88];
    const maxScore = scores.reduce((max, score) => 
    score > max ? score : max
    , 0);
    console.log(maxScore); // 95

    // 2. 카테고리별 그룹핑
    const items = [
    { name: '사과', category: '과일' },
    { name: '당근', category: '채소' },
    { name: '바나나', category: '과일' },
    { name: '배추', category: '채소' }
    ];

    const grouped = items.reduce((result, item) => {
    // 카테고리가 없으면 빈 배열 생성
    if (!result[item.category]) {
        result[item.category] = [];
    }
    // 해당 카테고리에 아이템 추가
    result[item.category].push(item.name);
    return result;
    }, {});

    console.log(grouped);
    // { 과일: ['사과', '바나나'], 채소: ['당근', '배추'] }

    // 3. 평균 구하기
    const grades = [85, 92, 78, 88, 95];
    const average = grades.reduce((sum, grade) => sum + grade, 0) / grades.length;
    console.log(average); // 87.6
    ```

### 4.6 메서드 체이닝 (조합해서 사용하기)
여러 메서드를 연결해서 복잡한 작업을 수행할 수 있습니다!

```js
const students = [
  { name: '철수', score: 85, passed: true },
  { name: '영희', score: 92, passed: true },
  { name: '민수', score: 58, passed: false },
  { name: '지은', score: 78, passed: true },
  { name: '수진', score: 45, passed: false }
];

// 합격한 학생들의 평균 점수
const passedAverage = students
  .filter(s => s.passed)           // 1. 합격자만 필터링
  .map(s => s.score)                // 2. 점수만 추출
  .reduce((sum, score) => sum + score, 0) / students.filter(s => s.passed).length;

console.log(passedAverage); // 85

// 더 복잡한 예시: 불합격자 이름을 대문자로
const failedNames = students
  .filter(s => !s.passed)           // 1. 불합격자만
  .map(s => s.name.toUpperCase())   // 2. 이름을 대문자로
  .join(', ');                      // 3. 쉼표로 연결

console.log(failedNames); // '민수, 수진'
```

## 5. 객체 다루기

### 5.1 구조 분해 할당 (Destructuring)
객체나 배열에서 값을 쉽게 꺼내는 문법

* 객체 구조 분해
    ```js
    const person = { 
    name: '철수', 
    age: 25, 
    city: '서울',
    job: '개발자'
    };

    // 옛날 방식
    const name1 = person.name;
    const age1 = person.age;

    // 구조 분해 할당
    const { name, age } = person;
    console.log(name); // '철수'
    console.log(age);  // 25

    // 원하는 것만 꺼내기
    const { city } = person;
    console.log(city); // '서울'

    // 변수명 바꾸기
    const { name: personName, age: personAge } = person;
    console.log(personName); // '철수'

    // 기본값 설정
    const { name, salary = 0 } = person;
    console.log(salary); // 0 (person에 salary가 없으므로)
    ```

* React에서 가장 많이 사용하는 패턴
    ```js
    // 함수 매개변수에서 바로 구조 분해
    function Greeting({ name, age, city }) {
    return `안녕하세요, ${city}에 사는 ${age}세 ${name}님!`;
    }

    const user = { name: '철수', age: 25, city: '서울' };
    console.log(Greeting(user));
    // '안녕하세요, 서울에 사는 25세 철수님!'
    ```

* 배열 구조 분해
    ```js
    const colors = ['red', 'green', 'blue', 'yellow'];

    // 옛날 방식
    const first1 = colors[0];
    const second1 = colors[1];

    // 구조 분해 할당
    const [first, second] = colors;
    console.log(first);  // 'red'
    console.log(second); // 'green'

    // 일부만 가져오기
    const [, , third] = colors; // 첫 두 개는 건너뛰기
    console.log(third); // 'blue'

    // 나머지 가져오기
    const [primary, ...rest] = colors;
    console.log(primary); // 'red'
    console.log(rest);    // ['green', 'blue', 'yellow']
    ```

* React useState에서 사용
    ```js
    // React의 useState는 배열을 반환합니다
    // const [count, setCount] = useState(0);
    // const [user, setUser] = useState(null);
    ```

### 5.2 스프레드 연산자 (...)
객체나 배열을 "펼쳐서" 복사하거나 합칠 때 사용
*  `...` 기호를 사용하여 배열이나 객체의 요소를 개별적으로 펼친다.

* 객체 복사 및 수정
    ```js
    const user = { 
    name: '철수', 
    age: 25,
    city: '서울'
    };

    // 옛날 방식: 값을 직접 변경 (위험!)
    user.age = 26; // 원본이 변경됨!

    // 스프레드로 복사 후 수정 (안전!)
    const updatedUser = { ...user, age: 26 };
    console.log(user);        // { name: '철수', age: 25, city: '서울' } (원본 유지)
    console.log(updatedUser); // { name: '철수', age: 26, city: '서울' }

    // 여러 속성 동시 수정
    const newUser = { 
    ...user, 
    age: 26, 
    job: '개발자',
    city: '부산'
    };
    ```

* 객체 합치기
    ```js
    const basic = { name: '철수', age: 25 };
    const extra = { job: '개발자', city: '서울' };

    const combined = { ...basic, ...extra };
    console.log(combined);
    // { name: '철수', age: 25, job: '개발자', city: '서울' }

    // 중복되는 키는 뒤의 값으로 덮어씌워짐
    const obj1 = { a: 1, b: 2 };
    const obj2 = { b: 3, c: 4 };
    const merged = { ...obj1, ...obj2 };
    console.log(merged); // { a: 1, b: 3, c: 4 }
    ```

* 배열 복사 및 추가
    ```js
    const numbers = [1, 2, 3];

    // 복사
    const copied = [...numbers];

    // 끝에 추가
    const withMore = [...numbers, 4, 5];
    console.log(withMore); // [1, 2, 3, 4, 5]

    // 앞에 추가
    const withPrefix = [0, ...numbers];
    console.log(withPrefix); // [0, 1, 2, 3]

    // 배열 합치기
    const arr1 = [1, 2];
    const arr2 = [3, 4];
    const combined = [...arr1, ...arr2];
    console.log(combined); // [1, 2, 3, 4]
    ```

* React에서 state 업데이트 (매우 중요!)
    ```js
    // 객체 state 업데이트
    const user = { name: '철수', age: 25, city: '서울' };
    // setUser({ ...user, age: 26 }); // 나이만 변경

    // 배열 state에 아이템 추가
    const todos = [{ id: 1, text: '공부' }];
    // setTodos([...todos, { id: 2, text: '운동' }]);

    // 배열 state에서 아이템 삭제
    const filtered = todos.filter(todo => todo.id !== 1);
    // setTodos(filtered);
    ```

## 6. 화살표 함수 익숙해지기
- 호이스팅(Hoisting): 변수와 함수 선언이 코드의 최상단으로 "끌어올려지는" 것처럼 동작하는 현

### 6.1 기본 문법
```js
// 일반 함수
function add(a, b) {
  return a + b;
}

// 화살표 함수 - 완전한 형태
// "add라는 이름이 이미 환경 레코드에 존재하므로 재선언 불가!"
// 다른 이름으로 더하기 함수의 이름을 지정해야
const add = (a, b) => {
  return a + b;
};

// 화살표 함수 - 축약형 (return 생략)
const add = (a, b) => a + b;

// 매개변수 1개면 괄호 생략 가능
const double = num => num * 2;
const greet = name => `안녕하세요, ${name}님!`;

// 매개변수 없으면 빈 괄호
const sayHi = () => '안녕하세요';
//Math.random()은 내장 객체인 Math 객체의 메서드
// 0 이상 1 미만의 부동소수점 난수
const getRandom = () => Math.random();

// 객체를 반환할 때는 괄호로 감싸기
const makePerson = (name, age) => ({ name, age });
console.log(makePerson('철수', 25)); // { name: '철수', age: 25 }
```

### 6.2 언제 어떤 형태를 사용할까?
```js
// 1. 한 줄 계산 → 중괄호, return 생략
const double = x => x * 2;
const isEven = n => n % 2 === 0;

// 2. 여러 줄 로직 → 중괄호 사용
const processUser = user => {
  const fullName = `${user.firstName} ${user.lastName}`;
  const age = 2025 - user.birthYear;
  return { fullName, age };
};

// 3. 객체 반환 → 괄호로 감싸기
const createTodo = text => ({ 
  id: Date.now(), 
  text, 
  done: false 
});
```

### 6.3 React에서 자주 쓰는 패턴

* 이벤트 핸들러
    ```js
    // 버튼 클릭
    const handleClick = () => {
    console.log('클릭됨!');
    };

    // 입력값 변경
    const handleChange = (e) => {
    console.log(e.target.value);
    };

    // 매개변수가 있는 핸들러
    const handleDelete = (id) => {
    console.log(`${id}번 삭제`);
    };
    ```

    * 전체 예시 (React 컴포넌트)

    ```jsx
    import React, { useState } from 'react';

    function MyComponent() {
      //const [state, setState] = useState(초기값);
      const [inputValue, setInputValue] = useState('');

      const handleClick = () => {
        console.log('클릭됨!');
      };

      const handleChange = (e) => {
        setInputValue(e.target.value);
        console.log(e.target.value);
      };

      const handleDelete = (id) => {
        console.log(`${id}번 삭제`);
      };

      return (
        <div>
          <button onClick={handleClick}>클릭</button>
          <input type="text" value={inputValue} onChange={handleChange} />
          <button onClick={() => handleDelete(1)}>1번 삭제</button>
          <button onClick={() => handleDelete(2)}>2번 삭제</button>
        </div>
      );
    }
    ```
    
    

* 배열 메서드와 함께
    ```js
    const numbers = [1, 2, 3, 4, 5];

    // map
    const doubled = numbers.map(n => n * 2);

    // filter
    const evens = numbers.filter(n => n % 2 === 0);

    // find
    const found = numbers.find(n => n > 3);

    // 객체 배열에서
    const users = [
    { id: 1, name: '철수', active: true },
    { id: 2, name: '영희', active: false }
    ];

    const activeUsers = users.filter(user => user.active);
    const userNames = users.map(user => user.name);
    ```

* 콜백 함수
    ```js
    // setTimeout
    setTimeout(() => {
    console.log('1초 후 실행');
    }, 1000);

    // addEventListener (브라우저에서)
    // button.addEventListener('click', () => {
    //   console.log('버튼 클릭!');
    // });

    // Promise
    fetch('https://api.example.com/data')
    .then(response => response.json())
    .then(data => console.log(data));
    ```


## 7. 클래스
프레임워크(React) 사용 시 자주 이용, Vanilla JS에서는 적게 사용

*   1.클래스 문법 (ES6+)
    ```js
    class Person {
        constructor(name) {
            this.name = name;
        }
        sayHello() {
            console.log(`Hello, ${this.name}`);
        }
    }

    const person = new Person('John');
    ```

*   2.프로토타입 방식 (전통적)

    ```js
    function Person(name) {
        this.name = name;
    }

    Person.prototype.sayHello = function() {
        console.log('Hello, ' + this.name);
    };
    ```

*   3.객체 리터럴

    ```js
    const person = {
        name: 'John',
        sayHello: function() {
            console.log('Hello, ' + this.name);
        }
    };
    ```

## 8. ES6+ 필수 문법

### 8.1 템플릿 리터럴 (백틱 사용)
문자열 안에 변수를 쉽게 넣을 수 있습니다.
- 템플릿 리터럴은 문자열 구성에 완벽하지만, 객체의 내용을 확인하는 용도로는 부적합

```js
const name = '철수';
const age = 25;

// 옛날 방식
const message1 = '안녕하세요, ' + name + '님! ' + age + '세이시군요.';

// 템플릿 리터럴 (백틱 ` 사용)
const message2 = `안녕하세요, ${name}님! ${age}세이시군요.`;

// 표현식도 넣을 수 있음
const price = 1000;
const tax = `세금 포함: ${price * 1.1}원`;
console.log(tax); // '세금 포함: 1100원'

// 여러 줄 문자열
const html = `
  <div>
    <h1>${name}</h1>
    <p>나이: ${age}</p>
  </div>
`;
```

### 8.2 삼항 연산자
조건에 따라 다른 값을 반환하는 간단한 방법

```js
// if-else 방식
const age = 20;
let message;
if (age >= 18) {
  message = '성인입니다';
} else {
  message = '미성년자입니다';
}

// 삼항 연산자
const message = age >= 18 ? '성인입니다' : '미성년자입니다';
//              조건      ? 참일 때     : 거짓일 때

// 더 많은 예시
const score = 85;
const grade = score >= 90 ? 'A' : score >= 80 ? 'B' : 'C';

const isLoggedIn = true;
const greeting = isLoggedIn ? '환영합니다!' : '로그인해주세요';

const count = 5;
const text = `아이템 ${count}개`;
const status = count > 0 ? text : '없음';
```

* React에서 조건부 렌더링
    ```js
    // JSX 안에서 사용
    // {isLoggedIn ? <Dashboard /> : <Login />}
    // {count > 0 ? <ItemList items={items} /> : <EmptyMessage />}
    ```

### 8.3 선택적 체이닝 (?.)
객체의 속성에 안전하게 접근하는 방법

```js
const user = {
  name: '철수',
  address: {
    city: '서울',
    zipCode: '12345'
  }
};

// 옛날 방식: 에러 방지를 위한 긴 체크
const zipCode1 = user && user.address && user.address.zipCode;

// 선택적 체이닝
const zipCode2 = user?.address?.zipCode;
console.log(zipCode2); // '12345'

// 없는 속성에 접근해도 에러 없음
const phone = user?.contact?.phone;
console.log(phone); // undefined (에러 발생 안 함!)
```

* 배열에서 사용
    ```js
    const user = {
    name: '철수',
    friends: ['영희', '민수']
    };

    // 첫 번째 친구
    const firstFriend = user?.friends?.[0];
    console.log(firstFriend); // '영희'

    // friends가 없는 경우
    const stranger = {};
    const firstFriend2 = stranger?.friends?.[0];
    console.log(firstFriend2); // undefined (에러 없음!)
    ```

* 함수 호출에서 사용
    ```js
    const user = {
    name: '철수',
    sayHello: () => '안녕하세요!'
    };

    // 함수가 있으면 호출
    user.sayHello?.(); // '안녕하세요!'

    // 함수가 없어도 에러 없음
    const guest = { name: '손님' };
    guest.sayHello?.(); // undefined (에러 없음!)
    ```

### 8.4 const vs let
변수를 선언하는 두 가지 방법

```js
// const: 재할당 불가 (상수)
const name = '철수';
// name = '영희'; // 에러! 재할당 불가

const age = 25;
// age = 26; // 에러!

// let: 재할당 가능
let count = 0;
count = 1;  // OK
count = 2;  // OK

let message = '안녕';
message = '잘가'; // OK
```

* 중요: 객체/배열의 내용은 변경 가능!
    ```js
    // const로 선언해도 내용은 변경 가능
    const numbers = [1, 2, 3];
    numbers.push(4);        // OK - 내용 변경
    numbers[0] = 10;        // OK - 내용 변경
    console.log(numbers);   // [10, 2, 3, 4]

    // numbers = [5, 6];    // 에러! 재할당은 불가

    const user = { name: '철수', age: 25 };
    user.age = 26;          // OK - 속성 변경
    user.city = '서울';     // OK - 속성 추가
    console.log(user);      // { name: '철수', age: 26, city: '서울' }

    // user = { name: '영희' }; // 에러! 재할당은 불가
    ```

* 언제 뭘 사용할까?
    ```js
    // 기본적으로 const 사용 (React에서 권장)
    const userName = '철수';
    const maxCount = 100;
    const users = [];
    const config = { theme: 'dark' };

    // 값이 바뀌어야 할 때만 let 사용
    let count = 0;
    for (let i = 0; i < 10; i++) {
    count += i;
    }

    let isLoading = true;
    // 나중에...
    isLoading = false;
    ```
### 8.5 메서드 단축 문법
* 객체에서 함수를 간결하게 정의
* 기존 방식
  ```js
    const obj = {
      sayHello: function() {
          console.log('Hello');
      }
  };
  ```

* 메서드 단축 문법
  ```js
    const obj = {
      sayHello() {
          console.log('Hello');
      }
  };
  ```

## 9. 종합 실전 예제

모든 개념을 한 번에 사용해봅시다!

```js
// 학생 데이터
const students = [
  { id: 1, name: '철수', score: 85, grade: 3, passed: true },
  { id: 2, name: '영희', score: 92, grade: 3, passed: true },
  { id: 3, name: '민수', score: 58, grade: 2, passed: false },
  { id: 4, name: '지은', score: 73, grade: 3, passed: true },
  { id: 5, name: '수진', score: 45, grade: 2, passed: false }
];

// 1. 합격한 학생들만 필터링
const passedStudents = students.filter(student => student.passed);
console.log('합격자:', passedStudents.length, '명');

// 2. 합격자 이름 리스트 만들기 (map)
const passedNames = passedStudents.map(student => student.name);
console.log('합격자 명단:', passedNames.join(', '));
// '합격자 명단: 철수, 영희, 지은'

// 3. 3학년 학생들의 평균 점수 (filter + map + reduce)
const grade3Students = students.filter(s => s.grade === 3);
const grade3Scores = grade3Students.map(s => s.score);
const grade3Average = grade3Scores.reduce((sum, score) => sum + score, 0) / grade3Scores.length;
console.log(`3학년 평균: ${grade3Average.toFixed(1)}점`);

// 4. 특정 학생 찾기 (find)
const target = students.find(s => s.name === '영희');
console.log(`${target?.name}의 점수: ${target?.score}점`);

// 5. 점수 업데이트 (불변성 유지)
const updatedStudents = students.map(student => 
  student.id === 3 
    ? { ...student, score: 65, passed: true }  // 민수 점수 상승
    : student
);

// 6. 학년별 그룹핑 (reduce)
const byGrade = students.reduce((result, student) => {
  const { grade } = student;  // 구조 분해
  if (!result[grade]) {
    result[grade] = [];
  }
  result[grade].push(student.name);
  return result;
}, {});
console.log('학년별:', byGrade);
// { 2: ['민수', '수진'], 3: ['철수', '영희', '지은'] }

// 7. 성적 메시지 생성 (템플릿 리터럴 + 삼항 연산자)
const messages = students.map(student => {
  const { name, score, passed } = student;
  const status = passed ? '합격 🎉' : '불합격';
  const emoji = score >= 90 ? '👏' : score >= 80 ? '😊' : '💪';
  return `${name}: ${score}점 (${status}) ${emoji}`;
});

console.log('성적표:');
messages.forEach(msg => console.log(msg));
// 철수: 85점 (합격 🎉) 😊
// 영희: 92점 (합격 🎉) 👏
// 민수: 58점 (불합격) 💪
// ...

// 8. 최고점, 최저점 찾기
const scores = students.map(s => s.score);
const maxScore = Math.max(...scores);  // 스프레드 사용!
const minScore = Math.min(...scores);
const topStudent = students.find(s => s.score === maxScore);

console.log(`최고점: ${topStudent?.name} (${maxScore}점)`);
console.log(`최저점: ${minScore}점`);

// 9. 통계 객체 만들기
const stats = {
  total: students.length,
  passed: passedStudents.length,
  failed: students.filter(s => !s.passed).length,
  average: scores.reduce((sum, s) => sum + s, 0) / students.length,
  topScore: maxScore,
  topStudent: topStudent?.name
};

console.log('통계:', stats);

// 10. 체이닝으로 복잡한 작업 수행
const result = students
  .filter(s => s.grade === 3)           // 3학년만
  .filter(s => s.passed)                 // 합격자만
  .map(s => ({ name: s.name, score: s.score }))  // 필요한 정보만
  .sort((a, b) => b.score - a.score)    // 점수 내림차순
  .map(s => `${s.name}(${s.score})`)    // 문자열로 변환
  .join(' > ');                          // 연결

console.log('3학년 합격자 순위:', result);
// '영희(92) > 철수(85) > 지은(73)'
```

## 10. React로 넘어가기 전 실습 과제

이 문제들을 풀 수 있으면 React를 시작할 준비가 된 것입니다!

### 10.1: 장바구니 기능
```js
const cart = [
  { id: 1, name: '노트북', price: 1500000, quantity: 1 },
  { id: 2, name: '마우스', price: 30000, quantity: 2 },
  { id: 3, name: '키보드', price: 80000, quantity: 1 }
];

// TODO:
// 1. 총 가격 계산 (가격 × 수량의 합)
// 2. 상품명 리스트 추출
// 3. 수량이 2개 이상인 상품만 필터링
// 4. id가 2인 상품의 수량을 3으로 변경 (불변성 유지)
```

```js
// 1. 총 가격
const total = cart.reduce((sum, item) => sum + (item.price * item.quantity), 0);
console.log(`총 가격: ${total.toLocaleString()}원`);

// 2. 상품명 리스트
const names = cart.map(item => item.name);
console.log('상품:', names.join(', '));

// 3. 수량 2개 이상
const multipleItems = cart.filter(item => item.quantity >= 2);

// 4. 수량 변경
const updated = cart.map(item => 
  item.id === 2 ? { ...item, quantity: 3 } : item
);
```

### 10.2: 사용자 데이터 처리
```js
const users = [
  { id: 1, name: '철수', age: 25, city: '서울', premium: true },
  { id: 2, name: '영희', age: 30, city: '부산', premium: false },
  { id: 3, name: '민수', age: 28, city: '서울', premium: true },
  { id: 4, name: '지은', age: 22, city: '대구', premium: false }
];

// TODO:
// 1. 서울에 사는 사용자만 필터링
// 2. 프리미엄 사용자의 평균 나이
// 3. 각 도시별 사용자 수 (reduce 사용)
// 4. 나이가 25세 이상인 사용자에게 '성인' 속성 추가
```

```js
// 1. 서울 사용자
const seoulUsers = users.filter(user => user.city === '서울');

// 2. 프리미엄 평균 나이
const premiumUsers = users.filter(u => u.premium);
const avgAge = premiumUsers.reduce((sum, u) => sum + u.age, 0) / premiumUsers.length;
console.log(`프리미엄 평균 나이: ${avgAge}세`);

// 3. 도시별 사용자 수
const byCity = users.reduce((result, user) => {
  //A || B : A가 falsy면 B를 반환
  //false: false, 0, "", null, undefined, NaN
  result[user.city] = (result[user.city] || 0) + 1;
  return result;
}, {});
console.log('도시별:', byCity);

// 4. 성인 속성 추가
const withAdult = users.map(user => ({
  ...user,
  isAdult: user.age >= 25
}));
```

### 10.3: 할 일 목록 관리
```js
const todos = [
  { id: 1, text: '공부하기', done: false, priority: 'high' },
  { id: 2, text: '운동하기', done: true, priority: 'medium' },
  { id: 3, text: '청소하기', done: false, priority: 'low' },
  { id: 4, text: '쇼핑하기', done: false, priority: 'high' }
];

// TODO:
// 1. 완료되지 않은 할일만 필터링
// 2. priority가 'high'인 할일 찾기
// 3. id가 3인 할일을 완료(done: true)로 변경
// 4. priority별로 할일 개수 세기
```

```js
// 1. 미완료 할일
const incomplete = todos.filter(todo => !todo.done);

// 2. 높은 우선순위 할일
const highPriority = todos.filter(todo => todo.priority === 'high');

// 3. 할일 완료 처리
const updated = todos.map(todo =>
  todo.id === 3 ? { ...todo, done: true } : todo
);

// 4. priority별 개수
const countByPriority = todos.reduce((count, todo) => {
  count[todo.priority] = (count[todo.priority] || 0) + 1;
  return count;
}, {});
console.log('우선순위별:', countByPriority);
// { high: 2, medium: 1, low: 1 }
```

## 11. 다음 단계: React로! 🚀

### 11.1 이제 배운 것들이 React에서 어떻게 쓰이는지 확인해보세요

```js
// React 컴포넌트는 함수입니다
function StudentList({ students }) {
  // 구조 분해로 props 받기
  
  return (
    <div>
      {/* map으로 리스트 렌더링 */}
      {students.map(student => (
        <div key={student.id}>
          {/* 템플릿 리터럴처럼 사용 */}
          <h3>{student.name}</h3>
          <p>점수: {student.score}점</p>
          
          {/* 삼항 연산자로 조건부 렌더링 */}
          {student.passed ? (
            <span>합격 ✅</span>
          ) : (
            <span>불합격 ❌</span>
          )}
        </div>
      ))}
    </div>
  );
}

// 이벤트 핸들러는 화살표 함수
function TodoApp() {
  const [todos, setTodos] = useState([]);  // 배열 구조 분해
  
  const handleAdd = (text) => {
    // 스프레드로 배열에 추가
    // 객체에서 속성명과 변수명이 같으면 생략 가능
    setTodos([...todos, { id: Date.now(), text, done: false }]);
  };
  
  const handleToggle = (id) => {
    // map으로 특정 항목 수정
    setTodos(todos.map(todo =>
      todo.id === id ? { ...todo, done: !todo.done } : todo
    ));
  };
  
  const handleDelete = (id) => {
    // filter로 삭제
    setTodos(todos.filter(todo => todo.id !== id));
  };
  
  // 완료된 항목 개수
  const completedCount = todos.filter(todo => todo.done).length;
  
  return (
    <div>
      <h1>할 일 {todos.length}개 (완료: {completedCount})</h1>
      {/* ... */}
    </div>
  );
}
```

### 11.2 핵심 정리

✅ **배열 메서드** → 리스트 렌더링, 상태 관리  
✅ **객체 다루기** → Props 전달, State 관리  
✅ **화살표 함수** → 컴포넌트, 이벤트 핸들러  
✅ **구조 분해** → Props 받기, State 사용  
✅ **스프레드** → 불변성 유지하며 업데이트  
✅ **삼항 연산자** → 조건부 렌더링  
✅ **템플릿 리터럴** → 동적 문자열 생성

**기억하세요:**
- React는 새로운 프레임워크가 아니라 **JavaScript를 사용하는 방법**입니다
- React에서 막히면 대부분 **JavaScript 기초**로 돌아가면 해결됩니다
- 실습이 가장 중요합니다. 예제를 따라 치지 말고 **직접 변형**해보세요!
