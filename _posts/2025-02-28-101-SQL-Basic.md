---
title: 13차시 :SQL Basic
layout: single
classes: wide
categories:
  - SQL
toc: true # 이 포스트에서 목차를 활성화
toc_sticky: true # 목차를 고정할지 여부 (선택 사항)
---




## 1. MySQL 설치 및 Workbench 접속
### 1.1 MySQL 설치
MySQL은 데이터를 저장하고 관리할 수 있는 무료 오픈소스 데이터베이스 관리 시스템(DBMS)입니다. 아래 단계로 설치를 시작하세요.

- **설치 과정:**
    1. **공식 사이트 방문**
        - [MySQL 공식 웹사이트](https://www.mysql.com/)로 이동합니다.
        - 상단 메뉴에서 "Downloads"를 클릭하고, "MySQL Community Server"를 선택합니다.
    2. **운영체제에 맞는 버전 다운로드**
        - Windows, macOS, Linux 중 본인의 운영체제에 맞는 설치 파일을 선택합니다.
        - "Download" 버튼을 누르고 무료 버전(Community Edition)을 받습니다.
    3. **설치 실행**
        - 다운로드한 파일을 실행합니다.
        - 설치 중 "Developer Default" 옵션을 선택하면 기본 설정으로 진행됩니다.
        - root 계정 비밀번호를 설정하라는 창이 나오면, 기억하기 쉬운 비밀번호를 입력하고 저장하세요.
    4. **설치 완료 확인**
        - 설치가 끝나면 MySQL이 자동으로 실행됩니다.
        - 명령 프롬프트(CMD)나 터미널에서 `mysql -u root -p`를 입력하고 비밀번호를 입력해 접속이 되는지 확인합니다.
    5. **Mac의 Homebrew 사용자**
        - 복잡한 설정 없이 `brew install mysql` 하나로 설치
        - `brew services start mysql`로 실행 
    

### 1.2 MySQL Workbench 설치
MySQL Workbench는 MySQL을 시각적으로 관리할 수 있는 도구입니다.

- **설치 과정:**
    1. **다운로드**
        - MySQL 공식 사이트의 "Downloads"에서 "MySQL Workbench"를 선택합니다.
        - 운영체제에 맞는 버전을 다운로드합니다.
    2. **설치**
        - 다운로드한 파일을 실행하고 지시에 따라 설치를 완료합니다.
        - 별도의 설정 없이 "Next"를 눌러 진행하면 됩니다.
    3. **설치 확인**
        - 설치 후 Workbench를 실행하면 초기 화면이 나타납니다.

### 1.3 MySQL Workbench에서 MySQL 접속
Workbench를 통해 MySQL 서버에 접속해 봅시다.
- **접속 과정:**
    1. **Workbench 실행**
        - MySQL Workbench를 열고, 기본 화면에서 "MySQL Connections" 아래에 있는 접속 항목(기본적으로 "Local Instance MySQL")을 더블클릭합니다.
    2. **비밀번호 입력**
        - MySQL 설치 시 설정한 root 비밀번호를 입력합니다.
        - "OK"를 누르면 접속이 완료됩니다.
    3. **접속 확인**
        - 왼쪽에 "SCHEMAS" 탭이 보이고, 쿼리 창이 열리면 접속 성공입니다.
        - 간단한 명령어 `SHOW DATABASES;`를 입력하고 실행(Ctrl+Enter)해 데이터베이스 목록을 확인해 보세요.

### 1.4 MySQL 학습 참조 사이트
>[Tech On The Net](https://www.techonthenet.com/mysql/index.php)


## 2. **SQL 학습 목차**
- SQL 동작을 8가지 주요 카테고리로 구분
  - 1.기본 쿼리
  - 2.데이터 조작
  - 3.조건 및 연산
  - 4.고급 쿼리
  - 5.테이블 관리
  - 6.사용자 및 권한
  - 7.프로그래밍 요소
  - 8.트리거

> SQL 동작은 <u>기본</u>적인 <u>데이터를 조작</u>하거나 <u>연산</u>하는 <u>고급</u> 기술로 <u>테이블</u>을 <u>사용자</u>에게 맞게 <u>프로그래밍</u>하고 <u>트리거</u>를 생성한다

### **2.1 기본 쿼리**
> "새(SE) 프린터(FR) 코웨이(CO,WH)가 오래(OB)되어 안(AN) 돌아(OR), 디짐!(DI)"

- **SELECT:** 데이터베이스에서 데이터를 검색하는 가장 기본적인 명령어입니다.
- **FROM:** 데이터를 가져올 테이블을 지정합니다.
- **Comparison 연산자:** =, >, <, >=, <=, != 등 데이터를 비교하는 연산자입니다.
- **WHERE:** 특정 조건을 만족하는 데이터만 검색합니다.
- **ORDER BY:** 검색된 데이터를 특정 열을 기준으로 정렬합니다.
- **AND 조건:** 여러 조건을 모두 만족하는 데이터를 검색합니다.
- **OR 조건:** 여러 조건 중 하나라도 만족하는 데이터를 검색합니다.
- **DISTINCT:** 중복된 데이터를 제거하고 고유한 데이터만 검색합니다.

### **2.2 데이터 조작**
> "인어(IN)를 업어(UP) 데려가(DE), 트럭(TR)에 태워!"

- **INSERT 문:** 테이블에 새로운 데이터를 추가합니다.
- **UPDATE 문:** 테이블에 있는 기존 데이터를 수정합니다.
- **DELETE 문:** 테이블에 있는 데이터를 삭제합니다.
- **TRUNCATE TABLE 문:** 테이블의 모든 데이터를 삭제하고 테이블을 초기화합니다.


### **2.3 조건 및 연산**
> "나랏(NAL)말싸미 좀비(JO-BE) 인(IN) 누나(NU-NA)와 다르리(LI)"

- **NOT 조건:** 특정 조건을 만족하지 않는 데이터를 검색합니다.
- **ALIASES:** 테이블이나 열에 별칭을 부여하여 쿼리를 간결하게 만듭니다.
- **JOINS:** 여러 테이블의 데이터를 연결하여 검색합니다.
- **BETWEEN 조건:** 특정 범위 내에 있는 데이터를 검색합니다.
- **IN 조건:** 특정 값 목록에 포함된 데이터를 검색합니다.
- **IS NULL 조건:** NULL 값을 가진 데이터를 검색합니다.
- **IS NOT NULL 조건:** NULL 값을 가지지 않는 데이터를 검색합니다.
- **LIKE 조건:** 특정 패턴과 일치하는 데이터를 검색합니다.

### **2.4 고급 쿼리**
> "엑스(EX)가 준 그램(GR) 하나(HA)를, 친구가 슬쩍(SL) 가져가더니 딜리(DL)버드처럼 유난(UN)히 자랑하고, 또 유난(UA)을 떨며 인터(IN)넷에 올렸다가 수습(SU)하느라 애먹었다."

- **EXISTS 조건:** 서브쿼리의 결과가 존재하는지 확인합니다.
- **GROUP BY 절:** 특정 열을 기준으로 데이터를 그룹화합니다.
- **HAVING 절:** 그룹화된 데이터에 조건을 적용합니다.
- **SELECT LIMIT 문:** 검색 결과의 개수를 제한합니다.
- **DELETE LIMIT 문:** 삭제하는 데이터의 개수를 제한합니다.
- **UNION 연산자:** 여러 SELECT 문의 결과를 합쳐서 보여줍니다 (중복 제거).
- **UNION ALL 연산자:** 여러 SELECT 문의 결과를 합쳐서 보여줍니다 (중복 포함).
- **INTERSECT 연산자:** 여러 SELECT 문의 결과에서 공통된 부분만 보여줍니다.
- **Subqueries:** 쿼리 안에 또 다른 쿼리를 사용하여 복잡한 검색을 수행합니다.

### **2.5 테이블 관리**
> "디트로이(DT)에 사는 크레파스(CR-CA)색 파카(PK)를 입은 곰이 알약(AL)을 먹고 드르렁(DR) 자고나서, 뷰티(VI)풀한 얼굴에 웃(UC)기네스(IN)"

- **Data Types:** 테이블 열의 데이터 유형을 정의합니다.
- **CREATE TABLE 문:** 새로운 테이블을 생성합니다.
- **CREATE TABLE AS 문:** 다른 테이블의 데이터를 기반으로 새로운 테이블을 생성합니다.
- **Primary Keys:** 테이블의 각 행을 고유하게 식별하는 열을 정의합니다.
- **ALTER TABLE 문:** 테이블의 구조를 변경합니다.
- **DROP TABLE 문:** 테이블을 삭제합니다.
- **VIEW:** 하나 이상의 테이블을 기반으로 가상의 테이블을 생성합니다.
- **Unique Constraints:** 열의 값이 중복되지 않도록 제약 조건을 설정합니다.
- **Indexes** 데이터 검색 속도를 향상시키기 위한 인덱스를 생성합니다.

### **2.6 사용자 및 권한**
> "그(GR) 쇼(SH)크(CR)에 사용자는 체(CH)리(RE)를 들(DR)어 판(FI)다."  

- **Grant / Revoke Privileges:** 사용자에게 특정 권한을 부여하거나 취소합니다.
- **Show grants for user in MySQL:** 특정 사용자의 권한을 확인합니다.
- **CREATE USER 문:** 새로운 사용자를 생성합니다.
- **Change a user password:** 사용자의 비밀번호를 변경합니다.
- **RENAME USER 문:** 사용자의 이름을 변경합니다.
- **DROP USER 문:** 사용자를 삭제합니다.
- **Find Users in MySQL:** MySQL에 등록된 사용자 목록을 확인합니다.
- **Find users logged into MySQL:** 현재 MySQL에 접속한 사용자 목록을 확인합니다.

### **2.7 프로그래밍 요소**

> "코(CO)리(LI) 데(DE)시(SE), 펑(FN)프(PR) 이(IF)와(WH)리(LE)! 계속 루(LO)리(RE)하고 간간히 케(CA)커(CU)해서 오(OP)픈 페(FE)이스를 클(CL)로즈 해(HA)!"

- **Comments within SQL:** SQL 코드에 주석을 추가합니다.
- **Literals:** 문자열, 숫자, 날짜 등과 같은 고정된 값을 나타냅니다.
- **Declaring Variables:** 변수를 선언하고 값을 할당합니다.
- **Sequences(AUTO_INCREMENT):** 자동으로 증가하는 숫자 시퀀스를 생성합니다.
- **Functions:** 특정 작업을 수행하는 함수를 정의하고 사용합니다.
- **Procedures:** 일련의 SQL 문을 묶어서 실행하는 프로시저를 정의하고 사용합니다.
- **IF-THEN-ELSE 문:** 조건에 따라 다른 SQL 문을 실행합니다.
- **WHILE 문:** 특정 조건이 만족하는 동안 SQL 문을 반복 실행합니다.
- **LEAVE 문:** 반복문에서 빠져나옵니다.
- **ITERATE 문:** 반복문의 특정 부분을 건너뜁니다.
- **RETURN 문:** 함수나 프로시저에서 값을 반환합니다.
- **LOOP 문:** SQL 문을 무한 반복합니다.
- **REPEATE 문:** 특정 조건이 만족할 때까지 SQL 문을 반복 실행합니다.
- **CASE 문:** 여러 조건에 따라 다른 값을 반환합니다.
- **Declare a Cursor:** 커서를 선언하여 쿼리 결과를 행 단위로 처리합니다.
- **OPEN 문:** 커서를 엽니다.
- **FETCH 문:** 커서에서 다음 행을 가져옵니다.
- **CLOSE 문:** 커서를 닫습니다.
- **Set up a Handler for Cursor's NOT Found condition:** 커서에서 더 이상 데이터를 찾을 수 없을 때 처리할 핸들러를 설정합니다.

### **2.8 트리거**
> "인어(IN)를 업어(UP) 데려가(DE), 비에(BEFORE/AFTER) 두통(DT)이 있다.

- **BEFORE INSERT Trigger:** 데이터 삽입 전에 실행되는 트리거를 생성합니다.
- **AFTER INSERT Trigger:** 데이터 삽입 후에 실행되는 트리거를 생성합니다.
- **BEFORE UPDATE Trigger:** 데이터 수정 전에 실행되는 트리거를 생성합니다.
- **AFTER UPDATE Trigger:** 데이터 수정 후에 실행되는 트리거를 생성합니다.
- **BEFORE DELETE Trigger:** 데이터 삭제 전에 실행되는 트리거를 생성합니다.
- **AFTER DELETE Trigger:** 데이터 삭제 후에 실행되는 트리거를 생성합니다.
- **DROP TRIGGER 문:** 트리거를 삭제합니다.



## **3.기본 쿼리**

**샘플 데이터 생성**

```sql
-- students 테이블 생성
CREATE TABLE students (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    grade CHAR(1),
    score INT
);

-- 샘플 데이터 삽입
INSERT INTO students (id, name, grade, score) VALUES
(1, 'Alice', 'A', 95),
(2, 'Bob', 'B', 85),
(3, 'Charlie', 'A', 92),
(4, 'David', 'C', 78),
(5, 'Eve', 'B', 88),
(6, 'Frank', 'A', 95),
(7, 'Grace', 'C', 72),
(8, 'Hannah', 'B', 85);
```

### **3.1 SELECT & FROM**
- **설명:** `SELECT`는 데이터를 검색하는 명령어이고, `FROM`은 데이터를 가져올 테이블을 지정합니다.

- **예제:** 모든 학생의 이름과 점수를 조회합니다.
```sql
SELECT name, score
FROM students;
```

- **결과:**
```
name    | score
--------|------
Alice   | 95
Bob     | 85
Charlie | 92
David   | 78
Eve     | 88
Frank   | 95
Grace   | 72
Hannah  | 85
```

---

### **3.2 Comparison 연산자 & WHERE**
- **설명:** `WHERE`는 특정 조건을 만족하는 데이터만 검색하며, 비교 연산자(`=`, `>`, `<`, `>=`, `<=`, `!=`)를 사용할 수 있습니다.

- **예제:** 점수가 90점 이상인 학생의 이름과 점수를 조회합니다.
```sql
SELECT name, score
FROM students
WHERE score >= 90;
```

- **결과:**
```
name    | score
--------|------
Alice   | 95
Charlie | 92
Frank   | 95
```

---

### **3.3 ORDER BY**
- **설명:** `ORDER BY`는 검색된 데이터를 특정 열을 기준으로 정렬합니다. 기본적으로 오름차순(`ASC`)이며, 내림차순으로 정렬하려면 `DESC`를 사용합니다.

- **예제:** 학생들을 점수 기준으로 내림차순으로 정렬하여 조회합니다.
```sql
SELECT name, score
FROM students
ORDER BY score DESC;
```

- **결과:**
```
name    | score
--------|------
Alice   | 95
Frank   | 95
Charlie | 92
Eve     | 88
Bob     | 85
Hannah  | 85
David   | 78
Grace   | 72
```


### **3.4 AND 조건**
- **설명:** `AND`는 여러 조건을 모두 만족하는 데이터를 검색합니다.

- **예제:** 등급이 'A'이고 점수가 90점 이상인 학생의 이름과 점수를 조회합니다.
```sql
SELECT name, grade, score
FROM students
WHERE grade = 'A' AND score >= 90;
```

- **결과:**
```
name    | grade | score
--------|-------|------
Alice   | A     | 95
Charlie | A     | 92
Frank   | A     | 95
```

### **3.5 OR 조건**
- **설명:** `OR`는 여러 조건 중 하나라도 만족하는 데이터를 검색합니다.

- **예제:** 등급이 'A'이거나 점수가 85점 이상인 학생의 이름과 점수를 조회합니다.
```sql
SELECT name, grade, score
FROM students
WHERE grade = 'A' OR score >= 85;
```

- **결과:**
```
name    | grade | score
--------|-------|------
Alice   | A     | 95
Bob     | B     | 85
Charlie | A     | 92
Eve     | B     | 88
Frank   | A     | 95
Hannah  | B     | 85
```


### **3.6 DISTINCT**
- **설명:** `DISTINCT`는 중복된 데이터를 제거하고 고유한 데이터만 검색합니다.

- **예제:** 중복 없이 학생들의 등급을 조회합니다.
```sql
SELECT DISTINCT grade
FROM students;
```

- **결과:**
```
grade
------
A
B
C
```

- 실습 후에는 테이블을 삭제하거나 데이터베이스를 초기화하여 다음 실습을 준비할 수 있습니다.

```sql
-- 테이블 삭제 (선택사항)
DROP TABLE students;
```


## **4.데이터 조작**
**테이블 생성 및 초기 데이터 설정**
먼저, 실습을 위해 간단한 `students` 테이블을 생성하고 초기 데이터를 삽입합니다.
```sql
-- students 테이블 생성
CREATE TABLE students (
    student_id INT PRIMARY KEY,
    name VARCHAR(50),
    age INT,
    grade CHAR(1)
);

-- 초기 데이터 삽입
INSERT INTO students (student_id, name, age, grade) VALUES
(1, 'Alice', 20, 'A'),
(2, 'Bob', 22, 'B'),
(3, 'Charlie', 21, 'C');
```



### **4.1 INSERT 문**
- **설명:** 새로운 학생 정보를 테이블에 추가합니다.

- **예제:** 
    ```sql
    -- 새로운 학생 추가
    INSERT INTO students (student_id, name, age, grade) VALUES
    (4, 'David', 19, 'A');

    -- 결과 확인
    SELECT * FROM students;
    ```

### **4.2 UPDATE 문**
- **설명:**  `UPDATE` 문을 사용하여 특정 조건(`WHERE`)을 만족하는 행의 값을 수정합니다. 예제에서는 `student_id`가 2인 학생(Bob)의 성적을 'A'로 변경했습니다.

- **예제:**
    ```sql
    -- Bob의 성적을 A로 변경
    UPDATE students
    SET grade = 'A'
    WHERE student_id = 2;

    -- 결과 확인
    SELECT * FROM students;
    ```



### **4.3 DELETE 문**
- **설명:** 특정 학생의 데이터를 삭제합니다.
- **예제:**
    ```sql
    -- Charlie의 데이터 삭제
    DELETE FROM students
    WHERE student_id = 3;

    -- 결과 확인
    SELECT * FROM students;
    ```


### **4.4 TRUNCATE TABLE 문**
- **설명:**  `TRUNCATE TABLE`은 테이블의 모든 데이터를 한 번에 삭제합니다. 이는 `DELETE`와 달리 로그를 남기지 않으므로 더 빠르지만, 조건을 지정할 수 없습니다. 예제에서는 `students` 테이블의 모든 데이터를 삭제했습니다.

- **예제:**
    ```sql
    -- 테이블의 모든 데이터 삭제
    TRUNCATE TABLE students;

    -- 결과 확인
    SELECT * FROM students;
    ```

- 실습 후에는 테이블을 삭제하거나 데이터베이스를 초기화하여 다음 실습을 준비

    ```sql
    -- 테이블 삭제 (선택사항)
    DROP TABLE students;
    ```



## **5.조건 및 연산**

**데이터 생성**
- 먼저 실습을 위해 두 개의 테이블(`students`와 `courses`)을 생성하고 샘플 데이터를 삽입.

    ```sql
    -- students 테이블 생성
    CREATE TABLE students (
        student_id INT PRIMARY KEY,
        name VARCHAR(50),
        age INT,
        grade CHAR(1),
        course_id INT,
        email VARCHAR(100)
    );

    -- courses 테이블 생성
    CREATE TABLE courses (
        course_id INT PRIMARY KEY,
        course_name VARCHAR(50),
        instructor VARCHAR(50)
    );

    -- students 테이블에 데이터 삽입
    INSERT INTO students (student_id, name, age, grade, course_id, email) VALUES
    (1, 'Alice', 20, 'A', 101, 'alice@example.com'),
    (2, 'Bob', 22, 'B', 102, NULL),
    (3, 'Charlie', 19, 'C', NULL, 'charlie@example.com'),
    (4, 'David', 21, 'A', 101, 'david@example.com'),
    (5, 'Eve', 23, 'F', NULL, NULL);

    -- courses 테이블에 데이터 삽입
    INSERT INTO courses (course_id, course_name, instructor) VALUES
    (101, 'Mathematics', 'Dr. Smith'),
    (102, 'Physics', 'Dr. Johnson'),
    (103, 'Chemistry', 'Dr. Brown');
    ```


### **5.1 NOT 조건**
- 특정 조건을 만족하지 않는 데이터를 검색합니다.  
- 예: 수학(Mathematics) 과목을 듣지 않는 학생 목록을 조회합니다.

    ```sql
    SELECT *
    FROM students
    WHERE course_id NOT IN (SELECT course_id FROM courses WHERE course_name = 'Mathematics');
    ```

### **5.2 ALIASES**
- 테이블이나 열에 별칭을 부여하여 쿼리를 간결하게 만듭니다.  
- 예: 학생 이름과 이메일을 조회하며, 열 이름을 간단히 표시합니다.

    ```sql
    SELECT name AS "Student Name", email AS "Email Address"
    FROM students;
    ```

### **5.3 JOINS**
- 여러 테이블의 데이터를 연결하여 검색합니다.  
- 예: 학생 이름과 그들이 수강 중인 과목 이름 및 강사를 조회합니다.

    ```sql
    SELECT s.name AS "Student Name", c.course_name AS "Course Name", c.instructor AS "Instructor"
    FROM students s
    JOIN courses c ON s.course_id = c.course_id;
    ```

### **5.4 BETWEEN 조건**
- 특정 범위 내에 있는 데이터를 검색합니다.  
- 예: 나이가 20세에서 22세 사이인 학생 목록을 조회합니다.

    ```sql
    SELECT *
    FROM students
    WHERE age BETWEEN 20 AND 22;
    ```

#### **5.5 IN 조건**
- 특정 값 목록에 포함된 데이터를 검색합니다.  
- 예: 성적이 'A' 또는 'B'인 학생 목록을 조회합니다.

    ```sql
    SELECT *
    FROM students
    WHERE grade IN ('A', 'B');
    ```

#### **5.6 IS NULL 조건**
- NULL 값을 가진 데이터를 검색합니다.  
- 예: 이메일 주소가 없는 학생 목록을 조회합니다.

    ```sql
    SELECT *
    FROM students
    WHERE email IS NULL;
    ```


### **5.7 IS NOT NULL 조건**
- NULL 값을 가지지 않는 데이터를 검색합니다.  
- 예: 이메일 주소가 있는 학생 목록을 조회합니다.

    ```sql
    SELECT *
    FROM students
    WHERE email IS NOT NULL;
    ```

### **5.8 LIKE 조건**
- 특정 패턴과 일치하는 데이터를 검색합니다.  
- 예: 이름이 'A'로 시작하는 학생 목록을 조회합니다.

    ```sql
    SELECT *
    FROM students
    WHERE name LIKE 'A%';
    ```

- 실습 후에는 테이블을 삭제하거나 데이터베이스를 초기화하여 다음 실습을 준비할 수 있습니다.

    ```sql
    -- 테이블 삭제 (선택사항)
    DROP TABLE students;
    ```



## **6.고급 쿼리**

- **샘플 데이터 생성**

    ```sql
    -- 학생 정보 테이블
    CREATE TABLE Students (
        StudentID INT PRIMARY KEY,
        Name VARCHAR(50),
        Age INT,
        Major VARCHAR(50)
    );

    -- 과목 정보 테이블
    CREATE TABLE Courses (
        CourseID INT PRIMARY KEY,
        CourseName VARCHAR(50),
        Credits INT
    );

    -- 수강 정보 테이블 (학생과 과목의 관계)
    CREATE TABLE Enrollments (
        EnrollmentID INT PRIMARY KEY,
        StudentID INT,
        CourseID INT,
        Grade CHAR(1)
    );

    -- 데이터 삽입
    INSERT INTO Students (StudentID, Name, Age, Major) VALUES
    (1, 'Alice', 20, 'Computer Science'),
    (2, 'Bob', 22, 'Mathematics'),
    (3, 'Charlie', 21, 'Physics'),
    (4, 'David', 23, 'Chemistry');

    INSERT INTO Courses (CourseID, CourseName, Credits) VALUES
    (101, 'Database Systems', 3),
    (102, 'Calculus', 4),
    (103, 'Quantum Mechanics', 3),
    (104, 'Organic Chemistry', 4);

    INSERT INTO Enrollments (EnrollmentID, StudentID, CourseID, Grade) VALUES
    (1001, 1, 101, 'A'),
    (1002, 1, 102, 'B'),
    (1003, 2, 102, 'A'),
    (1004, 3, 103, 'C'),
    (1005, 4, 104, 'B');
    ```

### **6.1 EXISTS 조건**
- **설명:** 서브쿼리의 결과가 존재하는지 확인합니다.

- **실습 예제:**
```sql
-- 'Database Systems' 과목을 수강한 학생이 있는지 확인
SELECT Name
FROM Students
WHERE EXISTS (
    SELECT 1
    FROM Enrollments e
    JOIN Courses c ON e.CourseID = c.CourseID
    WHERE e.StudentID = Students.StudentID AND c.CourseName = 'Database Systems'
);
```

#### **6.2 GROUP BY 절**
- **설명:** 특정 열을 기준으로 데이터를 그룹화합니다.

- **실습 예제:**
```sql
-- 각 전공별로 몇 명의 학생이 있는지 확인
SELECT Major, COUNT(*) AS StudentCount
FROM Students
GROUP BY Major;
```

#### **6.3 HAVING 절**
- **설명:** 그룹화된 데이터에 조건을 적용합니다.

- **실습 예제:**
```sql
-- 수강한 과목 수가 2개 이상인 학생 조회
SELECT StudentID, COUNT(*) AS CourseCount
FROM Enrollments
GROUP BY StudentID
HAVING COUNT(*) >= 2;
```

### **6.4 SELECT LIMIT 문**
- **설명:** 검색 결과의 개수를 제한합니다.

- **실습 예제:**
```sql
-- 나이가 많은 순으로 상위 2명의 학생 조회
SELECT Name, Age
FROM Students
ORDER BY Age DESC
LIMIT 2;
```

### **6.5 DELETE LIMIT 문**
- **설명:** 삭제하는 데이터의 개수를 제한합니다.

- **실습 예제:**
```sql
-- 가장 낮은 학점(C)을 받은 수강 기록 중 하나 삭제
DELETE FROM Enrollments
WHERE Grade = 'C'
LIMIT 1;
```

### **6.6 UNION 연산자**
- **설명:** 여러 SELECT 문의 결과를 합쳐서 보여줍니다 (중복 제거).

- **실습 예제:**
```sql
-- 'Computer Science' 전공 학생과 'Physics' 전공 학생의 이름 목록 합치기
SELECT Name FROM Students WHERE Major = 'Computer Science'
UNION
SELECT Name FROM Students WHERE Major = 'Physics';
```

### **6.7 UNION ALL 연산자**
- **설명:** 여러 SELECT 문의 결과를 합쳐서 보여줍니다 (중복 포함).

- **실습 예제:**
```sql
-- 'Computer Science' 전공 학생과 'Physics' 전공 학생의 이름 목록 합치기 (중복 포함)
SELECT Name FROM Students WHERE Major = 'Computer Science'
UNION ALL
SELECT Name FROM Students WHERE Major = 'Physics';
```

### **6.8 INTERSECT 연산자**
- **설명:** 여러 SELECT 문의 결과에서 공통된 부분만 보여줍니다.

- **참고:** MySQL에서는 `INTERSECT`를 직접 지원하지 않으므로, 아래와 같이 서브쿼리로 대체 가능:
```sql
SELECT StudentID
FROM Enrollments
WHERE CourseID = 101 AND StudentID IN (
    SELECT StudentID
    FROM Enrollments
    WHERE CourseID = 102
);
```

#### **6.9 Subqueries**
- **설명:** 쿼리 안에 또 다른 쿼리를 사용하여 복잡한 검색을 수행합니다.

- **실습 예제:**
```sql
-- 평균 수강 과목 수보다 많은 과목을 수강한 학생 조회
SELECT StudentID, COUNT(*) AS CourseCount
FROM Enrollments
GROUP BY StudentID
HAVING COUNT(*) > (
    SELECT AVG(CourseCount)
    FROM (
        SELECT COUNT(*) AS CourseCount
        FROM Enrollments
        GROUP BY StudentID
    ) AS AvgCourses
);
```

- 실습 후에는 테이블을 삭제하거나 데이터베이스를 초기화하여 다음 실습을 준비할 수 있습니다.

    ```sql
    -- 테이블 삭제 (선택사항)
    DROP TABLE students;
    ```


## **7.테이블 관리**
### **7.1 Data Types 및 CREATE TABLE 문**
- 테이블 열의 데이터 유형을 정의하고 새로운 테이블을 생성합니다.

    ```sql
    -- 학생 정보를 저장할 테이블 생성
    CREATE TABLE Students (
        StudentID INT PRIMARY KEY,          -- 정수형 기본 키
        Name VARCHAR(50),                   -- 가변 길이 문자열 (최대 50자)
        Age INT,                            -- 정수형
        Email VARCHAR(100),                 -- 이메일 주소 (가변 길이 문자열)
        EnrollmentDate DATE                 -- 날짜 형식
    );
    ```

- **실습 예제:**
    
    ```sql
    INSERT INTO Students (StudentID, Name, Age, Email, EnrollmentDate)
    VALUES (1, 'Alice', 20, 'alice@example.com', '2023-09-01'),
        (2, 'Bob', 22, 'bob@example.com', '2023-09-02');

    SELECT * FROM Students;
    ```

### **7.2 CREATE TABLE AS 문**
- 기존 테이블의 데이터를 기반으로 새로운 테이블을 생성합니다.

    ```sql
    -- Students 테이블에서 나이가 21세 이상인 학생들만 포함하는 새 테이블 생성
    CREATE TABLE AdultStudents AS
    SELECT * FROM Students WHERE Age >= 21;
    ```

- **실습 예제:**    
    ```sql
    SELECT * FROM AdultStudents;
    ```

### **7.3 Primary Keys**
- 테이블의 각 행을 고유하게 식별하는 열을 정의합니다.

    ```sql
    -- 강의 정보를 저장할 테이블 생성 (CourseID가 기본 키)
    CREATE TABLE Courses (
        CourseID INT PRIMARY KEY,
        CourseName VARCHAR(100),
        Credits INT
    );
    ```

- **실습 예제:**
    - 기본 키를 사용하여 데이터를 삽입하고 중복된 `CourseID`를 삽입하려고 시도해보세요.

    ```sql
    INSERT INTO Courses (CourseID, CourseName, Credits)
    VALUES (101, 'Mathematics', 3),
        (102, 'Physics', 4);

    -- 중복된 CourseID 삽입 시도 (오류 발생)
    INSERT INTO Courses (CourseID, CourseName, Credits)
    VALUES (101, 'Chemistry', 3);
    ```

### **7.4 ALTER TABLE 문**
- 테이블의 구조를 변경합니다.

    ```sql
    -- Students 테이블에 전화번호 열 추가
    ALTER TABLE Students ADD PhoneNumber VARCHAR(15);

    -- Students 테이블에서 PhoneNumber 열 삭제
    ALTER TABLE Students DROP COLUMN PhoneNumber;

    -- Students 테이블의 Email 열 이름 변경
    ALTER TABLE Students RENAME COLUMN Email TO ContactEmail;
    ```

- **실습 예제:**
    - `ALTER TABLE` 명령어를 사용하여 테이블 구조를 수정한 후 테이블 스키마를 확인하세요.
    ```sql
    DESCRIBE Students;
    ```

### **7.5 DROP TABLE 문**
- 테이블을 삭제합니다.

    ```sql
    -- AdultStudents 테이블 삭제
    DROP TABLE AdultStudents;
    ```

- **실습 예제:**
    - `DROP TABLE` 명령어를 실행한 후 `AdultStudents` 테이블이 더 이상 존재하지 않는지 확인하세요.
    ```sql
    SELECT * FROM AdultStudents; -- 오류 발생 (테이블이 존재하지 않음)
    ```

### **7.6 VIEW**
- 하나 이상의 테이블을 기반으로 가상의 테이블을 생성합니다.

    ```sql
    -- 학생과 강좌 정보를 결합한 뷰 생성
    CREATE VIEW StudentCourseView AS
    SELECT s.StudentID, s.Name, c.CourseName, c.Credits
    FROM Students s
    JOIN Courses c ON s.StudentID = c.CourseID;
    ```

- **실습 예제:**
    - `StudentCourseView` 뷰를 쿼리하여 데이터를 확인하세요.
    ```sql
    SELECT * FROM StudentCourseView;
    ```


### **7.7 Unique Constraints**
- 열의 값이 중복되지 않도록 제약 조건을 설정합니다.

    ```sql
    -- 강좌 정보 테이블에 CourseName에 대해 UNIQUE 제약 조건 추가
    ALTER TABLE Courses ADD CONSTRAINT UniqueCourseName UNIQUE (CourseName);
    ```

- **실습 예제:**
    - 동일한 `CourseName`을 삽입하려고 시도해보고 오류가 발생하는지 확인하세요.
    ```sql
    INSERT INTO Courses (CourseID, CourseName, Credits)
    VALUES (103, 'Physics', 4); -- 오류 발생 (중복된 CourseName)
    ```


### **7.8 Indexes**
- 데이터 검색 속도를 향상시키기 위한 인덱스를 생성합니다.

    ```sql
    -- Students 테이블의 Name 열에 인덱스 생성
    CREATE INDEX idx_student_name ON Students(Name);
    ```

- **실습 예제:**
    - 인덱스가 생성된 후 `Name` 열을 기준으로 데이터를 검색해보고 성능 차이를 확인하세요.
    ```sql
    EXPLAIN SELECT * FROM Students WHERE Name = 'Alice';
    ```

    - 실습 후에는 테이블을 삭제하거나 데이터베이스를 초기화하여 다음 실습을 준비할 수 있습니다.
    ```sql
    -- 테이블 삭제 (선택사항)
    DROP TABLE students;
    ```


## **8.사용자 및 권한**

- **환경 설정 및 데이터 준비**

```sql
-- 데이터베이스 생성
CREATE DATABASE IF NOT EXISTS school;
USE school;

-- 학생 정보 테이블 생성
CREATE TABLE students (
    student_id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50) NOT NULL,
    grade INT NOT NULL
);

-- 샘플 데이터 삽입
INSERT INTO students (name, grade) VALUES
('Alice', 1),
('Bob', 2),
('Charlie', 3);
```


### **8.1 CREATE USER 문**
- 새로운 사용자를 생성합니다.
```sql
-- 새로운 사용자 생성
CREATE USER 'teacher'@'localhost' IDENTIFIED BY 'password123';
```

### **8.2 Grant / Revoke Privileges**
- 사용자에게 특정 권한을 부여하거나 취소합니다.
    ```sql
    -- teacher 사용자에게 students 테이블에 대한 SELECT 권한 부여
    GRANT SELECT ON school.students TO 'teacher'@'localhost';

    -- teacher 사용자에게 INSERT 권한 추가 부여
    GRANT INSERT ON school.students TO 'teacher'@'localhost';

    -- teacher 사용자의 INSERT 권한 취소
    REVOKE INSERT ON school.students FROM 'teacher'@'localhost';
    ```

### **8.3 Show grants for user in MySQL**
- 특정 사용자의 현재 권한을 확인합니다.
```sql
-- teacher 사용자의 권한 확인
SHOW GRANTS FOR 'teacher'@'localhost';
```

### **8.4 Change a user password**
- 사용자의 비밀번호를 변경합니다.

```sql
-- teacher 사용자의 비밀번호 변경
ALTER USER 'teacher'@'localhost' IDENTIFIED BY 'newpassword456';
```

### **8.5. RENAME USER 문**
- 사용자의 이름을 변경합니다.
```sql
-- teacher 사용자의 이름을 instructor로 변경
RENAME USER 'teacher'@'localhost' TO 'instructor'@'localhost';
```

### **8.6 DROP USER 문**
- 사용자를 삭제합니다.
```sql
-- instructor 사용자 삭제
DROP USER 'instructor'@'localhost';
```

### **8.7 Find Users in MySQL**
- MySQL에 등록된 모든 사용자 목록을 확인합니다.
```sql
-- 사용자 목록 확인
SELECT User, Host FROM mysql.user;
```

### **8.8 Find users logged into MySQL**
- 현재 MySQL에 접속한 사용자 목록을 확인합니다.
```sql
-- 현재 접속한 사용자 목록 확인
SELECT USER(), CURRENT_USER();
SHOW PROCESSLIST;
```

- 실습 후에는 생성된 사용자와 데이터를 정리하기 위해 `DROP USER`와 `DROP DATABASE` 명령어를 사용하세요.
```sql
-- 실습 후 정리
DROP USER IF EXISTS 'teacher'@'localhost';
DROP USER IF EXISTS 'instructor'@'localhost';
DROP DATABASE IF EXISTS school;
```



## **9.프로그래밍 요소**

## **10.트리거**
