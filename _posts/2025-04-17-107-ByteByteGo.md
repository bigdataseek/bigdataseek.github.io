---
title: 32차시 7:ByteByteGo
layout: single
classes: wide
categories:
  - ByteByteGo
toc: true # 이 포스트에서 목차를 활성화
toc_sticky: true # 목차를 고정할지 여부 (선택 사항)
---

## 91.  데이터 파이프라인
- 출처: [What is Data Pipeline? \| Why Is It So Popular?](https://www.youtube.com/watch?v=kGT4PcTEPP8)

### **91.1 데이터 파이프라인이란?**

* 마치 공장의 자동화된 생산 라인처럼, **데이터 파이프라인**은 여러 데이터 소스에서 쏟아져 들어오는 방대한 양의 데이터를 체계적으로 수집(Collect), 가공(Transform), 그리고 최종 목적지로 전달(Deliver)하여 데이터가 실질적인 가치를 창출하도록 돕는 **자동화된 데이터 처리 흐름**입니다.
* 이는 단순한 데이터 이동을 넘어, 조직이 **데이터 기반 의사 결정**을 내리고, 새로운 **비즈니스 기회를 발굴**하며, 궁극적으로 **혁신**을 이루는 데 없어서는 안 될 핵심적인 인프라입니다.
* 데이터 파이프라인은 그 목적과 복잡성에 따라 매우 다양한 형태로 존재하며, 데이터를 한 지점에서 다른 지점으로 이동시키는 모든 자동화된 프로세스를 포괄합니다. 예를 들어, 간단한 파일 복사 스크립트부터 복잡한 실시간 데이터 처리 시스템까지 모두 데이터 파이프라인의 범주에 포함될 수 있습니다.

### **91.2 데이터 파이프라인의 일반적인 단계**

* **수집(Collect):** 
    - 데이터 여정의 첫걸음으로, 다양한 형태와 위치에 존재하는 데이터를 한 곳으로 모으는 단계입니다.
    * **데이터 저장소(Data Stores):** 
        - 관계형 데이터베이스(MySQL, Postgres), NoSQL 데이터베이스(DynamoDB) 등에서 발생하는 **운영 데이터(Transactional Data)**를 수집합니다. 이는 사용자의 회원 가입 정보, 상품 주문 내역, 결제 기록 등 비즈니스 운영의 핵심적인 기록들을 포함합니다.
    * **데이터 스트림(Data Streams):** 
        - Apache Kafka, Amazon Kinesis와 같은 플랫폼을 이용하여 웹사이트 클릭 이벤트, 사용자 검색어, IoT 장치에서 발생하는 센서 데이터 등 **실시간으로 생성되는 데이터 피드**를 지속적으로 캡처합니다. 이러한 데이터는 즉각적인 분석 및 대응에 활용될 수 있습니다.
    * **애플리케이션:** 
        - 다양한 애플리케이션에서 생성되는 로그 데이터, API 호출 결과 등을 수집합니다. 예를 들어, 웹 서버 로그, 모바일 앱 사용 기록 등이 이에 해당합니다.
* **적재/유입(Ingest):** 
    - 수집된 데이터를 본격적인 데이터 파이프라인 환경으로 안전하고 효율적으로 적재하는 단계입니다.
    * **실시간 데이터:** 
        - Apache Kafka, Amazon Kinesis와 같은 스트리밍 플랫폼을 통해 **데이터가 생성되는 즉시** 파이프라인으로 흘러 들어가도록 구성합니다.
    * **데이터베이스 데이터:** 
        - 주기적인 **배치 프로세스**를 통해 전체 데이터를 한 번에 가져오거나, **변경 데이터 캡처(CDC, Change Data Capture)** 도구를 사용하여 데이터베이스의 변경 사항만을 실시간 또는 거의 실시간으로 파이프라인에 반영합니다. CDC는 데이터의 최신성을 유지하는 데 중요한 역할
* **저장(Store):** 
    - 수집 및 적재된 데이터를 즉시 처리할 수도 있지만, 일반적으로는 **데이터 레이크(Data Lake)**와 같은 중앙 집중식 저장소에 먼저 저장한 후 필요에 따라 처리하는 방식을 많이 사용합니다. 이는 다양한 형태의 원시 데이터를 효율적으로 관리하고, 향후 다양한 분석 요구에 유연하게 대응할 수 있도록 합니다.
* **연산(Compute):** 
    - 저장된 데이터를 분석 및 활용 목적에 맞게 가공하고 변환하는 핵심 단계입니다.
    * **배치 처리(Batch Processing):** 
        - **대량의 데이터를 정해진 시간 간격(예: 매일, 매주)**으로 묶어서 처리합니다.
        * 도구: 
            - Apache Spark, Apache Hadoop MapReduce, Apache Hive와 같은 분산 처리 프레임워크를 활용하여 대규모 데이터셋을 효율적으로 처리합니다. (예: 매일 밤의 모든 판매 데이터를 집계하여 일일 판매 보고서를 생성)
    * **스트림 처리(Stream Processing):** 
        - **데이터가 생성되는 즉시 실시간으로 처리**합니다.
        * 도구: 
            - Apache Flink, Google Cloud Dataflow, Apache Storm, Apache Samza 등을 사용하여 실시간 데이터 스트림에서 특정 패턴을 감지하거나, 이상 징후를 탐지하는 데 활용됩니다. (예: 실시간으로 발생하는 금융 거래를 분석하여 사기 가능성이 높은 거래를 즉시 탐지)
    * **ETL/ELT (Extract, Transform, Load / Extract, Load, Transform):** 
        - 데이터를 추출, 변환, 적재하는 일련의 과정을 **오케스트레이션**하는 중요한 단계입니다. ETL은 데이터를 먼저 변환한 후 저장소에 적재하는 방식이고, ELT는 데이터를 먼저 저장소에 적재한 후 필요에 따라 변환하는 방식입니다.
        * 도구: 
            - Apache Airflow, AWS Glue와 같은 워크플로우 관리 도구를 사용하여 복잡한 데이터 처리 단계를 자동화하고 관리합니다.
        * 수행 작업: 
            - 데이터 정제(결측치 처리, 이상치 제거), 데이터 형식 표준화, 여러 데이터 소스 간의 데이터 통합, 분석에 용이한 형태로의 데이터 변환 및 집계, 데이터 보강(외부 데이터 결합) 등 다양한 데이터 품질 향상 및 분석 준비 작업을 수행합니다.
* **소비(Consume):** 
    - 최종적으로 처리되고 변환된 데이터를 사용자들이 다양한 방식으로 활용할 수 있도록 제공하는 단계
    * **데이터 과학 팀:** 
        - 정제되고 분석 준비가 완료된 데이터를 활용하여 **예측 모델링**을 수행합니다. (예: 과거 고객 데이터를 기반으로 고객 이탈 가능성을 예측하는 모델 개발)
        * 도구: 
            - Jupyter Notebooks, TensorFlow, PyTorch와 같은 데이터 과학 도구를 활용합니다.
    * **비즈니스 인텔리전스(BI) 도구:** 
        - 처리된 데이터를 기반으로 **시각화된 대시보드 및 보고서**를 생성하여 비즈니스 성과를 모니터링하고 중요한 통찰력을 얻을 수 있도록 지원합니다.
        * 도구: 
            - Tableau, Power BI와 같은 BI 플랫폼을 사용합니다.
    * **셀프 서비스 분석 도구:** 
        - 데이터에 대한 지식이 없는 사용자도 **직접 필요한 데이터를 쿼리하고 분석**할 수 있도록 지원.
        * 도구: 
            - Looker, LookML과 같은 셀프 서비스 BI 도구를 활용합니다.
    * **머신러닝 모델:** 
        - 새롭게 들어오는 데이터를 기반으로 **지속적으로 학습하고 성능을 개선**하여 예측 또는 분류 작업을 수행합니다. (예: 실시간 사용자 행동 데이터를 기반으로 사기 거래를 탐지하는 모델 운영)

### **91.3 데이터 저장소 옵션**

* **데이터 레이크(Data Lake):** 
    - 다양한 형태(정형, 반정형, 비정형)의 **원시 데이터를 그대로 저장**하는 중앙 집중식 저장소입니다. 스키마를 미리 정의할 필요 없이 데이터를 저장할 수 있어 유연성이 높고, 다양한 분석 요구에 대응.
    * 도구: 
        - Amazon S3, HDFS(Hadoop Distributed File System)와 같은 확장 가능한 객체 저장소 또는 분산 파일 시스템을 사용합니다.
    * 형식: 
        - CSV, JSON, XML뿐만 아니라 효율적인 분석을 위한 컬럼 기반 형식인 Parquet, Avro 등을 활용하여 저장합니다.
* **데이터 웨어하우스(Data Warehouse):** 
    - 비즈니스 분석 및 보고를 위해 **구조화되고 정제된 데이터를 저장**하는 저장소입니다. 특정 분석 목적에 맞춰 데이터를 모델링하고 최적화하여 빠른 쿼리 성능을 제공합니다.
    * 도구: 
        - Snowflake, Amazon Redshift, Google BigQuery와 같은 클라우드 기반 데이터 웨어하우스 솔루션을 많이 사용합니다.
* **데이터 레이크하우스(Data Lakehouse):** 
    - 데이터 레이크의 유연성과 데이터 웨어하우스의 관리 용이성 및 분석 성능을 결합한 새로운 데이터 저장 패러다임입니다. ACID 트랜잭션, 스키마 강제, 데이터 거버넌스 등의 기능을 데이터 레이크에 추가하여 **다양한 분석 워크로드**를 효율적으로 지원합니다.

## 92. 메시지 큐 아키텍처
- 출처: [Kafka vs. RabbitMQ vs. Messaging Middleware vs. Pulsar](https://www.youtube.com/watch?v=x4k1XEjNzYQ)

### **92.1 메시지 큐란?**

* 핵심적으로, 메시지 큐는 시스템을 구성하는 여러 독립적인 부분, 즉 **송신자(Producer)** 와 **수신자(Consumer)** 가 서로의 작업 완료 여부에 구애받지 않고 **비동기적**으로 데이터를 주고받을 수 있도록 설계된 **소프트웨어 구성 요소**입니다. 마치 우편 시스템처럼, 송신자는 메시지를 '우체통(큐)'에 넣고, 수신자는 필요할 때 '우체통'에서 메시지를 꺼내 처리합니다.
* 이러한 구조는 송신자와 수신자가 서로에 대한 직접적인 의존성 없이 **독립적으로 작동**하도록 중간에서 **중재자** 역할을 수행하며, 시스템의 각 컴포넌트가 자신의 역할에 집중할 수 있도록 돕습니다.
* 결과적으로, 메시지 큐는 시스템의 **확장 가능성(Scalability)** 을 높이고, 각 컴포넌트 간의 결합도를 낮춰 **느슨하게 결합된(Loosely Coupled)** 구조를 만들어 **내결함성(Fault Tolerance)** 이 뛰어난 시스템을 구축하는 데 필수적인 요소가 됩니다. 특정 컴포넌트에 장애가 발생하더라도, 메시지 큐는 메시지를 안전하게 보관하고 있다가 장애 복구 후 정상적으로 전달하여 전체 시스템의 안정성을 유지합니다.
* 더 나아가, 메시지 큐는 **안정적인 통신**을 보장하고, 시간이 오래 걸리는 작업을 백그라운드에서 처리하는 **비동기 작업 처리**를 지원하며, 대량의 데이터를 실시간으로 효율적으로 처리하는 **고처리량 데이터 스트림 처리**를 가능하게 합니다.

### **92.2 활용 사례**

* **Uber:** 
    - 승객의 **라이더 요청**과 가장 가까운 **운전자 연결** 프로세스를 메시지 큐를 통해 분리함으로써, 급증하는 실시간 요청을 효율적으로 처리하고 시스템의 응답성을 높입니다. 만약 메시지 큐가 없다면, 라이더 앱의 요청 처리와 운전자 매칭 로직이 하나의 시스템에서 동시에 처리되어 부하가 집중되고 시스템 장애로 이어질 가능성이 커집니다.

### **92.3 메시지 큐 아키텍처 진화**

| 기술          | 출시 | 특징                                                                                                                               | 활용 예시                                                                      | 주요 기능                                                                                                                                                                                             |
| ----------- | ---- | ---------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| IBM MQ      | 1993 | **엔터프라이즈 메시징** 분야의 **선구자**로서, 오랜 기간 동안 **안정성, 보안, 트랜잭션 지원**에 강점을 가져왔습니다. 금융권과 같이 데이터의 정확성과 신뢰성이 중요한 환경에서 핵심적인 역할을 수행합니다. | **대형 은행:** 고객의 **금융 거래**를 **안정적**이고 **정확**하게 처리하는 데 활용됩니다.                                                                             | **영구/비영구 메시징**, **강력한 트랜잭션 지원(ACID 속성)**, **다양한 플랫폼 지원(OS, 하드웨어)**, 메시지 우선순위 처리, 보안 기능(SSL/TLS) 제공.                                                               |
| RabbitMQ    | 2007 | **유연하고 동적인 메시징 모델**을 제공하며, **AMQP, MQTT, STOMP** 등 다양한 표준 프로토콜을 지원하여 이기종 시스템 간의 연동에 용이합니다. 개발자 친화적인 인터페이스와 다양한 플러그인 생태계를 가지고 있습니다. | **전자상거래 플랫폼:** 사용자의 **주문 처리**, 상품 **재고 업데이트** 등 다양한 백엔드 작업을 비동기적으로 처리하여 사용자 경험을 향상시킵니다.                                                               | **메시지 라우팅(Exchange)**, **다양한 큐잉 방식(Direct, Fanout, Topic, Headers)**, **Pub-Sub 메시징 모델 지원**, **플러그인 시스템을 통한 기능 확장**, **클러스터링을 통한 가용성 확보**, **세분화된 메시지 승인(Acknowledgement)** 기능 제공. |
| Apache Kafka  | 2011 | **고처리량**의 **실시간 데이터 스트리밍** 처리에 특화되어 있으며, **확장성**과 **내결함성**을 강력하게 제공합니다. **분산 커밋 로그** 기반의 아키텍처는 대규모 데이터를 안정적으로 처리하고, 여러 컨슈머 그룹이 독립적으로 데이터를 소비할 수 있도록 지원합니다. | **LinkedIn:** 사용자의 **실시간 활동 알림**, 사용자 행동 기반 **데이터 분석** 파이프라인 구축에 활용되어 개인화된 서비스를 제공하고 데이터 기반 의사 결정을 지원합니다.                                                               | **파티션된 로그 아키텍처(수평적 확장 용이)**, **데이터 내구성 및 고가용성 확보(데이터 복제)**, **컨슈머 그룹을 통한 독립적인 데이터 소비**, **선택적인 Exactly-Once 의미 체계 지원**을 통한 데이터 처리 정확성 향상.                                                               |
| Apache Pulsar |      | Kafka의 **높은 확장성 및 성능**과 기존 메시지 큐의 **유연성 및 다양한 기능**을 결합한 차세대 메시징 시스템입니다. **클라우드 네이티브 아키텍처**를 기반으로 설계되었으며, **멀티 테넌시**를 기본적으로 지원하고 **계층형 스토리지**를 통해 비용 효율성을 높입니다. | (아직 구체적인 활용 사례는 더 많이 등장할 것으로 예상됩니다.)                                                                                                                             | **멀티 테넌시 지원(하나의 클러스터에서 여러 독립적인 사용자 환경 제공)**, **지리적 복제(데이터 센터 간 재해 복구 및 낮은 지연 시간 보장)**, **계층형 스토리지(고성능/저비용 스토리지 분리)**, **Pulsar Functions을 통한 스트림 처리**, **Pulsar IO 커넥터를 통한 외부 시스템과의 용이한 통합**.                                                               |

## 93. 데이터베이스 확장 전략
- 출처: [7 Must-know Strategies to Scale Your Database](https://www.youtube.com/watch?v=_1IKwnbscQU)

### **93.1 확장 필요성 및 시점**

*   애플리케이션 성장으로 데이터 양과 사용자 수가 증가하면 데이터베이스 성능 저하 발생 (응답 시간 지연, 타임아웃, 장애 등).
*   원활한 운영 및 좋은 사용자 경험 유지를 위해 확장이 필수적.
*   예시: 스타트업의 급격한 사용자 증가, 아마존과 같은 이커머스 플랫폼의 특정 시기 트래픽 폭증.

### **93.2 데이터베이스 확장 7가지 핵심 전략**

| **전략**          | **설명**                                                                                                                                           | **장점**                                                                                                                                                                                                                   | **단점**                                                                                                                                                                                 | **예시**                                                                                                                                                             |
| ---------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **인덱싱 (Indexing)** | 특정 정보 검색 속도를 높이기 위해 색인 생성 (책의 찾아보기와 유사).                                                                                               | 검색 쿼리 실행 시간 단축. B-tree 인덱스는 정렬된 데이터 유지에 적합하며, 범위 검색에 효과적.                                                                                                                                      | 데이터 수정 시 인덱스 업데이트 필요로 쓰기 작업 속도 저하 가능. 최적의 성능 유지를 위해 어떤 필드에 인덱싱할지 균형이 중요.                                                                               | 온라인 쇼핑몰 고객 데이터베이스에서 주문 ID나 고객 ID 기반으로 주문 내역 빠르게 검색.                                                                                                                              |
| **구체화된 뷰 (Materialized Views)** | 복잡한 쿼리의 결과를 미리 계산하여 저장해 둠.                                                                                                           | 쿼리 계산 부하 감소로 성능 향상.                                                                                                                                                                                           | 데이터 최신 유지를 위해 주기적으로 갱신해야 함. 갱신 작업은 리소스 소모가 클 수 있음. 갱신 빈도와 성능 이점 간의 균형이 중요.                                                                                     | 비즈니스 인텔리전스 플랫폼에서 대용량 데이터셋 기반 일일 판매 보고서 생성 시, 미리 계산된 판매 데이터 저장하여 보고서 생성 속도 향상.                                                                                                        |
| **비정규화 (Denormalization)** | 데이터 검색 속도 향상을 위해 중복 데이터 저장.                                                                                                            | 쿼리 복잡성 감소 및 데이터 검색 속도 향상.                                                                                                                                                                                 | 데이터 일관성 유지를 위한 업데이트 관리 복잡도 증가. 일관성 유지 실패 시 문제 발생 가능성 증가.                                                                                                       | 소셜 미디어 플랫폼에서 사용자 게시물과 정보를 같은 테이블에 저장하여 사용자 피드 표시 속도 향상.                                                                                                                               |
| **수직적 확장 (Vertical Scaling)** | CPU, RAM, 스토리지 등 서버 자원 증설.                                                                                                              | 비교적 구현이 간단하며, 애플리케이션 아키텍처 변경 불필요. 즉각적인 성능 개선 가능.                                                                                                                                                     | 하드웨어 최대 용량 제한 존재. 추가 업그레이드 비용이 비싸질 수 있음. 단일 서버 장애 시 전체 데이터베이스 다운 위험.                                                                                                      | 온라인 마켓플레이스의 데이터베이스 서버 성능 향상을 위해 CPU 업그레이드, RAM 증설, 스토리지 확장.                                                                                                                        |
| **캐싱 (Caching)**         | 자주 사용되는 데이터를 더 빠른 저장소에 저장.                                                                                                              | 데이터베이스 부하 감소 및 응답 시간 단축.                                                                                                                                                                                    | 캐시 무효화 문제 발생 가능 (최신 데이터 유지 필요). 캐시 갱신 전략 필수 (시간 기반 만료 또는 이벤트 기반 업데이트).                                                                                                     | 온라인 스트리밍 서비스에서 사용자가 영화 제목 검색 시, 데이터베이스 쿼리 대신 캐시에서 영화 메타데이터 검색하여 표시 속도 향상.                                                                                                                            |
| **복제 (Replication)**      | 주 데이터베이스의 복사본을 여러 서버에 생성.                                                                                                              | 가용성 향상, 부하 분산, 내결함성 강화.                                                                                                                                                                                           | 데이터 일관성 유지 복잡성 증가 (특히 분산 시스템). 스토리지 및 유지 보수 오버헤드 증가. 동기 복제 시 지연 시간 발생 가능, 비동기 복제 시 일시적인 불일치 발생 가능.                                                                     | N/A                                                                                                                                                                 |
| **샤딩 (Sharding)**        | 대규모 데이터베이스를 작고 관리하기 쉬운 조각 (샤드)으로 분할. 각 샤드는 데이터의 하위 집합을 포함.                                                                                             | 데이터베이스 수평 확장에 효과적. 각 서버가 데이터 일부 처리하여 읽기/쓰기 성능 향상.                                                                                                                                                  | 데이터베이스 설계 및 관리 복잡성 증가. 적절한 샤딩 키 선정 중요 (데이터 및 작업량 균등 분산). 여러 샤드에 대한 쿼리 복잡성 증가. 샤드 불균형 시 재샤딩 작업 필요 (리소스 소모 큼).                                                                   | 소셜 미디어 플랫폼에서 사용자 ID별로 데이터베이스 샤딩하여 각 사용자의 데이터를 특정 샤드에 저장.                                                                                                                                |


## 94. 병행성(Concurrency) vs 병렬성(Parallelism)
- 출처: [Concurrency Vs Parallelism!](https://www.youtube.com/watch?v=RlM9AfWf1WU)


### **94.1 병행성 (Concurrency)**

* **정의:** 
    - 단일 CPU 코어에서 여러 작업을 **논리적으로 동시에** 진행되는 것처럼 보이게 하는 추상적인 개념입니다. 실제로는 CPU가 매우 짧은 시간 간격으로 여러 작업의 실행 맥락(Context)을 빠르게 전환(Context Switching)하며 작업을 조금씩 처리합니다. 마치 여러 개의 작업이 동시에 진행되는 듯한 **환상**을 제공합니다.
* **원리:** 
    - CPU의 시분할(Time-Sharing) 방식을 활용합니다. 각 작업에 아주 짧은 시간 할당량(Time Slice)을 부여하고, 이 할당량 동안 작업을 실행한 후 다음 작업으로 빠르게 전환합니다. 이 전환 속도가 매우 빨라 사용자에게는 동시에 처리되는 것처럼 느껴집니다.
* **장점:**
    * **I/O 바운드(I/O-bound) 작업에 탁월한 효율:** 
        - 디스크 읽기/쓰기, 네트워크 요청과 같이 CPU 연산보다 대기 시간이 긴 작업이 포함된 경우, CPU가 대기하는 동안 다른 작업을 처리함으로써 전체 시스템의 유휴 시간을 줄이고 효율성을 극대화
    * **향상된 사용자 경험:** 
        - 응답성이 중요한 사용자 인터페이스(UI) 환경에서, 오래 걸리는 작업을 백그라운드로 처리하고 사용자 입력에 즉각적으로 반응할 수 있도록 만들어 사용자 경험을 향상시킵니다.
    * **자원 활용도 증대:** 
        - 단일 코어의 CPU를 최대한 활용하여 시스템의 전반적인 처리량을 늘릴 수 있습니다.
* **단점:**
    * **Context Switching 오버헤드:** 
        - 작업 전환 과정에서 현재 작업의 상태를 저장하고 다음 작업의 상태를 불러오는 Context Switching은 CPU 자원을 소모하는 부가적인 작업입니다.
    * **성능 저하 가능성:** 
        - 과도한 Context Switching은 오히려 CPU 사용률을 높이고, 각 작업에 할당되는 실제 처리 시간을 줄여 전체적인 성능 저하를 유발할 수 있습니다. 특히 CPU 집중적인(CPU-bound) 작업이 많은 경우 효율이 떨어질 수 있습니다.
    * **복잡한 설계 및 디버깅:** 
        - 여러 작업이 공유 자원에 접근할 때 발생할 수 있는 동시성 문제(레이스 컨디션, 데드락 등)를 고려하여 프로그램을 설계하고 디버깅해야 하므로 복잡도가 증가합니다.
* **예시:**
    * **요리사가 여러 요리를 번갈아 가며 준비하는 상황:** 
        - 찌개 끓이기, 야채 다듬기, 고기 굽기 등의 작업을 순서대로 조금씩 처리하며 전체 요리 과정을 관리합니다.
    * **웹 서버가 단일 코어에서 여러 사용자 요청을 처리하는 상황:** 
        - 동시에 여러 사용자의 HTTP 요청을 받아들여 각 요청에 대한 처리를 짧은 시간씩 번갈아 가며 응답합니다.
    * **운영체제의 멀티태스킹:** 
        - 사용자가 여러 개의 애플리케이션을 동시에 실행하는 것처럼 보이지만, 실제로는 운영체제가 각 애플리케이션에 CPU 시간을 분할하여 할당하고 빠르게 전환하며 실행합니다.

### **94.2 병렬성 (Parallelism)**

* **정의:** 
    - 여러 개의 독립적인 CPU 코어 또는 처리 장치(GPU, TPU 등)를 사용하여 **실제로 여러 작업을 동시에** 실행하는 것입니다. 각 코어가 독립적으로 하나의 작업을 온전히 처리합니다.
* **원리:** 
    - 시스템 내에 물리적으로 여러 개의 실행 단위가 존재하며, 각 실행 단위가 서로 다른 작업을 동시에 처리하거나 하나의 작업을 분할하여 동시에 처리합니다.
* **장점:**
    * **과부하 연산 작업의 압도적인 처리 속도 향상:** 
        - 복잡한 계산, 대용량 데이터 처리, 그래픽 렌더링 등 CPU 자원을 많이 사용하는 작업을 여러 코어가 동시에 처리함으로써 실행 시간을 획기적으로 단축할 수 있습니다.
    * **실시간 처리 능력 향상:** 
        - 여러 작업을 진정한 의미로 동시에 처리할 수 있으므로, 실시간성이 중요한 시스템에서 예측 가능하고 빠른 응답성을 보장할 수 있습니다.
    * **확장성 용이:** 
        - 더 많은 처리 능력이 필요할 때, 단순히 CPU 코어 수를 늘리거나 병렬 처리 장치를 추가하는 방식으로 시스템 성능을 확장하기 용이합니다.
* **단점:**
    * **하드웨어 의존성:** 
        - 병렬성을 제대로 활용하기 위해서는 멀티 코어 CPU 또는 병렬 처리 장치와 같은 하드웨어 지원이 필수적입니다.
    * **자원 관리의 복잡성:** 
        - 여러 코어가 공유 자원(메모리 등)에 동시에 접근할 때 발생할 수 있는 데이터 일관성 문제, 동기화 문제 등을 해결하기 위한 복잡한 자원 관리 메커니즘이 필요합니다.
    * **작업 분할 및 조율의 어려움:** 
        - 하나의 작업을 여러 개의 독립적인 하위 작업으로 효율적으로 분할하고, 각 작업의 실행 결과를 다시 통합하는 과정이 어려울 수 있습니다.
* **예시:**
    * **두 명의 요리사가 각자 다른 요리를 동시에 준비하는 상황:** 
        - 한 명은 찌개를 끓이고, 다른 한 명은 고기를 굽는 것처럼 독립적인 작업을 동시에 수행합니다.
    * **머신러닝 모델 훈련 시 여러 코어 또는 장비에 작업을 분산하는 상황:** 
        - 대규모 데이터를 여러 개의 작은 배치로 나누어 각 코어에서 병렬적으로 학습을 진행하여 전체 학습 시간을 단축합니다. 분산 컴퓨팅 환경에서는 여러 대의 서버가 병렬적으로 작업을 처리할 수도 있습니다.
    * **이미지 또는 비디오 편집 소프트웨어의 렌더링:** 
        - 각 프레임 또는 이미지의 특정 영역을 여러 코어가 동시에 처리하여 렌더링 시간을 단축합니다.

### **94.3 병행성과 병렬성의 관계**

* **관리 vs 실행:** 
    - 병행성은 **여러 작업을 효율적으로 관리**하여 마치 동시에 실행되는 것처럼 보이게 하는 기술이며, 병렬성은 **실제로 여러 작업을 동시에 실행**하는 하드웨어 및 소프트웨어 능력입니다.
* **구조화와 가능성:** 
    - 병행성은 프로그램을 여러 개의 독립적인 실행 단위로 구조화하여 병렬 실행이 가능한 기반을 마련해 줍니다. 즉, 병행적인 설계를 통해 작업을 더 작은 단위로 나누고, 이 나뉜 작업들이 병렬적으로 실행될 수 있도록 준비하는 것입니다.
* **분할 용이성:** 
    - 병행적인 프로그래밍 모델(예: 스레드, 비동기 프로그래밍)은 작업을 독립적으로 관리하고 실행할 수 있도록 도와주므로, 궁극적으로 병렬성을 활용하기 더 쉬운 환경을 제공합니다.
* **보장하지 않음:** 
    - 병행성을 적용했다고 해서 반드시 병렬성이 확보되는 것은 아닙니다. 단일 코어 CPU 환경에서는 병행적으로 설계된 프로그램도 실제로는 시간을 분할하여 순차적으로 실행될 뿐입니다. 병렬성의 이점을 얻기 위해서는 멀티 코어 CPU와 같은 병렬 처리 하드웨어가 필수적입니다. 병행성은 이러한 하드웨어를 효율적으로 활용하기 위한 소프트웨어적인 전략입니다.

### **94.4 활용 분야**

* **병행성:**
    * **웹 애플리케이션:** 
        - 여러 사용자의 동시 요청 처리, 사용자 입력에 대한 즉각적인 반응 유지, 데이터베이스 쿼리 실행 중에도 다른 작업 처리, 이미지 업로드 또는 이메일 발송과 같은 백그라운드 작업 처리 등 사용자 경험 향상 및 시스템 효율성 증대에 핵심적인 역할을 합니다.
    * **GUI (Graphical User Interface) 애플리케이션:** 
        - 사용자 인터페이스의 응답성을 유지하면서 백그라운드에서 데이터 처리나 네트워크 통신과 같은 시간이 오래 걸리는 작업을 수행합니다.
    * **이벤트 기반 시스템:** 
        - 다양한 외부 이벤트(마우스 클릭, 네트워크 패킷 도착 등)에 동시에 반응하고 처리해야 하는 시스템에 적용됩니다.
* **병렬성:**
    * **머신러닝:** 
        - 대규모 데이터셋을 이용한 모델 훈련, 복잡한 신경망 계산 등 막대한 연산량을 요구하는 작업의 처리 시간을 단축합니다. 분산 학습을 통해 여러 장비의 병렬성을 활용하기도 합니다.
    * **비디오 렌더링:** 
        - 각 프레임을 독립적인 작업으로 간주하여 여러 코어에서 동시에 렌더링함으로써 영상 제작 시간을 크게 줄입니다.
    * **과학 시뮬레이션:** 
        - 복잡한 물리적, 화학적 현상을 모델링하고 시뮬레이션하는 데 필요한 방대한 계산을 병렬적으로 처리합니다. (예: 날씨 예측, 분자 모델링)
    * **빅데이터 처리:** 
        - Hadoop, Spark와 같은 분산 처리 프레임워크는 대규모 데이터를 여러 노드에 분산시키고 각 노드에서 병렬적으로 데이터를 처리하여 분석 속도를 높입니다.
    * **고성능 컴퓨팅 (HPC):** 
        - 과학 기술 연구, 공학 시뮬레이션 등 최고 수준의 연산 성능을 요구하는 분야에서 필수적으로 활용됩니다.
    * **게임 개발:** 
        - 복잡한 게임 로직, 물리 엔진, AI 처리, 그래픽 렌더링 등을 병렬적으로 처리하여 부드럽고 현실감 넘치는 게임 경험을 제공합니다.

### **94.5 결론**

* **반응성 유지 (병행성):** 
    - 병행성은 주로 I/O 바운드 작업이 많은 환경에서 시스템의 반응성을 높이고, 사용자가 애플리케이션을 사용하는 동안 멈춤 없이 다양한 작업을 수행할 수 있도록 관리하는 데 중요한 역할을 합니다.
* **성능 향상 (병렬성):** 
    - 병렬성은 CPU 집중적인 작업을 여러 코어에서 동시에 처리하여 전체적인 처리량을 극적으로 향상시키는 데 핵심적인 기술입니다.
* **조화로운 설계:** 
    - 병행성을 기반으로 프로그램을 잘 설계하고, 이를 멀티 코어 환경에서 병렬적으로 실행할 수 있도록 구현하는 것이 가장 효율적인 시스템 설계 방식입니다. 병행성 개념을 이해하고 활용하여 프로그램을 모듈화하고 독립적인 작업 단위로 나누면, 자연스럽게 병렬성을 적용할 여지가 많아져 시스템의 성능과 효율성을 동시에 높일 수 있습니다. 즉, 병행성은 효율적인 병렬성 활용을 위한 토대를 제공합니다.

## 95. Linux 파일 권한
- 출처: [Linux Crash Course - Understanding File Permissions](https://www.youtube.com/watch?v=4N4Q576i3zA)

- Linux에서 파일 권한을 정확히 이해하고 관리하는 것은 시스템의 안정성과 보안을 확보하는 데 **필수적인** 요소입니다. 이는 단순히 파일 접근 여부를 결정하는 것을 넘어, 시스템 리소스의 효율적인 관리와 잠재적인 보안 위협으로부터 시스템을 보호하는 기반이 됩니다.

### **95.1 소유권 (Ownership): 파일과 디렉토리를 누가 책임지고 있는가?**

* **사용자 (User):** 
    - 해당 파일을 **최초로 생성한 사용자**입니다. 파일 소유자는 파일에 대한 **가장 강력한 제어 권한**을 가지며, 필요에 따라 파일 권한을 변경할 수 있습니다. 시스템 내의 각 사용자는 고유한 사용자 ID(UID)를 가지며, 이 UID를 통해 파일 소유자가 식별됩니다.
* **그룹 (Group):** 
    - **여러 사용자를 묶어 놓은 단위**입니다. 특정 파일이나 디렉토리에 대한 **동일한 액세스 권한을 공유**해야 하는 사용자들을 하나의 그룹으로 묶을 수 있습니다. 각 그룹은 고유한 그룹 ID(GID)를 가지며, 파일은 특정 그룹에 소속될 수 있습니다. 이를 통해 여러 사용자가 공동으로 작업하는 환경에서 효율적인 권한 관리가 가능해집니다.
* **Others (기타 사용자):** 
    - 파일의 **소유자도 아니고, 해당 파일의 그룹에 속해 있지도 않은 모든 사용자**를 의미합니다. 이들은 파일에 대한 **가장 제한적인 제어 권한**을 가집니다. 시스템 보안을 위해 Others의 권한 설정은 특히 주의 깊게 관리해야 합니다.

### **95.2 권한 종류 (Permissions): 파일과 디렉토리에 대해 무엇을 할 수 있는가?**

* **읽기 (Read):**
    * **파일:** 파일의 **내용을 열어서 보고 복사**할 수 있는 권한입니다.
    * **디렉토리:** 디렉토리 내에 있는 **파일과 하위 디렉토리의 목록을 확인**할 수 있는 권한입니다.
* **쓰기 (Write):**
    * **파일:** 파일의 **내용을 수정, 삭제, 이름 변경**할 수 있는 권한입니다.
    * **디렉토리:** 디렉토리 내에 **새로운 파일이나 하위 디렉토리를 생성, 기존 파일이나 하위 디렉토리를 삭제 또는 이름 변경**할 수 있는 권한입니다. 디렉토리에 대한 쓰기 권한은 그 내용을 변경하는 데 매우 중요합니다.
* **실행 (Execute):**
    * **파일:** 파일을 **프로그램이나 스크립트**로 직접 실행할 수 있는 권한입니다. 일반적인 텍스트 파일 등은 실행 권한이 있어도 실행되지 않습니다.
    * **디렉토리:** 디렉토리를 **탐색**하고, 해당 디렉토리 내의 파일이나 하위 디렉토리에 **접근**할 수 있는 권한입니다. 실행 권한이 없으면 해당 디렉토리로 `cd` 명령어를 사용하여 이동할 수 없습니다.

### **95.3 권한 표현 (Representation): 권한을 어떻게 나타내는가?**

* **이진수 (Binary):** 
    - 각 권한(읽기, 쓰기, 실행)의 존재 유무를 **1(활성화) 또는 0(비활성화)의 비트**로 표현합니다. 순서대로 읽기(r), 쓰기(w), 실행(x)에 해당합니다. 예를 들어, 읽기 및 실행 권한만 있는 경우 `101`로 표현
* **8진수 (Octal):** 
    - 이진수 표현을 **세 자리의 8진수**로 변환하여 표현합니다. 각 자리는 각각 소유자, 그룹, Others의 권한을 나타냅니다. 읽기(r)는 4, 쓰기(w)는 2, 실행(x)는 1의 값을 가지며, 각 권한의 값을 더하여 8진수 숫자를 얻습니다. 예를 들어, `rwx`는 4+2+1=7, `rw-`는 4+2+0=6, `r--`는 4+0+0=4로 표현
* **문자열 (String):** 
    - 각 권한을 **문자**로 표현합니다. 소유자, 그룹, Others 순으로 각각 읽기(`r`), 쓰기(`w`), 실행(`x`) 권한이 있으면 해당 문자로 표시되고, 권한이 없으면 하이픈(`-`)으로 표시됩니다. 예를 들어, 소유자에게 모든 권한이 있고, 그룹에게 읽기 및 쓰기 권한만 있고, Others에게 읽기 권한만 있는 경우 `-rwxrwxr--` 와 같이 총 10개의 문자로 표현됩니다. (첫 번째 문자는 파일 유형을 나타냅니다. 일반 파일은 `-`, 디렉토리는 `d` 등으로 표시됩니다.)

**예시:**

* 소유자: `rwx` (이진수: `111`, 8진수: `4+2+1=7`) - 모든 권한 보유
* 그룹: `rw-` (이진수: `110`, 8진수: `4+2+0=6`) - 읽기 및 쓰기 권한 보유
* Others: `r--` (이진수: `100`, 8진수: `4+0+0=4`) - 읽기 권한만 보유
* 8진수 표현: `764` - 위 권한 설정을 8진수 하나로 간결하게 표현
* `chmod 764 filename` : `chmod` 명령어는 파일의 권한을 변경하는 데 사용되며, 위 예시는 `filename`이라는 파일의 권한을 소유자에게 `rwx`, 그룹에게 `rw-`, Others에게 `r--`로 설정하는 명령어입니다.

### **95.4 특수 권한 비트 (Special Permission Bits): 일반적인 권한 외의 특별한 기능**

* **SetUID (Set User ID):**
    * **실행 파일이 실행될 때**, 파일을 실행하는 사용자의 실제 사용자 ID(Real UID) 대신 **파일 소유자의 유효 사용자 ID(Effective UID)로 일시적으로 변경**되어 실행됩니다. 이는 특정 프로그램이 일반 사용자 권한으로는 접근할 수 없는 시스템 자원에 접근해야 할 때 유용하게 사용
    * 소유자의 실행 비트 위치에 **`s`** (실행 권한이 있는 경우) 또는 **`S`** (실행 권한이 없는 경우)로 표시
    * **예시:** `passwd` 명령어는 일반 사용자가 자신의 비밀번호를 변경하기 위해 실행되지만, 실제로는 root 권한으로 실행되어 `/etc/shadow` 파일에 접근하고 수정할 수 있도록 SetUID가 설정되어 있습니다.
* **SetGID (Set Group ID):**
    * **파일:** 실행 파일이 실행될 때, 파일을 실행하는 사용자의 실제 그룹 ID(Real GID) 대신 **파일 그룹의 유효 그룹 ID(Effective GID)로 일시적으로 변경**되어 실행됩니다. 이는 특정 그룹에게만 접근 권한이 있는 자원에 접근해야 할 때 사용됩니다.
    * **디렉토리:** 디렉토리에 SetGID가 설정되면, 해당 **디렉토리 내에 새로 생성되는 파일과 하위 디렉토리가 자동으로 해당 디렉토리의 그룹 소유권을 상속**받습니다. 또한, 새로운 파일들은 해당 디렉토리의 그룹 쓰기 권한을 상속받습니다. 이는 여러 사용자가 동일한 그룹으로 협업하는 환경에서 파일 공유 및 관리를 용이하게 합니다.
    * 그룹의 실행 비트 위치에 **`s`** (실행 권한이 있는 경우) 또는 **`S`** (실행 권한이 없는 경우)로 표시됩니다.
* **Sticky Bit:**
    * 주로 **공유 디렉토리 (예: `/tmp`)** 에 설정되어, 해당 디렉토리 내의 파일이나 하위 디렉토리를 **삭제 또는 이름 변경할 수 있는 사용자를 제한**합니다. Sticky Bit이 설정된 디렉토리에서는 파일의 **소유자, 디렉토리의 소유자 또는 root 사용자**만이 해당 파일을 삭제하거나 이름을 변경할 수 있습니다. 다른 사용자는 자신의 파일만 삭제 또는 이름 변경할 수 있습니다.
    * Others의 실행 비트 위치에 **`t`** (실행 권한이 있는 경우) 또는 **`T`** (실행 권한이 없는 경우)로 표시
    * **예시:** `/tmp` 디렉토리는 모든 사용자가 임시 파일을 저장하는 공유 공간이므로, 다른 사용자의 파일을 함부로 삭제하는 것을 방지하기 위해 Sticky Bit이 설정되어 있습니다.

**특수 권한 설정 예시:**

```bash
chmod 4755 important_script
```

* `4`: SetUID 비트 설정 (8진수 4000)
* `7`: 소유자의 권한 (읽기, 쓰기, 실행 - 8진수 700)
* `5`: 그룹의 권한 (읽기, 실행 - 8진수 050)
* `5`: Others의 권한 (읽기, 실행 - 8진수 005)
* 따라서 `4755`는 SetUID를 설정하고, 소유자에게 읽기/쓰기/실행, 그룹과 Others에게 읽기/실행 권한을 부여합니다.

### **95.5 중요성**

* **정밀한 권한 관리 및 강력한 보안 유지:** 
    - 파일 및 디렉토리에 대한 세밀한 권한 설정을 통해 **무단 접근 및 악의적인 행위를 방지**하고 시스템의 보안 수준을 향상시킵니다.
* **의도치 않은 데이터 손실 및 시스템 오류 예방:** 
    - 잘못된 권한 설정으로 인해 발생할 수 있는 **실수로 인한 파일 수정, 삭제 또는 실행 오류를 방지**하여 시스템의 안정성을 높입니다.
* **안전하고 효율적인 협업 환경 조성:** 
    - 다수의 사용자가 함께 작업하는 환경에서 적절한 권한 관리를 통해 **데이터를 보호하고 원활한 협업을 보장**합니다. 각 사용자는 필요한 권한만 부여받아 작업 효율성을 높이고 보안 위험을 최소화


## 96. 웹 인증 방식 분석: 세션 기반 vs. JWT
- 출처: [Session Vs JWT: The Differences You May Not Know!](https://www.youtube.com/watch?v=fyTxwIa-1U0)

- 세션 기반 인증과 JWT 인증 방식의 작동 원리, 구체적인 장단점을 심층적으로 이해하고, 애플리케이션의 특성과 요구 사항에 따라 최적의 인증 방식을 현명하게 선택할 수 있도록 상세한 정보를 제공한다.

### **96.1 세션 기반 인증**

* **흐름:**
    1.  **사용자 인증 정보 제출:** 
        - 사용자가 아이디, 비밀번호와 같은 로그인 정보를 웹 애플리케이션 서버에 전송한다. 이때, HTTPS와 같은 보안 프로토콜을 사용하여 정보의 안전한 전송을 보장하는 것이 중요하다.
    2.  **서버의 인증 및 세션 생성:** 
        - 서버는 수신된 로그인 정보를 데이터베이스와 같은 저장소에 보관된 사용자 정보와 비교하여 인증을 수행한다. 
        - 인증에 성공하면, 서버는 해당 사용자를 위한 고유한 세션 ID를 생성하고, 세션 데이터(사용자 ID, 로그인 시간, 권한 정보, 만료 시간 등)를 서버의 메모리, 데이터베이스, 또는 Redis와 같은 캐시 시스템에 저장한다.
    3.  **세션 ID 쿠키 발급:** 
        - 생성된 세션 ID는 HTTP 응답 헤더의 `Set-Cookie`를 통해 클라이언트의 웹 브라우저에 쿠키 형태로 전달된다. 
        - 이때, 쿠키의 속성(HttpOnly, Secure, SameSite 등)을 적절히 설정하여 보안을 강화할 수 있다.
    4.  **클라이언트의 세션 ID 쿠키 저장:** 
        - 클라이언트(웹 브라우저)는 서버로부터 받은 세션 ID 쿠키를 저장하고, 이후 해당 웹 애플리케이션에 대한 모든 HTTP 요청 시 자동으로 쿠키를 요청 헤더에 담아 서버에 전송한다.
    5.  **서버의 세션 확인 및 요청 처리:** 
        - 서버는 클라이언트로부터 받은 세션 ID 쿠키를 확인하고, 해당 세션 ID로 세션 저장소에서 저장된 세션 데이터를 조회한다. 유효한 세션 데이터가 발견되면, 서버는 사용자를 인증된 상태로 간주하고 요청된 리소스에 대한 접근 권한을 확인한 후 요청을 처리하여 응답한다.

* **핵심:** 
    - 서버는 각 활성 사용자마다 세션 데이터를 별도로 관리하며, 클라이언트와의 연결 상태를 유지하기 위해 세션 ID를 매개로 활용한다. 
    - 이는 서버 측에 상태를 저장하는 Stateful 방식이다.

* **장점:**
    * **간편한 세션 만료 (Revocation):** 
        - 서버 측에서 특정 세션 ID에 해당하는 세션 데이터를 삭제함으로써 해당 사용자의 모든 활성 세션을 즉시 만료시킬 수 있다. 
        - 이는 계정 탈취와 같은 보안 사고 발생 시 신속하게 대응할 수 있도록 한다.
    * **민감한 데이터의 안전한 보관:** 
        - 사용자 정보, 권한 정보와 같은 민감한 데이터를 서버 측 세션 저장소에 안전하게 보관할 수 있다. 
        - 클라이언트에게는 세션 ID만 노출되므로, 정보 유출의 위험을 줄일 수 있다.
    * **상대적으로 쉬운 구현:** 
        - 기본적인 세션 관리 기능은 대부분의 웹 프레임워크에서 기본적으로 제공하므로, JWT에 비해 초기 구현이 상대적으로 용이할 수 있다.

* **단점:**
    * **분산 시스템에서의 복잡성:** 
        - 여러 대의 서버로 구성된 분산 시스템 환경에서는 모든 서버가 동일한 세션 데이터에 접근하고 공유할 수 있도록 중앙 집중식 세션 저장소(Redis, Memcached, 분산 데이터베이스 등)를 구축하고 관리해야 한다.
        -  이는 시스템의 복잡성을 증가시키고, 잠재적인 단일 실패 지점(Single Point of Failure)이 됨.
    * **세션 저장소 접근으로 인한 성능 저하 가능성:** 
        - 매 요청마다 서버가 세션 저장소에 접근하여 세션 데이터를 확인해야 하므로, 트래픽이 많은 환경에서는 세션 저장소의 부하 증가 및 응답 지연을 야기할 수 있다.
    * **서버 자원 사용 증가:** 
        - 활성 사용자 수에 비례하여 서버의 메모리 또는 세션 저장소의 공간 사용량이 증가한다. 많은 수의 사용자를 처리해야 하는 대규모 서비스에서는 서버 자원 관리가 중요해진다.
    * **CORS (Cross-Origin Resource Sharing) 문제:** 
        - 쿠키 기반 인증은 서로 다른 도메인 간의 요청에서 보안상의 이유로 제한될 수 있다. CORS 설정을 적절히 관리해야 한다.

### **96.2 JWT (JSON Web Token) 기반 인증**

* **흐름:**
    1.  **사용자 인증 정보 제출:** 
        - 사용자가 로그인 정보를 서버에 전송한다. HTTPS를 통한 보안 통신은 필수적이다.
    2.  **서버의 인증 및 JWT 생성:** 
        - 서버는 로그인 정보를 검증하고, 유효한 사용자임이 확인되면 JSON 형식의 데이터(payload)를 포함하는 JWT를 생성한다. 
        - 이 payload에는 사용자 ID, 권한 정보, 토큰 발급 시간, 만료 시간 등 필요한 정보가 담길 수 있다.
    3.  **JWT 서명:** 
        - 생성된 JWT의 무결성을 보장하기 위해 서버의 비밀 키(secret key)를 사용하여 서명한다. 
        - 서명 알고리즘으로는 HMAC (대칭 키 방식) 또는 RSA, ECDSA (비대칭 키 방식) 등이 사용된다.
    4.  **JWT 클라이언트에게 전달:** 
        - 생성 및 서명된 JWT는 HTTP 응답 body 또는 헤더(Authorization 헤더에 Bearer 스키마와 함께 포함)를 통해 클라이언트에게 전송된다.
    5.  **클라이언트의 JWT 저장:** 
        - 클라이언트는 수신한 JWT를 로컬 스토리지, 쿠키, 또는 메모리와 같은 저장소에 안전하게 보관한다. 
        - 보안 측면에서는 XSS(Cross-Site Scripting) 공격에 취약한 로컬 스토리지보다는 HttpOnly 쿠키에 저장하는 것이 더 안전할 수 있다.
    6.  **클라이언트의 JWT 전송:** 
        - 이후 클라이언트는 보호된 리소스에 접근하기 위한 모든 HTTP 요청 시 JWT를 Authorization 헤더에 담아 서버에 전송한다. 일반적으로 "Bearer $\[JWT\]$" 형식으로 전송된다.
    7.  **서버의 JWT 검증 및 인증/권한 부여:** 
        - 서버는 클라이언트로부터 받은 JWT의 서명을 서버가 가진 비밀 키(또는 공개 키)를 사용하여 검증한다. 
        - 서명이 유효하고 만료되지 않았으며, payload에 포함된 정보가 신뢰할 수 있다면, 서버는 별도의 데이터베이스 조회 없이 JWT 내의 정보를 기반으로 사용자를 인증하고 요청된 리소스에 대한 접근 권한을 부여한다.

* **핵심:** 
    - 서버는 세션 상태를 유지하지 않고, JWT 자체에 필요한 모든 정보를 담아 클라이언트에게 전달한다. 
    - 각 요청은 JWT를 통해 스스로를 증명하므로 Stateless한 구조를 가진다.

* **서명 알고리즘:**
    * **HMAC (Hash-based Message Authentication Code, 대칭 키):** 
        - 서버와 클라이언트(엄밀히는 토큰을 발행하고 검증하는 주체)가 동일한 비밀 키를 공유하여 JWT를 서명하고 검증한다. 
        - 구현이 간단하고 효율적이지만, 키가 노출될 경우 보안상의 위험이 크므로 주로 내부 서비스 간 통신이나 모놀리식 아키텍처에서 사용될 수 있다.
    * **RSA (Rivest–Shamir–Adleman), ECDSA (Elliptic Curve Digital Signature Algorithm, 비대칭 키):** 
        - 공개 키와 개인 키 쌍을 사용한다. 
        - 서버의 개인 키로 JWT를 서명하고, 클라이언트는 서버의 공개 키로 서명을 검증한다. 개인 키는 안전하게 서버에 보관되며, 공개 키는 외부에 노출되어도 안전하므로 MSA(Microservices Architecture) 환경이나 외부 서비스와의 연동 시 보안성을 높일 수 있다. 
        - RSA는 키 길이가 길어 보안성이 높지만 연산 비용이 높고, ECDSA는 더 짧은 키 길이로 유사한 보안성을 제공하며 연산 속도도 빠르다.
        * **활용:** 
            - 일반적으로 단일 서버 환경 또는 내부 서비스 간 통신에서는 HMAC을 고려할 수 있으며, 마이크로서비스 아키텍처 환경이나 외부 서비스와의 안전한 연동이 필요한 경우에는 RSA 또는 ECDSA와 같은 비대칭 키 알고리즘을 사용하는 것이 권장된다.

* **JWT 만료 처리:**
    * **Access Token과 Refresh Token 활용:** 
        - JWT 자체는 Stateless하므로 서버에서 강제로 만료시킬 수 없다. 따라서 토큰 탈취 시 악용될 수 있는 위험을 줄이기 위해 짧은 수명의 Access Token과 긴 수명의 Refresh Token을 함께 사용하는 것이 일반적인 방법이다.
        * **Access Token:** 
            - 비교적 짧은 만료 시간(예: 15분 ~ 1시간)을 가지며, 실제 API 요청 시 인증에 사용된다.
        * **Refresh Token:** 
            - Access Token보다 훨씬 긴 만료 시간(예: 며칠 ~ 몇 주)을 가지며, Access Token이 만료되었을 때 새로운 Access Token을 발급받기 위해 사용된다. 
            - Refresh Token은 탈취될 경우 장기간 악용될 수 있으므로 안전하게 관리하는 것이 중요
    * **Access Token 갱신 흐름:** 
        - Access Token이 만료시, 클라이언트는 Refresh Token을 서버의 토큰 갱신 엔드포인트로 전송. 
        - 서버는 수신된 Refresh Token의 유효성을 검사하고, 유효하다면 새로운 Access Token과 Refresh Token(선택적으로)을 클라이언트에게 발급해 준다. 
        - 이 과정에서 사용자 개입은 필요하지 않으므로 사용자 경험을 향상시킬 수 있다.
    * **Refresh Token 사용 시점:** 
        - Refresh Token은 Access Token이 만료되어 더 이상 사용할 수 없을 때에만 사용해야 한다. 
        - 매 API 요청마다 Refresh Token을 사용하는 것은 불필요한 트래픽을 유발하고 보안상의 위험을 증가시킬 수 있다.

### **96.3 선택 기준**

* **세션 기반 인증이 적합한 경우:**
    * **즉각적인 세션 만료가 중요한 경우:** 
        - 관리자 권한으로 특정 사용자의 세션을 즉시 만료시키거나, 사용자가 로그아웃했을 때 모든 활성 세션을 즉시 종료해야 하는 요구 사항이 있는 경우에 유리하다.
    * **기존 중앙 집중식 데이터 저장소 활용이 용이한 경우:** 
        - 이미 Redis나 분산 데이터베이스와 같은 중앙 집중식 데이터 저장소를 사용하고 있으며, 이를 세션 관리에 활용하는 것이 시스템 구조에 자연스러운 경우 고려할 수 있다.
    * **민감한 사용자 데이터의 서버 측 안전한 관리가 중요한 경우:** 
        - 사용자 정보나 권한과 같은 민감한 데이터를 클라이언트에게 노출시키지 않고 서버 측에서만 안전하게 관리해야 하는 보안 요구 사항이 높은 경우 적합하다.
    * **상대적으로 작은 규모의 서비스:** 
        - 서버의 확장성이 크게 중요하지 않고, 관리해야 할 세션 수가 많지 않은 소규모 서비스에서는 세션 기반 인증이 구현 및 관리가 더 단순할 수 있다.

* **JWT 기반 인증이 적합한 경우:**
    * **Stateless 아키텍처가 필요한 경우:** 
        - 여러 대의 서버로 확장하기 용이한 Stateless한 구조를 지향하는 마이크로서비스 아키텍처 환경에서 각 서비스가 독립적으로 사용자를 인증하고 권한을 부여할 수 있도록 한다.
    * **서로 다른 도메인 또는 서비스 간 인증 데이터 공유가 필요한 경우:** 
        - API 게이트웨이 또는 여러 백엔드 서비스가 동일한 JWT를 통해 사용자를 인증하고 권한을 공유해야 하는 경우 효율적이다.
    * **클라이언트 중심의 설계:** 
        - 클라이언트 측에서 토큰을 저장하고 관리하며, 서버는 매 요청마다 토큰의 유효성만 검증하면 되므로 서버의 부담을 줄일 수 있다.
    * **모바일 애플리케이션과의 연동:** 
        - 모바일 앱은 쿠키 관리가 웹 브라우저만큼 편리하지 않으므로, JWT를 HTTP 헤더에 담아 전송하는 방식이 더 적합할 수 있다.
    * **Access Token과 Refresh Token을 통한 보안 강화 및 사용자 경험 개선:** 
        - 짧은 만료 시간의 Access Token으로 보안을 강화하고, 만료 시 Refresh Token을 사용하여 사용자 불편 없이 새로운 Access Token을 발급받아 지속적인 서비스 이용이 가능하도록 한다.


## 97. 컴퓨터 과학의 혁신을 이끈 25가지 연구 논문
- 출처: [25 Computer Papers You Should Read!](https://www.youtube.com/watch?v=_kynGl5hr9U)

### **97.1 분산 시스템 및 데이터베이스 분야의 패러다임 전환**

* **Google File System (GFS):** 
    - 대규모 데이터 집약적 애플리케이션을 위해 설계된 이 혁신적인 분산 파일 시스템은 수많은 저가형 하드웨어로 구성된 환경에서도 뛰어난 성능과 안정성을 제공하며, 장애 상황을 효과적으로 관리하는 방법을 제시했습니다. GFS의 설계는 이후 수많은 분산 스토리지 시스템의 기반이 되었습니다.
* **Amazon Dynamo:** 
    - 여러 데이터 센터에 걸쳐 확장 가능한 고가용성 키-값 저장소인 Dynamo는 특정 오류 상황에서 데이터의 일관성보다는 서비스의 가용성을 우선시하는 새로운 접근 방식을 제시했습니다. 객체 버전 관리 및 애플리케이션 수준의 충돌 해결 기법을 통해 극한의 확장성과 안정성을 확보했습니다.
* **BigTable & Cassandra:** 
    - 이 두 논문은 대규모 구조화된 데이터를 효율적으로 관리하면서도 높은 가용성과 내결함성을 보장하는 분산 NoSQL 데이터베이스의 잠재력을 입증했습니다. 전통적인 관계형 데이터베이스의 한계를 뛰어넘는 새로운 데이터 관리 패러다임을 열었습니다.
    * **BigTable (Google):** 
        - 낮은 지연 시간과 뛰어난 확장성을 특징으로 하며, 대규모 데이터 처리 및 실시간 분석에 최적화되어 있습니다. Google의 다양한 핵심 서비스에 활용되며 NoSQL 데이터베이스 설계에 큰 영향을 미쳤습니다.
    * **Apache Cassandra (Facebook):** 
        - Dynamo와 BigTable의 주요 기능을 결합하여 빠른 읽기 및 쓰기 성능을 제공하는 확장 가능한 다중 마스터 복제 시스템입니다. 높은 가용성과 강력한 성능으로 많은 기업에서 채택하고 있습니다.
* **Google Spanner:** 
    - 전 세계적으로 일관성과 확장성을 동시에 제공하는 고가용성 분산 데이터베이스 시스템인 Spanner는 분산 데이터베이스 기술의 수준을 한 단계 끌어올렸습니다. TrueTime API를 도입하여 전역적으로 일관된 스냅샷과 다중 버전 동시성 제어를 가능하게 하여 복잡한 분산 트랜잭션 관리를 용이하게 함.
* **FoundationDB:** 
    - 다중 모델 키-값 저장소 아키텍처를 통해 분산 트랜잭션을 처리하는 혁신적인 방식을 제시했습니다. 분산 시스템 전반에 걸쳐 강력한 일관성(ACID 속성)을 보장하면서 다양한 데이터 모델을 지원하여 유연성과 안정성을 동시에 제공합니다.
* **Amazon Aurora:** 
    - 스토리지와 컴퓨팅을 분리하는 혁신적인 아키텍처를 통해 고성능 관계형 데이터베이스의 새로운 가능성을 열었습니다. 필요에 따라 자동으로 확장 및 축소되는 탄력적인 스토리지를 제공하며, 3개의 가용 영역에 걸친 6방향 복제를 통해 뛰어난 가용성과 데이터 내구성을 보장합니다.

### **97.2 데이터 처리 및 분석 분야의 혁명**

* **Google MapReduce:** 
    - 대규모 하드웨어 클러스터에서 대규모 데이터 세트의 병렬 처리를 가능하게 함으로써 빅데이터 처리 분야에 혁명적인 변화를 가져왔습니다. 복잡한 데이터 처리 작업을 단순화하고 확장성을 확보하여 대규모 데이터 분석의 시대를 열었습니다.
* **Apache Hadoop:** 
    - MapReduce의 오픈 소스 구현체로서, 동일한 원칙을 기반으로 대규모 데이터를 효율적으로 처리할 수 있는 강력한 프레임워크를 제공합니다. 빅데이터 생태계의 핵심 기술로 자리매김했습니다.
* **Flink:** 
    - 스트림 처리와 배치 처리를 통합하여 실시간 데이터와 과거 데이터를 모두 일관된 방식으로 처리할 수 있도록 했습니다. 배치 처리를 스트리밍의 특수한 경우로 간주하는 통일된 아키텍처를 통해 데이터 집약적인 애플리케이션 개발을 위한 강력한 기반을 제공합니다.
* **Apache Kafka:** 
    - LinkedIn에서 개발된 이 분산 메시징 플랫폼은 실시간 데이터 스트리밍을 위한 업계 표준으로 자리 잡았습니다. 안정성, 확장성, 내결함성을 갖춘 데이터 파이프라인 구축을 지원하며, 실시간 데이터 처리 및 분석의 핵심 인프라로 활용됩니다.
* **Google Dapper:** 
    - 낮은 오버헤드와 애플리케이션 수준의 투명성을 제공하는 분산 추적 시스템을 제시하여 복잡한 분산 시스템의 성능 문제 해결 및 최적화를 용이하게 합니다. 시스템의 동작 방식을 심층적으로 이해하고 병목 지점을 식별하는 데 중요한 역할을 합니다.
* **Google Monarch:** 
    - 막대한 양의 시계열 데이터를 효율적으로 저장하고 쿼리하기 위해 설계된 인-메모리 시계열 데이터베이스입니다. 지역화된 아키텍처를 통해 뛰어난 확장성과 안정성을 제공하며, 모니터링 및 분석 시스템의 핵심 구성 요소로 활용됩니다.

### **97.3 분산 시스템의 난제 해결을 위한 돌파구**

* **Google Borg:** 
    - Google이 대규모 클러스터를 관리하는 방식을 상세히 설명하며 컨테이너 기술의 개념을 도입하여 중앙 집중식 클러스터 관리 시스템의 효율성과 이점을 보여줍니다. 현대 클라우드 컴퓨팅 기술의 기반이 되는 중요한 아이디어를 제시했습니다.
* **Uber Shard Manager:** 
    - 분산 시스템에서 데이터 파티셔닝(샤딩) 관리를 위한 일반적인 프레임워크를 제시하여 데이터베이스 확장성과 성능 향상을 위한 중요한 기술적 토대를 마련했습니다.
* **Google Zanzibar:** 
    - 전역적인 액세스 제어 시스템으로, 대규모 분산 시스템에서 액세스 제어 목록(ACL)을 효율적으로 관리하는 방법을 제시합니다. 일관성 있고 안전한 권한 관리를 위한 핵심 기술입니다.
* **Facebook Thrift:** 
    - 코드 생성 도구의 설계 고려 사항을 탐구하고, 공통 인터페이스 정의 언어(IDL)를 사용하여 확장 가능하고 유지 관리 가능한 시스템을 구축하는 이점을 강조합니다. 이기종 시스템 간의 효율적인 통신을 가능하게 합니다.
* **Raft Consensus Algorithm:** 
    - Paxos 알고리즘에 비해 이해하기 쉬운 합의 알고리즘을 제시하여 내결함성 분산 시스템 구축 과정을 단순화했습니다. 분산 합의 문제에 대한 더 실용적인 해결책을 제시하며 널리 채택되고 있습니다.
* **"Time, Clocks, and the Ordering of Events in a Distributed System" (1978):** 
    - 논리적 시계의 개념을 도입하고 분산 시스템에서 이벤트의 부분적인 순서를 설정하여 물리적 시계에 의존하지 않고 이벤트 동기화 및 일관성 문제를 해결하기 위한 이론적 프레임워크를 제공합니다. 분산 시스템의 근본적인 이해에 중요한 기여를 했습니다.

### **97.4 컴퓨터 과학의 새로운 지평을 연 획기적인 개념 및 아키텍처**

* **"Attention Is All You Need" (2017):** 
    - 자연어 처리 분야에 혁명적인 변화를 가져온 트랜스포머 아키텍처를 소개합니다. self-attention 메커니즘의 강력한 효과를 입증하며, 번역, 요약, 질의응답 등 다양한 자연어 처리 task의 성능을 획기적으로 향상시킨 GPT와 같은 거대 언어 모델의 탄생에 결정적인 역할을 했습니다.
* **Bitcoin Whitepaper:** 
    - 암호화폐와 블록체인 기술의 기반을 마련하고, 탈중앙화된 P2P 전자 화폐 시스템의 개념을 제시하여 디지털 통화 및 분산형 애플리케이션의 새로운 시대를 열었습니다. 금융 시스템과 기술에 대한 근본적인 질문을 던지고 새로운 가능성을 제시했습니다.
* **"Go To Statement Considered Harmful" (1968):** 
    - 당시의 프로그래밍 관행에 도전하고 프로그래밍 언어 설계에 대한 중요한 논쟁을 촉발했습니다. `goto` 문의 무분별한 사용의 위험성을 지적하고 구조적 프로그래밍 패러다임의 중요성을 강조하여 현대 프로그래밍 언어 설계에 큰 영향을 미쳤습니다.

### **97.5 특정 애플리케이션 및 최적화를 위한 심층 연구**

* **Memcached:** 
    - 대규모 캐싱 시스템 구축의 복잡성을 보여주고 애플리케이션 성능 향상을 위한 분산 캐싱 시스템 설계 시 고려해야 할 문제점과 해결책을 상세히 설명합니다. 고성능 웹 애플리케이션 구축의 핵심 기술로 자리 잡았습니다.
* **MyRocks:** 
    - LSM-트리 기반의 새로운 데이터베이스 스토리지 엔진을 제시하고, 대규모 데이터베이스의 스토리지 및 검색 작업을 효율적으로 최적화하는 방법을 보여줍니다. 특히 쓰기 작업이 많은 환경에서 성능 향상을 가져왔습니다.
* **Twitter's "Who to Follow":** 
    - 효과적인 추천 시스템 구축에 대한 귀중한 통찰력을 제공합니다. 사용자 행동 분석, 소셜 네트워크 구조 분석 등 다양한 기법을 활용하여 개인화된 추천을 제공하는 방법론을 제시합니다.
* **Vector Databases (2021):** 
    - 최신 기술 동향에 대한 심층적인 시각을 제공하며, 고차원 벡터 데이터를 효율적으로 저장하고 검색하는 방법론을 제시합니다. 인공지능, 머신러닝 분야에서 빠르게 중요성이 증가하고 있는 기술입니다.

이러한 논문들은 컴퓨터 과학이라는 광대한 학문 분야를 형성해 온 놀라운 연구 성과의 일부에 불과합니다. 이 논문들을 통해 우리는 오늘날 우리가 직면한 도전 과제, 이를 해결하기 위한 혁신적인 아이디어, 그리고 미래를 향해 나아가는 데 필요한 깊이 있는 이해를 얻을 수 있습니다.

## 98. Linux 시스템 성능 문제 진단 및 해결
- 출처: [Linux Performance Tools!](https://www.youtube.com/watch?v=iJ_eIsA5E1U)

### **98.1 문제 확인**

* **가짜 문제 방지:** 성능 문제 보고를 받았을 때, 섣불리 문제 해결에 착수하기 전에 다음의 질문들을 통해 사용자의 인식이 실제 시스템 문제인지, 아니면 단순히 기대치와 다른 상황인지 명확히 구분하는 것이 중요.
    * **문제의 원인에 대한 이해도 확인:** 
        - "문제의 원인이 무엇이라고 생각하는가?"라는 질문을 통해 사용자가 인지하는 문제의 근본적인 원인을 파악하고, 문제 해결의 방향성을 설정하는 데 도움을 얻을 수 있습니다.
    * **과거 시스템 상태 비교:** 
        - "시스템이 이전에는 더 잘 작동했는가?"라는 질문은 현재 성능 저하가 일시적인 현상인지, 아니면 지속적인 문제인지 판단하는 데 중요한 기준이 됩니다. 과거의 정상 작동 시점과 비교하여 문제 발생 시점을 추정할 수 있습니다.
    * **최근 변경 사항의 영향 분석:** 
        - "최근 변경 사항 중 성능에 영향을 미친 것이 있는가?"라는 질문을 통해 소프트웨어 업데이트, 설정 변경, 하드웨어 추가 등 최근 시스템 변경 사항이 성능 저하의 잠재적인 원인인지 확인해야 합니다.
    * **주관적인 표현의 객관화:** 
        - 단순히 "느리다"와 같은 주관적인 표현 대신, "느리다"는 것을 구체적으로 어떻게 측정하고 인지하는지 질문하여 문제의 심각성을 객관적으로 파악해야 합니다. 예를 들어, 특정 작업 완료에 걸리는 시간, 응답 속도 등을 수치화할 수 있습니다.
    * **문제 발생 범위 파악:** 
        - "문제가 여러 사용자에게 영향을 미치는가, 아니면 특정 사용자에게만 영향을 미치는가?"라는 질문을 통해 문제의 범위가 시스템 전체인지, 특정 환경이나 사용자에게 국한된 것인지 파악하여 문제 해결 전략을 달리해야 합니다.
* **사례:** 
    - 데이터베이스 쿼리 실행 시간이 항상 5초가 걸렸음에도 불구하고 사용자가 최근에 "느려졌다"고 보고하는 경우가 있을 수 있습니다. 이는 시스템의 실제 문제가 아니라 사용자의 잘못된 기대 또는 인지에서 비롯된 것일 수 있습니다.
* **중요성:** 
    - 가짜 문제에 불필요한 시간을 낭비하지 않고, 실제적인 시스템 성능 문제 해결에 집중함으로써 효율적인 문제 해결 프로세스를 구축할 수 있습니다.

### **98.2 문제 정의**

* **구체적인 지표 활용:** "느리다", "답답하다"와 같은 모호한 표현 대신, 다음과 같이 객관적으로 측정 가능한 구체적인 성능 지표를 사용하여 문제를 명확하게 정의해야 합니다.
    * **웹 페이지 로딩 시간:** 
        - 특정 웹 페이지를 요청했을 때 브라우저에 완전히 로딩될 때까지 걸리는 시간 (예: 평균 로딩 시간 10초 초과).
    * **DB 쿼리 타임아웃:** 
        - 데이터베이스에 특정 쿼리를 요청했을 때 설정된 시간 내에 응답을 받지 못하고 오류가 발생하는 상황.
* **문제 발생 시점 및 위치 정확히 파악:** 
    - 문제가 언제부터 발생했는지, 특정 시간대에만 발생하는지, 특정 기능이나 작업 수행 시에만 발생하는지 등 구체적인 발생 시점과 위치를 파악하는 것이 문제의 원인을 좁히는 데 중요합니다.
* **범위 및 영향 분석:**
    * **영향받는 서버 범위:** 
        - 성능 저하 문제가 특정 서버에서만 발생하는지, 아니면 여러 서버에 걸쳐 나타나는지 파악하여 문제의 масштабы (규모)를 결정합니다.
    * **영향받는 사용자 수:** 
        - 성능 문제로 인해 불편을 겪는 사용자 수를 파악하여 문제의 긴급성을 판단하고, 비즈니스에 미치는 영향을 가늠합니다.
    * **비즈니스적 영향:** 
        - 성능 저하가 실제 비즈니스 운영에 어떤 부정적인 영향을 미치는지 (예: 거래 실패율 증가, 고객 불만 증가 등) 파악하여 문제 해결의 우선순위를 결정합니다.
* **문제 원인 조사:** 성능 저하의 근본적인 원인을 파악하기 위해 다음과 같은 측면에서 조사를 진행합니다.
    * **정상적인 사용자 활동으로 인한 부하:** 
        - 평소보다 많은 사용자가 동시에 접속하거나, 평소보다 많은 요청을 처리하면서 시스템 부하가 증가했을 가능성을 확인합니다.
    * **특정 애플리케이션 문제:** 
        - 특정 애플리케이션의 오류, 비효율적인 로직, 과도한 자원 사용 등이 성능 저하의 원인일 수 있다.
    * **비정상적인 프로세스 (runaway process):** 
        - 의도치 않게 과도한 CPU나 메모리 자원을 점유하는 프로세스가 있는지 확인합니다.
* **정량화:** 시스템 성능 변화 추이를 객관적으로 관찰하기 위해 다음과 같은 지표들을 시간 경과에 따라 기록하고 분석합니다.
    * **초당 요청 수 (Requests Per Second, RPS):** 
        - 웹 서버나 API 서버의 처리량을 나타내는 지표입니다.
    * **데이터 전송률 (Throughput):** 
        - 네트워크 인터페이스를 통해 전송되는 데이터의 양을 나타내는 지표입니다. 이러한 지표 변화를 통해 문제 발생 시점과 연관된 시스템 부하 변화를 파악할 수 있습니다.

### **98.3 기본 도구 활용**

* **uptime:** 시스템이 얼마나 오랫동안 가동되었는지, 현재 시간, 그리고 시스템 부하 평균(load average)을 간략하게 보여줍니다.
    * **부하 평균 (load average):** 
        - 1분, 5분, 15분 동안 시스템에서 실행 중이거나 CPU 자원을 기다리는 프로세스의 평균 개수를 나타냅니다.
    * **자원 경쟁 가능성 시사:** 
        - 일반적으로 부하 평균이 CPU 코어 수보다 높으면 시스템이 처리해야 할 작업량에 비해 CPU 자원이 부족하여 성능 병목이 발생할 가능성을 의미합니다.
    * **다양한 원인 존재:** 
        - 높은 부하 평균은 CPU뿐만 아니라 디스크 I/O, 과도한 단명 프로세스 생성 등 다양한 요인으로 인해 발생할 수 있으므로, 단순 지표로 활용하고 추가적인 조사가 필요합니다.
    * **단순 지표, 추가 조사 필요:** 
        - `uptime` 명령어의 결과만으로는 성능 문제의 정확한 원인을 파악하기 어렵습니다. 다른 도구와 함께 사용하여 종합적으로 분석해야 합니다.
* **top:** 시스템에서 실행 중인 프로세스들의 실시간 정보를 보여주며, CPU 사용률, 메모리 사용률, 실행 시간 등 다양한 지표를 제공합니다.
    * **CPU 사용률:** 
        - 각 프로세스별, 그리고 전체 시스템의 사용자 영역(user) CPU 사용률과 시스템 영역(system) CPU 사용률을 보여줍니다. 높은 시스템 CPU 사용률은 커널 수준의 문제 (예: I/O 병목, 인터럽트 처리 과부하)를 의심해 볼 수 있습니다.
    * **메모리 사용률:** 
        - 전체 메모리 사용량, 사용 가능한 메모리, 버퍼 및 캐시 사용량 등을 보여줍니다. 메모리 부족은 스와핑(swapping)을 유발하여 시스템 성능을 크게 저하시킬 수 있습니다.
    * **비정상적으로 높은 CPU/메모리 사용 프로세스 집중 감시:**
        - `top` 명령어를 통해 CPU나 메모리를 과도하게 사용하는 프로세스를 실시간으로 확인하고, 해당 프로세스가 성능 저하의 원인인지 조사할 수 있습니다.
    * **스냅샷 정보, 장시간 관찰 또는 다른 도구와 병행 필요:**
        - `top` 명령어는 특정 시점의 스냅샷 정보를 제공하므로, 시간 경과에 따른 변화를 파악하기 위해서는 장시간 관찰하거나 `sar`와 같은 다른 도구와 함께 사용하는 것이 효과적입니다.
* **vmstat (Virtual Memory Statistics):** 시스템의 가상 메모리, CPU 활동, 디스크 I/O, 트랩 및 인터럽트 등 다양한 시스템 활동에 대한 실시간 통계를 보여줍니다.
    * **CPU, IO, SWAP 활동, IO 대기 시간 등:** 
        - `vmstat` 출력을 통해 CPU 사용률, 디스크 읽기/쓰기 속도, 스왑 공간 사용량, I/O를 기다리는 프로세스 비율 등을 확인할 수 있습니다. 높은 I/O 대기 시간은 디스크 병목을 의심할 수 있습니다.
* **iostat (Input/Output Statistics):** 시스템의 디스크 I/O 활동에 대한 상세한 통계를 제공합니다. 각 디스크별 읽기/쓰기 속도, 초당 전송량 (TPS), 평균 대기 시간 등을 분석할 수 있습니다.
    * **초당 트랜잭션 수 (TPS), IO 대기 시간 (%):** 
        - 특정 디스크의 초당 읽기 및 쓰기 작업 수와 I/O 요청을 처리하기 위해 대기하는 시간 비율을 통해 디스크 성능을 평가할 수 있습니다.
    * **디스크별 IO 성능 분석 (특정 디스크 병목 확인):** 
        - 시스템에 여러 개의 디스크가 있는 경우, `iostat` 출력을 통해 특정 디스크에서 I/O 병목이 발생하는지 여부를 확인할 수 있습니다.
* **netstat (Network Statistics):** 네트워크 연결 상태, 라우팅 테이블, 인터페이스 통계 등을 보여줍니다. 네트워크 관련 성능 문제를 진단하는 데 유용합니다.
    * **활성 연결 목록:** 
        - 현재 시스템에서 활성화된 네트워크 연결 목록과 해당 연결의 상태 (ESTABLISHED, LISTEN 등), 로컬 및 원격 주소, 포트 번호를 확인할 수 있습니다. 이를 통해 어떤 서비스가 어떤 호스트와 통신하고 있는지 파악할 수 있습니다.
    * **특정 포트의 연결 수:** 
        - 특정 서비스 (예: 웹 서버의 80번 포트)에 대한 활성 연결 수를 파악하여 서비스 부하를 측정할 수 있습니다.
    * **예시:**
        * `netstat -an`: 모든 활성 네트워크 연결과 수신 대기 중인 소켓 목록을 숫자 주소와 포트 번호로 표시합니다.
        * `netstat -lt`: 수신 대기 중인 TCP 및 UDP 포트 목록을 표시합니다. 어떤 서비스가 어떤 포트에서 Listen하고 있는지 확인할 수 있습니다.
        * `netstat -an | grep :80 | wc -l`: 80번 포트를 사용하는 활성 연결 수를 세어 웹 서버에 얼마나 많은 연결이 동시에 이루어지고 있는지 확인할 수 있습니다.
* **sar (System Activity Reporter):** CPU 사용률, 메모리 사용률, 디스크 I/O, 네트워크 통계 등 시스템의 다양한 활동 정보를 주기적으로 기록하고 보고하는 도구입니다.
    * **장점: 과거 데이터 저장:** 
        - `sar`는 시스템 성능 데이터를 주기적으로 파일에 저장하므로, 문제가 발생한 과거 시점의 시스템 상태를 추적하고 성능 변화 패턴을 분석하는 데 매우 유용합니다.
    * **주기적인 데이터 수집 설정:** 
        - 대부분의 Linux 배포판에서는 `sar`가 기본적으로 설치되어 있으며, 일정 간격으로 시스템 성능 데이터를 수집하도록 설정되어 있습니다.

### **98.4 추가 정보**

* Linux 환경에서는 위에 언급된 기본적인 도구 외에도 `perf`, `tcpdump`, `strace` 등 시스템의 모든 레벨과 다양한 하위 시스템 (CPU, 메모리, 디스크, 네트워크, 애플리케이션 등)의 성능 분석을 위한 매우 다양한 도구들이 존재합니다.
* **반복적인 프로세스:** 성능 문제 해결은 하나의 도구만으로는 어렵고, 여러 도구를 함께 사용하고 분석 결과를 종합하여 심층적인 원인 분석을 수행하는 반복적인 프로세스입니다.
* **접근 방식:** 일반적으로 시스템 전체적인 상황을 파악하기 위해 `uptime`이나 `top`과 같은 도구로 넓게 시작하여, 발견된 이상 징후를 기반으로 `vmstat`, `iostat`, `netstat` 등의 전문적인 도구를 사용하여 문제의 범위를 좁혀나가는 체계적인 접근 방식이 효과적입니다.

## 99. 인터넷 작동 방식
- 출처: [How the Internet Works in 9 Minutes](https://www.youtube.com/watch?v=sMHzfigUxz4)

### **99.1 인터넷의 장대한 여정**

* **1960년대 후반: 혁신의 씨앗, 아파넷(ARPANET) 프로젝트 시작:** 
    - 냉전 시대, 미국 국방부는 핵 공격에도 살아남을 수 있는 통신망의 필요성을 느꼈습니다. 이에 따라 여러 연구 기관의 컴퓨터를 연결하는 실험적인 네트워크, 아파넷이 탄생했습니다. 이는 오늘날 인터넷의 기원이 되는 중요한 발걸음이었습니다.
* **1970년대: 소통의 언어, TCP/IP 개발 (현대 인터넷의 뼈대 구축):** 
    - 서로 다른 네트워크들이 효율적으로 통신하기 위한 공통의 언어가 필요했습니다. 이때 등장한 것이 전송 제어 프로토콜(TCP)과 인터넷 프로토콜(IP)의 조합, 즉 TCP/IP입니다. TCP는 데이터 전송의 신뢰성을 보장하고, IP는 네트워크 상에서 주소를 지정하고 경로를 설정하는 핵심 역할을 수행합니다.
* **1989년: 정보의 바다, 월드 와이드 웹(WWW) 탄생 (정보 접근과 공유의 혁명):** 
    - 팀 버너스-리가 제안한 월드 와이드 웹은 하이퍼텍스트와 URL(Uniform Resource Locator), HTTP(Hypertext Transfer Protocol) 등의 기술을 기반으로 정보를 쉽고 직관적으로 공유할 수 있는 환경을 제공했습니다. 이는 인터넷을 단순한 통신망에서 전 세계적인 정보 공유 플랫폼으로 탈바꿈시키는 결정적인 사건이었습니다.
* **2000년대: 연결의 확장, 소셜 미디어 및 모바일 인터넷 성장 (사람과 사람, 이동 중에도 연결):** 
    - 고속 인터넷 보급과 스마트폰의 등장은 소셜 미디어의 폭발적인 성장을 이끌었고, 사람들은 시간과 장소에 구애받지 않고 서로 연결될 수 있게 되었습니다. 이는 인터넷의 사회적 영향력을 크게 확장시켰습니다.
* **현재: 융합과 확장, 사물 인터넷(IoT) 및 5G 네트워크 확장 (모든 것이 연결되는 초연결 시대):** 
    - 이제 인터넷은 단순히 사람과 사람을 연결하는 것을 넘어, 다양한 사물과 서비스를 연결하는 사물 인터넷 시대로 진입하고 있습니다. 초고속, 초저지연의 5G 네트워크는 이러한 변화를 가속화하며, 자율 주행, 스마트 시티 등 이전에는 상상하기 어려웠던 새로운 가능성을 열고 있습니다.

### **99.2 인터넷을 구성하는 핵심 요소들**

* **네트워크 에지(Network Edge): 인터넷 세상의 최전선:**
    * **엔드 시스템 (호스트): 인터넷에 접속하는 모든 장치:** 
        - 우리가 일상적으로 사용하는 컴퓨터, 스마트폰은 물론, 웹 서버, 심지어 냉장고와 같은 IoT 기기까지 인터넷에 연결되는 모든 장치를 엔드 시스템 또는 호스트라고 부릅니다. 이들은 정보를 주고받는 최종 지점입니다.
    * **클라이언트: 정보를 요청하는 사용자:** 
        - 일반적으로 우리가 사용하는 개인용 장치(PC, 스마트폰, 태블릿 등)는 웹 페이지 보기, 이메일 보내기 등 특정 서비스를 요청하는 클라이언트 역할을 합니다.
    * **서버: 정보를 제공하는 강력한 조력자:** 
        - 웹 페이지, 동영상 파일, 이메일 데이터베이스 등 다양한 정보를 저장하고 클라이언트의 요청에 따라 이를 제공하는 고성능 컴퓨터입니다. 서버는 24시간 작동하며, 많은 사용자의 요청을 동시에 처리할 수 있도록 설계되었습니다.
    * **데이터 센터: 인터넷 서비스의 심장부:** 
        - 수많은 서버를 효율적으로 관리하고 운영하기 위해 특별히 설계된 시설입니다. 안정적인 전력 공급, 냉각 시스템, 보안 시스템 등을 갖추고 있으며, 우리가 사용하는 대부분의 인터넷 서비스가 이 곳에서 제공됩니다.
* **액세스 네트워크(Access Network): 인터넷으로 향하는 첫 번째 관문:**
    * **엔드 시스템과 첫 번째 라우터의 물리적 연결:** 
        - 우리가 사용하는 장치를 인터넷 서비스 제공업체의 네트워크로 연결해주는 통신망입니다. 이 연결 방식에 따라 인터넷 속도와 안정성이 달라집니다.
    * **홈 액세스 네트워크: 가정에서의 인터넷 연결:** 
        - DSL(Digital Subscriber Line), 케이블 인터넷, 광섬유(FTTH: Fiber To The Home) 등 다양한 기술을 이용하여 가정 내 장치들을 인터넷 서비스 제공업체의 네트워크로 연결합니다. 최근에는 기가비트 속도를 제공하는 광섬유 연결이 점차 확대되고 있습니다.
    * **기관 액세스 네트워크: 기업 및 단체의 맞춤형 연결:** 
        - 기업이나 학교와 같은 기관에서는 더 많은 사용자와 높은 대역폭 요구를 충족하기 위해 고속 광섬유, 이더넷 LAN(Local Area Network), 무선 LAN(Wi-Fi) 등 보다 복잡하고 효율적인 네트워크 구조를 사용합니다.
    * **모바일 액세스 네트워크: 언제 어디서든 자유롭게:** 
        - 스마트폰과 같은 이동 장치를 통해 인터넷에 접속하는 방식입니다. 4G LTE, 5G 등 셀룰러 기술을 이용하여 기지국과 무선으로 연결되며, 이동 중에도 끊김 없는 인터넷 사용을 가능하게 합니다.
* **네트워크 코어(Network Core): 인터넷의 중추 신경망:**
    * **패킷 라우터와 링크의 복잡한 연결망:** 
        - 전 세계의 수많은 네트워크를 서로 연결하는 핵심적인 부분입니다. 고성능 라우터들이 복잡하게 연결되어 있으며, 데이터를 빠르고 정확하게 목적지로 전달하는 역할을 수행합니다.
    * **라우터: 길을 안내하는 똑똑한 택배 기사:** 
        - 네트워크 코어에 위치하며, 수신된 데이터 패킷의 목적지 주소를 분석하여 가장 적절한 다음 경로로 패킷을 전달하는 특수 장치입니다. 이 과정을 패킷 포워딩이라고 합니다.

### **99.3 패킷 스위칭: 효율적인 데이터 전송 전략**

* **데이터를 작은 조각으로 나누어 보내는 방식:** 
    - 큰 덩어리의 데이터를 그대로 전송하는 대신, 작은 크기의 패킷으로 분할하여 네트워크 혼잡을 줄이고 전송 효율성을 높입니다.
* **각 패킷에 담긴 중요한 정보:** 
    - 각 패킷에는 출발지 IP 주소, 목적지 IP 주소, 순서 정보 등 데이터가 정확하게 목적지에 도착하여 재조립될 수 있도록 필요한 정보들이 포함되어 있습니다.
* **자유로운 이동, 다양한 경로:** 
    - 각 패킷은 네트워크 상황에 따라 독립적으로 최적의 경로를 선택하여 이동할 수 있습니다. 따라서 특정 경로에 문제가 발생해도 다른 경로를 통해 데이터를 전송할 수 있어 안정성이 높습니다.
* **도착지에서의 완벽한 재구성:** 
    - 목적지에 도착한 패킷들은 순서 정보에 따라 다시 원래의 완전한 메시지로 재조립됩니다. 이 과정을 통해 우리는 깨짐 없이 온전한 데이터를 받아볼 수 있습니다.
* **패킷 스위칭의 빛나는 장점:**
    * **동시 다발적인 통신 처리 능력 극대화 (대역폭의 스마트한 활용):** 
        - 여러 사용자가 동시에 데이터를 송수신하더라도 네트워크 자원을 효율적으로 분배하여 병목 현상을 줄이고 전체적인 처리량을 향상시킵니다.
    * **예상치 못한 문제 발생에도 끄떡없는 데이터 전송 (강력한 복원력):** 
        - 네트워크의 특정 부분에 장애가 발생하거나 혼잡이 심해지더라도, 패킷들은 우회 경로를 통해 데이터를 전송할 수 있어 통신의 안정성을 높입니다.
* **포워딩(Forwarding): 라우터의 신속한 판단:** 
    - 라우터가 입력된 링크를 통해 들어온 패킷을 자신의 포워딩 테이블을 참조하여 적절한 출력 링크로 빠르게 전달하는 로컬 작업입니다. 이는 네트워크 코어에서의 데이터 흐름을 결정하는 핵심적인 과정.
* **라우팅(Routing): 최적의 길을 찾는 지능적인 항해:** 
    - 출발지에서 목적지까지 패킷이 이동해야 할 전체 경로를 결정하는 네트워크 전반의 프로세스입니다. 인터넷 라우팅 알고리즘은 네트워크의 구조와 현재 상태를 분석하여 가장 효율적인 경로를 계산합니다.
* **BGP (Border Gateway Protocol): 자율 시스템 간의 국경 없는 소통:** 
    - 서로 다른 관리 주체 하에 있는 독립적인 네트워크(자율 시스템)들이 서로의 라우팅 정보를 교환하여 전 세계적인 인터넷 연결을 가능하게 하는 핵심 프로토콜입니다. 이는 인터넷이 하나의 거대한 연결망으로 작동하는 데 필수적인 요소입니다.

### **99.4 프로토콜: 약속된 소통의 규칙**

* **네트워크 장치 간의 원활한 대화를 위한 공통 언어:** 
    - 인터넷 상의 모든 통신은 미리 정의된 규칙, 즉 프로토콜에 따라 이루어집니다. 이는 메시지의 형식, 주고받는 순서, 오류 발생 시의 처리 방법 등을 명확하게 규정합니다.
* **다양한 역할을 수행하는 프로토콜의 향연:** 
    - TCP, UDP, IP, HTTP 외에도 이메일 전송을 위한 SMTP, 파일 전송을 위한 FTP 등 수많은 프로토콜들이 각자의 역할을 수행하며 인터넷 통신을 지원합니다.
* **TCP: 신뢰를 바탕으로 한 꼼꼼한 전달:** 
    - 데이터를 패킷으로 분할하고, 각 패킷의 수신 여부를 확인하며, 손실된 패킷은 재전송하는 방식으로 신뢰성 있는 데이터 전송을 보장합니다. 웹 서핑, 파일 다운로드 등 정확성이 중요한 통신에 주로 사용됩니다.
* **IP: 주소와 경로를 책임지는 길잡이:** 
    - 각 장치에 고유한 IP 주소를 부여하고, 이 주소를 기반으로 패킷이 목적지까지 정확하게 라우팅될 수 있도록 합니다. 인터넷 통신의 기본적인 주소 체계입니다.
* **HTTP: 웹 세상의 소통 방식:** 
    - 웹 브라우저와 웹 서버 간에 웹 페이지와 같은 정보를 요청하고 응답하는 방식을 정의하는 프로토콜입니다. 우리가 웹 서핑을 할 때 가장 많이 사용되는 프로토콜 중 하나입니다.

### **99.5 TCP/IP 스택 (인터넷 프로토콜 스택): 효율적인 통신을 위한 계층 구조**

* **인터넷 통신 프로토콜의 체계적인 표준화 모델:** 
    - 복잡한 인터넷 통신 과정을 기능별로 나누어 계층화한 개념적인 프레임워크입니다. 각 계층은 특정 기능을 수행하며, 서로 협력하여 데이터를 효율적으로 전송합니다.
* **4개의 논리적인 계층:**
    * **응용 계층(Application Layer): 사용자와 직접 상호작용하는 창구:** 
        - HTTP (웹), SMTP (이메일), FTP (파일 전송), DNS (도메인 이름 해석) 등 최종 사용자가 사용하는 다양한 네트워크 응용 프로그램과 관련된 프로토콜들이 위치합니다.
    * **전송 계층(Transport Layer): 데이터 전송의 신뢰성과 효율성을 책임:** 
        - TCP (신뢰적 연결형 통신), UDP (빠른 비연결형 통신) 프로토콜이 작동하며, 응용 계층에서 받은 데이터를 네트워크 계층으로 전달하거나, 네트워크 계층에서 받은 데이터를 응용 계층으로 전달하는 역할을 합니다.
    * **네트워크 계층(Network Layer): 패킷의 주소 지정과 경로 설정을 담당:** 
        - IPv4, IPv6 프로토콜이 작동하며, 논리적인 주소(IP 주소)를 기반으로 패킷을 목적지까지 라우팅하는 역할을 수행합니다.
    * **링크 계층(Link Layer): 물리적인 연결을 관리하는 최하위 계층:** 
        - 이더넷, Wi-Fi 등 물리적인 네트워크 매체를 통해 데이터를 전송하는 데 필요한 프로토콜과 하드웨어 인터페이스(네트워크 인터페이스 카드, 장치 드라이버)를 관리합니다.

### **99.6 데이터 흐름: 캡슐화와 디캡슐화의 마법**

* **데이터의 포장 과정, 캡슐화:** 
    - 송신 측에서 응용 계층에서 생성된 데이터는 하위 계층으로 내려갈수록 각 계층의 헤더 정보가 추가되어 마치 택배 상자가 포장되는 것처럼 캡슐화됩니다. 이 헤더에는 각 계층에서 필요한 제어 정보(주소 정보, 순서 정보 등)가 담깁니다.
* **포장을 풀고 내용을 확인하는 과정, 디캡슐화:** 
    - 수신 측에서는 전송된 데이터를 받아 상위 계층으로 올라갈수록 각 계층의 헤더 정보가 제거되는 디캡슐화 과정을 거칩니다. 최종적으로 응용 계층에서 원래의 데이터를 얻을 수 있습니다.
* **계층화된 구조의 놀라운 힘:** 
    - 이러한 계층화된 접근 방식은 각 계층의 역할을 명확하게 분리하여 복잡한 인터넷 시스템을 보다 쉽게 이해하고 관리할 수 있도록 합니다. 또한, 특정 계층의 기술이 변경되더라도 다른 계층에 미치는 영향을 최소화하여 인터넷의 유연성과 확장성을 높이는 데 기여합니다.

**요약하자면,** 인터넷은 전 세계의 수많은 네트워크가 복잡하게 연결된 거대한 통신 시스템입니다. 데이터는 작은 패킷으로 나뉘어 라우터라는 길잡이 장치를 통해 최적의 경로를 찾아 목적지까지 전달됩니다. 이 모든 과정은 TCP/IP라는 기본적인 통신 규약과 다양한 프로토콜들에 의해 체계적으로 관리되며, 계층화된 구조 덕분에 우리는 안정적이고 효율적으로 전 세계의 정보와 연결될 수 있습니다.

## 100. HTTP 프로토콜 진화
- 출처: [HTTP 1 Vs HTTP 2 Vs HTTP 3!](https://www.youtube.com/watch?v=UMwQjFzTQXw)

### **100.1 HTTP 개요**

*   **정의:**  
    *   HTTP는 클라이언트(브라우저)와 서버 간 데이터 교환을 위한 애플리케이션 레벨 프로토콜입니다.  
    *   주요 특징은 상태 비저장(Stateless)으로, 각 요청은 독립적으로 처리됩니다. 이는 확장성을 높이는 장점이 있지만, 세션 관리나 사용자 인증 등의 상태 정보를 유지하려면 쿠키나 세션 같은 추가 메커니즘이 필요합니다.

*   **초기:**  
    *   초기 HTTP는 단순히 하이퍼텍스트 문서를 전송하기 위한 목적으로 설계되었습니다.  
    *   하이퍼텍스트 문서는 HTML 형식으로 작성되었으며, 링크를 통해 다른 문서로 이동할 수 있었습니다.  

*   **현재:**  
    *   현대 웹에서는 HTTP가 다양한 유형의 데이터 전송을 지원합니다. 이미지, 비디오, 오디오, API 호출, 파일 다운로드 등 거의 모든 웹 서비스가 HTTP를 기반으로 동작합니다.  
    *   또한 HTTPS(TLS/SSL 암호화 적용)를 통해 보안성을 강화하고 있으며, RESTful API, GraphQL 등 다양한 통신 방식도 HTTP 프로토콜을 기반으로 구현됩니다.

### **100.2 HTTP 버전별 특징**

*   **HTTP 0.9 (1991년 이전):**  
    *   **단순 GET 요청만 지원:**  
        *   최초 HTTP는 매우 단순한 프로토콜로, 클라이언트가 서버에 GET 요청을 보내고, 서버는 응답으로 HTML 문서를 반환하는 방식으로 동작했습니다.  
        *   요청에는 헤더가 포함되지 않았으며, 응답도 단순히 HTML 본문만 전송되었습니다.  
    *   **헤더 없음:**  
        *   메타데이터(예: 콘텐츠 타입, 길이 등)를 전달할 수 없는 제약이 있었습니다.  
    *   **HTML 파일만 전송:**  
        *   이 시점에서 HTTP는 순수히 하이퍼텍스트 문서 전송을 목적으로 설계되었습니다.  

*   **HTTP 1.0 (1996년):**  
    *   **헤더, 상태 코드 추가:**  
        *   요청과 응답에 메타데이터를 포함할 수 있는 헤더가 도입되었습니다. 예를 들어, `Content-Type`, `Content-Length` 등의 헤더가 추가되어 더 다양한 데이터 형식을 처리할 수 있게 되었습니다.  
        *   상태 코드(예: 200 OK, 404 Not Found)를 통해 요청 결과를 명확히 표현할 수 있게 됨.  
    *   **POST, HEAD 등 새로운 메서드 추가:**  
        *   POST 메서드는 데이터를 서버로 전송하는 데 사용되며, 폼 데이터 제출 등에 활용됩니다.  
        *   HEAD 메서드는 본문 없이 헤더만 요청하여 리소스의 메타데이터를 확인하는 데 사용됩니다.  
    *   **요청마다 새로운 연결 생성 (비효율적):**  
        *   각 요청마다 TCP 연결을 새로 생성하고 해제해야 했습니다. 이는 네트워크 자원을 낭비하고 성능을 저하시키는 원인이 되었습니다.  
        *   TCP 3-way handshake는 연결 설정 시간을 증가시키며, HTTPS의 경우 추가적인 TLS 핸드셰이크로 인해 더 많은 시간이 소요됩니다.  

*   **HTTP 1.1 (1997년):**  
    *   **주요 특징:**  
        *   **지속 연결 (Persistent Connections):**  
            *   Keep-Alive 메커니즘을 통해 하나의 TCP 연결을 여러 요청/응답에 재사용할 수 있게 되었습니다. 이는 연결 설정 및 해제의 오버헤드를 줄이고 성능을 향상시켰습니다.  
        *   **파이프라이닝 (Pipelining):**  
            *   여러 요청을 동시에 전송할 수 있게 되었지만, 응답은 여전히 순차적으로 처리되어야 했습니다. 이는 HOL Blocking 문제를 야기할 수 있습니다.  
        *   **청크 전송 인코딩 (Chunk Transfer Encoding):**  
            *   큰 파일이나 스트리밍 데이터를 작은 조각으로 나누어 점진적으로 전송할 수 있게 되었습니다. 이를 통해 초기 페이지 로딩 속도가 향상되었습니다.  
        *   **캐싱 (Caching):**  
            *   `Cache-Control`, `ETag`, `Expires` 등의 헤더를 통해 캐시 정책을 명확히 설정할 수 있게 되었습니다.  
            *   조건부 요청(`If-Modified-Since`, `If-None-Match`)을 통해 불필요한 데이터 전송을 줄일 수 있습니다.  
    *   **문제점:**  
        *   **HOL (Head-of-Line) Blocking:**  
            *   파이프라인에서 첫 번째 요청이 지연되면 후속 요청 전체가 차단되는 문제가 발생했습니다.  
    *   **제한 극복 방법:**  
        *   **도메인 샤딩 (Domain Sharding):**  
            *   브라우저는 한 도메인당 병렬 연결 수를 제한합니다. 이를 우회하기 위해 정적 자원을 여러 서브도메인에서 제공하는 방법이 사용되었습니다.  
        *   **파일 요청 감소:**  
            *   이미지 스프라이트(Sprites)는 여러 아이콘을 하나의 이미지로 결합하여 요청 수를 줄이는 기법입니다.  
            *   CSS/JavaScript 파일을 병합하거나 미리 처리하여 네트워크 요청을 최소화하는 방법도 사용되었습니다.  

*   **HTTP/2 (2015년):**  
    *   **주요 특징:**  
        *   **이진 프레이밍 레이어 (Binary Framing Layer):**  
            *   요청과 응답을 이진 형식으로 분할하여 효율적으로 전송합니다. 텍스트 기반 프로토콜보다 오류 발생 가능성이 적고, 처리 속도가 빠릅니다.  
        *   **멀티플렉싱 (Multiplexing):**  
            *   하나의 TCP 연결에서 여러 요청과 응답을 독립적으로 처리할 수 있습니다. 이는 HOL Blocking 문제를 해결하며, 병렬 처리를 가능하게 합니다.  
        *   **스트림 우선순위화 (Stream Prioritization):**  
            *   중요한 자원(예: HTML, CSS)을 먼저 전송하도록 설정할 수 있어 사용자 경험을 개선.  
        *   **서버 푸시 (Server Push):**  
            *   클라이언트 요청 없이 서버가 필요한 자원을 미리 전송하여 로딩 시간을 단축합니다.  
        *   **헤더 압축 (Header Compression, HPACK):**  
            *   동일한 헤더 정보를 반복적으로 전송하지 않고 압축하여 전송량을 줄입니다.  
    *   **문제점:**  
        *   **TCP 기반의 특성상 패킷 손실 및 HOL Blocking으로 인한 성능 저하:**  
            *   TCP는 신뢰성 있는 전송을 위해 패킷 손실 시 재전송을 수행합니다. 이는 고지연 또는 불안정한 네트워크 환경에서 성능 저하를 초래할 수 있습니다.  

*   **HTTP/3 (2022년):**  
    *   **기반 프로토콜:**  
        *   QUIC(Quick UDP Internet Connections)는 UDP 기반으로 설계, TCP의 단점을 보완.  
    *   **주요 특징:**  
        *   **낮은 지연 시간:**  
            *   연결 설정 시간이 단축되어 특히 모바일 환경에서 빠른 초기 연결이 가능합니다.  
        *   **향상된 멀티플렉싱:**  
            *   QUIC은 내부적으로 스트림 단위로 독립적인 전송을 관리하므로, 하나의 스트림에서 패킷 손실이 발생해도 다른 스트림에 영향을 주지 않습니다.  
        *   **향상된 패킷 손실 처리:**  
            *   QUIC은 자체적으로 오류 복구를 수행하므로, TCP처럼 전체 연결이 중단되지 않습니다.  
        *   **모바일 네트워크 성능 향상:**  
            *   IP 주소 변경 시에도 연결 ID를 통해 세션을 유지할 수 있어, 네트워크 전환 시에도 안정적인 연결이 가능합니다.  
        *   **빠른 연결 설정:**  
            *   QUIC 핸드셰이크와 TLS 1.3을 결합하여 1-RTT(또는 과거 연결 이력이 있을 경우 0-RTT)로 연결을 설정할 수 있습니다.  
        *   **네트워크 변경에 강건:**  
            *   QUIC 연결 ID를 사용하여 IP 주소에 의존하지 않으므로, 모바일 네트워크 환경에서 안정적인 연결을 유지할 수 있습니다.  

### **100.3 현재 사용 현황 (2023년 기준)**

*   **HTTP/1.1:**  
    *   간단한 웹사이트나 레거시 시스템에서 여전히 널리 사용됩니다.  
    *   호환성과 안정성이 뛰어나, HTTP/2나 HTTP/3로의 전환이 어려운 환경에서도 활용됩니다.  

*   **HTTP/2:**  
    *   웹 요청의 60% 이상을 처리하며, 대부분의 현대 웹 브라우저와 서버가 기본적으로 지원합니다.  
    *   멀티플렉싱, 헤더 압축 등의 기능으로 성능이 크게 향상되었습니다.  

*   **HTTP/3:**  
    *   도입 초기 단계로, Google, Cloudflare, Facebook 등의 대형 기업에서 선도적으로 채택.  
    *   아직 널리 보급되지는 않았지만, 모바일 네트워크와 고지연 환경에서의 성능 향상이 기대됩니다.  

