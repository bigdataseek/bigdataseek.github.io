---
title: 7차시 7:React
layout: single
classes: wide
categories:
  - React
toc: true # 이 포스트에서 목차를 활성화
toc_sticky: true # 목차를 고정할지 여부 (선택 사항)
---

## 1. React 소개 및 핵심 개념

### 1.1 React란 무엇인가? ⚛️

  * **UI 구축을 위한 JavaScript 라이브러리:** React는 웹 애플리케이션의 **사용자 인터페이스(UI)**를 만드는 데 특화된 라이브러리입니다. 프레임워크(Framework)보다는 라이브러리(Library)로 불리며, 전체 애플리케이션 구조를 강제하기보다는 UI 부분에 집중합니다.
  * **선언적(Declarative) 뷰:** React는 데이터가 변경될 때마다 DOM을 직접 조작하는 대신, 상태(State)만 변경하면 React가 자동으로 효율적인 방식으로 UI를 업데이트합니다.
  * **컴포넌트 기반 아키텍처:** 전체 UI를 독립적이고 재사용 가능한 작은 조각인 **컴포넌트**로 분할하여 개발합니다.

### 1.2 핵심 개념 (Components, Props, State)

React 학습의 가장 중요한 3가지 기본 요소는 다음과 같습니다:

| 개념 | 설명 |
| :--- | :--- |
| **컴포넌트 (Component)** | React의 기본 빌딩 블록. 재사용 가능한 UI 조각을 의미하며, JavaScript 함수로 작성됩니다. |
| **Props (속성)** | 부모 컴포넌트에서 자식 컴포넌트로 전달되는 **읽기 전용(Read-only)** 데이터입니다. 함수의 인자(argument)와 유사합니다. |
| **State (상태)** | 컴포넌트 내부에서 관리되며, 시간이 지남에 따라 **변경될 수 있는** 데이터입니다. State가 변경되면 해당 컴포넌트는 다시 렌더링됩니다. |



## 2. JSX (JavaScript XML)

### 2.1 이론

**JSX**는 JavaScript에 XML/HTML 문법을 추가한 확장 문법입니다. React에서 UI를 어떻게 보여줄지 설명하기 위해 사용합니다. 학생들에게는 HTML을 JavaScript 안에서 작성하는 것처럼 보일 것이라고 설명하면 이해하기 쉽습니다.

  * **JavaScript 표현식 사용:** JSX 내부에서 중괄호(`{}`)를 사용하여 JavaScript 변수, 함수 호출, 표현식 등을 삽입할 수 있습니다. (`<h1>{name}</h1>`)
  * **클래스 대신 `className`:** HTML의 `class` 속성은 JavaScript의 예약어이므로, JSX에서는 `className`을 사용합니다.
  * **하나의 루트 요소:** 컴포넌트는 반드시 하나의 루트 요소(Root Element)를 반환해야 합니다. 여러 요소를 반환해야 할 경우 `<></>` (Fragment)로 감싸줍니다.

### 2.2 간단한 샘플 예제 (JSX)

```jsx
// src/App.js

import React from 'react';

function App() {
  const title = 'Hello, React!';
  const showTitle = true;

  return (
    <div>
      {/* 1. 중괄호 {} 안에 JS 변수 사용 */}
      <h1>{title}</h1> 
      
      {/* 2. 조건부 렌더링 (JS 표현식 사용) */}
      {showTitle && <p>This is a paragraph rendered conditionally.</p>}
      
      {/* 3. 클래스 이름은 className으로 작성 */}
      <button className="my-button" onClick={() => alert('Clicked!')}>
        Click Me
      </button>
    </div>
  );
}

export default App;
```



## 3. 함수형 컴포넌트와 Props

### 3.1 이론

최신 React에서는 **함수형 컴포넌트(Functional Component)**와 **Hook**을 주로 사용합니다. 함수형 컴포넌트는 단순히 JavaScript 함수로 작성되며, JSX를 반환합니다.

  * **함수형 컴포넌트 작성:** 일반적인 JavaScript 함수를 작성하는 것과 동일합니다. (화살표 함수 또는 `function` 키워드 사용)
  * **Props 전달:** 부모 컴포넌트가 자식 컴포넌트에 데이터를 전달할 때 사용합니다. Props는 함수 컴포넌트의 첫 번째 인자(`props` 객체)로 전달됩니다.

### 3.2 간단한 샘플 예제 (Props)

```jsx
// src/components/WelcomeMessage.js
// Props를 받는 자식 컴포넌트

import React from 'react';

// props를 인자로 받아 구조 분해 할당으로 name을 추출
function WelcomeMessage({ name, age }) { 
  return (
    <p>안녕하세요, {name}님! 당신은 {age}살입니다.</p>
  );
}

export default WelcomeMessage;


// src/App.js
// WelcomeMessage를 사용하는 부모 컴포넌트

import React from 'react';
import WelcomeMessage from './components/WelcomeMessage';

function App() {
  return (
    <div>
      <h2>컴포넌트와 Props 연습</h2>
      
      {/* WelcomeMessage 컴포넌트에 name, age라는 Props를 전달 */}
      <WelcomeMessage name="김철수" age={25} /> 
      <WelcomeMessage name="이영희" age={30} />
    </div>
  );
}

export default App;
```



## 4. State와 Hook (`useState`)

### 4.1 이론

애플리케이션의 동적인 부분, 즉 사용자 상호작용(버튼 클릭, 입력 등)에 따라 화면이 바뀌어야 할 때 **State**를 사용합니다. 함수형 컴포넌트에서는 **Hooks**를 통해 State를 관리하며, 그 중 가장 기본이 되는 것이 **`useState`**입니다.

  * **`useState` 훅:** 함수 컴포넌트에서 상태를 추가할 수 있게 해주는 React 함수입니다.
  * **배열 비구조화 할당:** `useState`는 `[현재 상태 값, 상태 업데이트 함수]`의 배열을 반환합니다. 이 값을 배열 비구조화 할당으로 받습니다.
  * **불변성(Immutability):** React에서 State를 업데이트할 때는 기존 상태를 직접 수정하지 않고, **새로운 상태 값**을 만들어 `상태 업데이트 함수`를 통해 설정해야 합니다.

### 4.2 간단한 샘플 예제 (State와 `useState`)

사용자가 버튼을 클릭할 때마다 숫자가 증가하는 간단한 카운터 앱 예제입니다.

```jsx
// src/components/Counter.js

import React, { useState } from 'react'; // 1. useState Hook을 import

function Counter() {
  // 2. State 선언: [현재 상태 값, 상태 업데이트 함수]
  const [count, setCount] = useState(0); // 초기 상태 값은 0

  // 3. 이벤트 핸들러 함수
  const handleIncrease = () => {
    // 4. 상태 업데이트 함수(setCount)를 사용하여 상태 변경
    // 기존 count 값에 +1을 더한 새로운 값을 설정 (불변성 유지)
    setCount(count + 1); 
  };
  
  const handleDecrease = () => {
    setCount(count - 1);
  };

  return (
    <div>
      <h3>카운터</h3>
      <p>현재 값: **{count}**</p>
      <button onClick={handleIncrease}>증가 (+)</button>
      <button onClick={handleDecrease}>감소 (-)</button>
      
      {/* JS 문법을 알면, 삼항 연산자를 사용한 조건부 표시 등도 가능합니다 */}
      {count >= 5 && {%raw%}<p style={{ color: 'red' }}>값이 5 이상입니다!</p>{%endraw%}}
    </div>
  );
}

export default Counter;
```

이러한 단계(React 소개 $\to$ JSX $\to$ 컴포넌트 & Props $\to$ State & `useState`)를 따라가면, JavaScript 지식을 활용하여 동적인 UI를 만들 수 있는 React의 기본 원리를 빠르게 파악할 수 있을 것입니다.

## 5. JavaScript 기반 React 핵심 개념 정리

### 5.1 React의 기본 구성 요소 (Building Blocks)

| 개념 | 설명 | 
| :--- | :--- | :--- |
| **React** | 다양한 용어(Reconciliation, Composition, Error Boundaries 등)로 가득 찬 **JavaScript 라이브러리**입니다. | 
| **컴포넌트 (Components)** | 모든 React 앱의 **기본 구성 요소**이며, 버튼, 입력 필드 또는 전체 페이지와 같이 보이는 모든 부분을 만듭니다. 레고처럼 원하는 만큼 여러 번 사용할 수 있습니다. | 
| **JSX** | 모든 React 컴포넌트는 마크업을 반환하는 JavaScript 함수인데, 이는 HTML이 아닌 **JSX**를 반환합니다. JSX는 **'위장한 JavaScript'**이며 사용자 인터페이스를 만드는 데 사용됩니다. | 
| **속성 및 동적 값** | JSX는 JavaScript이기 때문에 HTML의 정적인 방식과 달리 **동적인 JavaScript 값**을 사용할 수 있습니다. 데이터를 표시하려면 **중괄호 (`{}`)**를 사용합니다. HTML 속성(예: `class`)은 JavaScript의 카멜 케이스(camel case) 스타일을 따라 `className`이 됩니다. | 
| **단일 반환 요소** | JavaScript 함수는 한 가지만 반환할 수 있으므로, React에서는 컴포넌트가 **하나의 부모 요소**만 반환할 수 있습니다. 여러 요소를 추가 요소 없이 묶으려면 **React Fragment**라는 빈 컴포넌트를 사용합니다. | 

### 5.2 데이터 전달 및 컴포넌트 구성

| 개념 | 설명 |
| :--- | :--- | :--- |
| **Props (속성)** | 컴포넌트 간에 데이터를 전달하기 위해 사용합니다. Props는 컴포넌트 매개변수(parameters)로 받는 **객체의 속성**이며, 컴포넌트에 추가할 수 있는 사용자 지정 속성(custom attributes)과 같습니다. 모든 유형의 값이나 심지어 다른 컴포넌트도 Props로 전달할 수 있습니다. | 
| **Composition (구성)** | React 컴포넌트를 최적으로 조직화하는 방법을 의미합니다. | |
| **Children prop** | 컴포넌트에 여는 태그와 닫는 태그를 만들고 그 사이에 전달된 다른 컴포넌트(자식)에 접근할 수 있도록 해줍니다. 자식들이 동일한 레이아웃을 갖도록 만들 때 **레이아웃 컴포넌트**를 생성하는 데 매우 유용합니다. | 
| **Key prop** | React에 내장된 prop으로, React가 하나의 컴포넌트를 다른 컴포넌트와 **구별**할 수 있도록 사용됩니다. 일반적으로 `map` 함수로 목록을 만들 때 필요하며, 고유한 문자열이나 숫자여야 합니다. 고유한 값이 없을 경우 `map` 함수의 현재 인덱스를 사용할 수도 있습니다. | 

### 5.3 렌더링 및 Virtual DOM

| 개념 | 설명 |
| :--- | :--- | :--- |
| **DOM (Document Object Model)** | 모든 브라우저가 웹페이지의 HTML 요소를 모델링하는 데 사용하는 것입니다 (나무 구조와 유사). | 
| **Virtual DOM (VDOM)** | React가 애플리케이션을 언제 어떻게 렌더링할지 아는 데 사용하는 개념입니다. 실제 DOM보다 업데이트가 빠릅니다. | 
| **렌더링 프로세스** | 1. **상태(State) 변경:** React 앱의 상태가 변경됩니다. 2. **VDOM 업데이트:** React가 Virtual DOM을 업데이트합니다. 3. **Diffing (차이점 비교):** 업데이트된 VDOM을 이전 버전과 비교하여 변경된 사항을 확인합니다. 4. **Reconciliation (조정):** 발견된 변경 사항으로 **실제 DOM을 업데이트**합니다. | 

### 5.4 상태 관리 및 Hooks (훅)

| 개념 | 설명 | 
| :--- | :--- | :--- |
| **이벤트 핸들링** | 사용자 이벤트(클릭, 키 누름 등)를 감지하고 이를 처리하는 방법입니다. React에는 `onClick`, `onChange`, `onSubmit`과 같은 내장 이벤트가 있습니다. 이벤트 핸들러는 prop으로 추가하고 함수에 연결하여 사용합니다. | 
| **State (상태)** | 앱의 특정 시점 스냅샷과 같으며, React 앱에서 데이터를 관리하기 위해 필요합니다. 일반 JavaScript 변수는 렌더링을 유발하지 않기 때문에 상태 관리에는 `useState`나 `useReducer` 같은 **특수 함수**를 사용해야 합니다. | 
| **`useState`** | 상태 변수의 시작 값을 인수로 취하며, **상태 변수**와 해당 상태를 **업데이트하는 함수**를 포함하는 배열을 반환합니다. | 
| **제어 컴포넌트 (Controlled Components)** | 상태 값을 사용하여 더 예측 가능한 동작을 갖는 컴포넌트입니다. 예를 들어, 입력 필드에 입력된 값이 상태에 저장되고, 이 상태 값이 입력의 값을 제어합니다. 컴포넌트 동작 변경을 상태 변경만으로 쉽게 할 수 있는 훌륭한 패턴입니다. | 
| **React Hooks** | 함수 컴포넌트 내에서 상태와 같은 React 기능에 **'연결(hook into)'**할 수 있게 해주는 기능입니다. | 
| **주요 훅 유형** | - **상태 훅:** `useState`, `useReducer` (상태 관리).<br> - **컨텍스트 훅:** `useContext` (Context 데이터 사용). <br> - **Ref 훅:** `useRef` (HTML 요소 등 참조).<br> - **이펙트 훅:** `useEffect` (브라우저 API 등 외부 시스템 연결).<br> - **성능 훅:** `useMemo`, `useCallback` (불필요한 작업 방지). | 

### 5.5 컴포넌트 순수성 및 에러 처리

| 개념 | 설명 | 
| :--- | :--- | :--- |
| **순수성 (Purity)** | 수학 공식처럼 **동일한 입력이 항상 동일한 출력을 반환**해야 하는 React 컴포넌트의 작동 방식입니다. 순수한 컴포넌트는 JSX만 반환해야 하며, 렌더링 이전에 존재했던 외부 변수나 객체를 변경해서는 안 됩니다. | 
| **Strict Mode (엄격 모드)** | 개발 중 실수에 대해 알려주는 특수 컴포넌트입니다. 일반적으로 앱 컴포넌트를 감싸서 사용하며, 권장되지 않는 작업을 할 때 경고를 해줍니다. | 
| **Error Boundaries (에러 경계)** | 렌더링 중 발생하는 심각한 오류를 포착하고, 앱이 완전히 충돌하는 것을 방지하기 위해 사용자에게 도움이 되는 오류 메시지를 포함하는 **대체 컴포넌트(fallback component)**를 표시할 수 있도록 해줍니다. | 

### 5.6 외부 시스템 연동 및 고급 기능

| 개념 | 설명 | 
| :--- | :--- | :--- |
| **Effects (이펙트 / 부수 효과)** | React 애플리케이션 외부로 나가는 코드(예: 서버 요청, 브라우저 API 호출)를 의미합니다. 이벤트 핸들러 내에서 실행하는 것이 가능하지만, 그렇지 않다면 **`useEffect` 훅**을 사용합니다. (예: 컴포넌트가 처음 로드될 때 데이터 가져오기). | 
| **Refs (참조)** | React 방식을 따르는 대신 **DOM 요소에 직접 작업**하거나 참조할 때 사용됩니다. `useRef` 훅으로 Ref를 생성하고, React 요소에 `ref` prop을 사용하여 실제 DOM 요소에 접근합니다. (예: 입력 필드에 포커스 맞추기). | 
| **Context (컨텍스트)** | 중첩된 컴포넌트가 많은 앱에서 여러 단계를 거쳐 prop을 전달할 필요 없이 **데이터를 컴포넌트 트리 전체에 전달**하는 강력한 방법입니다. Context를 생성하고, **Context Provider**로 부모를 감싸 데이터를 넣은 다음, `useContext` 훅으로 원하는 자식 컴포넌트에서 데이터에 액세스합니다. | 
| **Portals (포털)** | React 컴포넌트를 원하는 **HTML 요소로 이동**시킬 수 있게 해줍니다. 부모의 스타일 때문에 제대로 표시될 수 없는 모달, 드롭다운 메뉴, 툴팁 등에 유용합니다. `createPortal` 함수를 사용하여 생성합니다. | 
| **Suspense (서스펜스)** | 컴포넌트나 데이터 로딩을 처리하는 데 도움을 주는 특수 컴포넌트입니다. 데이터를 가져오는 데 시간이 걸릴 때, 데이터가 준비될 때까지 로딩 스피너 같은 **대체 컴포넌트**를 보여줌으로써 더 나은 사용자 경험을 제공합니다. 컴포넌트를 필요할 때만 로드하는 지연 로딩(lazily loading)에도 유용합니다. | 


 
## 6. React 핵심 개념 예제 가이드 

### 6.1 React 기본 구성 요소

*   컴포넌트와 JSX

```jsx
// 함수형 컴포넌트 예제
function Welcome() {
  const name = "React 학생";
  
  return (
    <div className="welcome-container">
      <h1>안녕하세요, {name}님!</h1>
      <p>React 세계에 오신 것을 환영합니다.</p>
    </div>
  );
}

// JSX에서 JavaScript 표현식 사용
function DynamicMessage() {
  const currentTime = new Date().getHours();
  const greeting = currentTime < 12 ? "좋은 아침입니다!" : "안녕하세요!";
  
  return (
    <>
      <p>{greeting}</p>
      <p>현재 시간: {new Date().toLocaleTimeString()}</p>
    </>
  );
}
```

### 6.2 Props와 컴포넌트 구성

*   Props 전달하기

```jsx
// Props를 받는 컴포넌트
function UserCard({ name, age, email }) {
  return (
    <div className="user-card">
      <h2>{name}</h2>
      <p>나이: {age}세</p>
      <p>이메일: {email}</p>
    </div>
  );
}

// Children prop 사용하기
function Card({ children, title }) {
  return (
    <div className="card">
      <h3>{title}</h3>
      <div className="card-content">
        {children}
      </div>
    </div>
  );
}

// 사용 예시
function App() {
  return (
    <div>
      <UserCard name="김철수" age={25} email="chulsoo@example.com" />
      
      <Card title="소개">
        <p>이것은 children으로 전달된 내용입니다.</p>
        <button>확인</button>
      </Card>
    </div>
  );
}
```

*   Key prop과 리스트 렌더링

```jsx
function TodoList() {
  const todos = [
    { id: 1, text: "React 공부하기", completed: false },
    { id: 2, text: "과제 제출하기", completed: true },
    { id: 3, text: "프로젝트 계획하기", completed: false }
  ];

  return (
    {%raw%}
    <ul>
      {todos.map(todo => (
        <li key={todo.id}>
          <span style={{ 
            textDecoration: todo.completed ? 'line-through' : 'none' 
          }}>
            {todo.text}
          </span>
        </li>
      ))}
    </ul>
    {%endraw%}
  );
}
```

### 6.3 State와 이벤트 핸들링

*   useState 훅 사용하기

```jsx
import { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  const increment = () => {
    setCount(count + 1);
  };

  const decrement = () => {
    setCount(count - 1);
  };

  return (
    <div>
      <h2>카운터: {count}</h2>
      <button onClick={decrement}>-1</button>
      <button onClick={increment}>+1</button>
      <button onClick={() => setCount(0)}>리셋</button>
    </div>
  );
}
```

*   제어 컴포넌트 (Controlled Components)

```jsx
function LoginForm() {
  const [formData, setFormData] = useState({
    username: '',
    password: ''
  });

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    console.log('제출된 데이터:', formData);
  };

  return (
    <form onSubmit={handleSubmit}>
      <div>
        <label>사용자명:</label>
        <input
          type="text"
          name="username"
          value={formData.username}
          onChange={handleChange}
        />
      </div>
      <div>
        <label>비밀번호:</label>
        <input
          type="password"
          name="password"
          value={formData.password}
          onChange={handleChange}
        />
      </div>
      <button type="submit">로그인</button>
    </form>
  );
}
```

### 6.4 useEffect와 외부 시스템 연동

```jsx
import { useState, useEffect } from 'react';

function DataFetcher() {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    // 컴포넌트가 마운트될 때 데이터 fetching
    fetch('https://api.example.com/data')
      .then(response => response.json())
      .then(data => {
        setData(data);
        setLoading(false);
      })
      .catch(error => {
        setError(error.message);
        setLoading(false);
      });
  }, []); // 빈 의존성 배열: 컴포넌트 마운트 시 한 번만 실행

  if (loading) return <div>로딩 중...</div>;
  if (error) return <div>에러: {error}</div>;

  return (
    <div>
      <h2>가져온 데이터:</h2>
      <pre>{JSON.stringify(data, null, 2)}</pre>
    </div>
  );
}
```

### 6.5 Context API를 이용한 상태 관리

```jsx
import { createContext, useContext, useState } from 'react';

// Context 생성
const ThemeContext = createContext();

// Provider 컴포넌트
function ThemeProvider({ children }) {
  const [isDark, setIsDark] = useState(false);

  const toggleTheme = () => {
    setIsDark(!isDark);
  };

  return (
    {%raw%}
    <ThemeContext.Provider value={{ isDark, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
    {%endraw%}
  );
}

// Context를 사용하는 컴포넌트
function ThemedButton() {
  const { isDark, toggleTheme } = useContext(ThemeContext);
  
  return (
    {%raw%}
    <button 
      onClick={toggleTheme}
      style={{
        backgroundColor: isDark ? '#333' : '#fff',
        color: isDark ? '#fff' : '#333'
      }}
    >
      {isDark ? '라이트 모드' : '다크 모드'}
    </button>
    {%endraw%}
  );
}

// 앱에서 사용
function App() {
  return (
    <ThemeProvider>
      <div>
        <h1>테마 예제</h1>
        <ThemedButton />
      </div>
    </ThemeProvider>
  );
}
```

### 6.6 useRef와 DOM 조작

```jsx
import { useRef } from 'react';

function FocusInput() {
  const inputRef = useRef(null);

  const handleFocus = () => {
    inputRef.current.focus();
  };

  return (
    <div>
      <input 
        ref={inputRef} 
        type="text" 
        placeholder="여기를 클릭해보세요!" 
      />
      <button onClick={handleFocus}>입력창에 포커스</button>
    </div>
  );
}
```

### 6.7 커스텀 훅 만들기

```jsx
import { useState, useEffect } from 'react';

// 커스텀 훅: 로컬 스토리지와 상태 동기화
function useLocalStorage(key, initialValue) {
  const [value, setValue] = useState(() => {
    const storedValue = localStorage.getItem(key);
    return storedValue ? JSON.parse(storedValue) : initialValue;
  });

  useEffect(() => {
    localStorage.setItem(key, JSON.stringify(value));
  }, [key, value]);

  return [value, setValue];
}

// 커스텀 훅 사용 예제
function Settings() {
  const [username, setUsername] = useLocalStorage('username', '');
  const [theme, setTheme] = useLocalStorage('theme', 'light');

  return (
    <div>
      <input
        value={username}
        onChange={(e) => setUsername(e.target.value)}
        placeholder="사용자명"
      />
      <select value={theme} onChange={(e) => setTheme(e.target.value)}>
        <option value="light">라이트</option>
        <option value="dark">다크</option>
      </select>
    </div>
  );
}
```

## 7.학습 체크리스트

각 개념을 학습한 후 다음 질문에 답해보세요:

### ✅ 기본 개념
- [ ] 컴포넌트가 무엇인지 설명할 수 있나요?
- [ ] JSX와 HTML의 차이점을 이해했나요?
- [ ] Props를 통해 어떻게 데이터를 전달하나요?

### ✅ 상태 관리
- [ ] useState 훅을 사용할 수 있나요?
- [ ] 제어 컴포넌트와 비제어 컴포넌트의 차이를 이해했나요?
- [ ] 이벤트 핸들링을 할 수 있나요?

### ✅ 고급 개념
- [ ] useEffect의 사용 사례를 이해했나요?
- [ ] Context API를 왜 사용해야 하는지 알겠나요?
- [ ] useRef로 DOM을 조작할 수 있나요?

### ✅ 실전 적용
- [ ] 간단한 폼을 만들 수 있나요?
- [ ] API에서 데이터를 가져와 표시할 수 있나요?
- [ ] 여러 컴포넌트를 조합하여 앱을 만들 수 있나요?

이 예제들을 직접 따라해보고 변형해보면서 React의 핵심 개념을 익혀보세요. 각 개념은 점진적으로 복잡해지므로, 앞의 개념을 충분히 이해한 후 다음으로 넘어가는 것이 중요합니다.