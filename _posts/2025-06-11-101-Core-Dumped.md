---
title: 47차시 1:Core Dumped
layout: single
classes: wide
categories:
  - Core Dumped
toc: true # 이 포스트에서 목차를 활성화
toc_sticky: true # 목차를 고정할지 여부 (선택 사항)
---


## 1. 시스템 프로그래밍에서 '변수의 크기'가 중요한 이유: 스크립팅 언어와의 근본적인 차이점
- 출처: [The size of your variables matters.](https://www.youtube.com/watch?v=hwyRnHA54lI&t=69s)

자바스크립트나 파이썬 같은 스크립팅 언어에서 러스트(Rust)나 C와 같은 시스템 프로그래밍 언어로 넘어갈 때 만나게 되는 **핵심적인 개념 중 하나인 '변수의 크기'**에 대해 이야기해보려 합니다. 이 개념을 이해하는 것은 러스트의 '빌림 검사기(Borrow Checker)'가 막으려는 '풋건(Foot Guns, 발등을 찍는 실수)'을 이해하는 데 도움이 될 뿐만 아니라, 시스템 프로그래밍 언어의 설계 철학을 깊이 이해하는 데 필수적입니다.

### 11. 스크립팅 언어와 시스템 프로그래밍 언어의 '타입' 개념 차이

파이썬이나 자바스크립트에서 러스트 또는 C로 전환할 때 가장 먼저 알아차리는 것 중 하나는 **변수를 선언할 때 타입을 명시해야 한다는 점**입니다. 스크립팅 언어에서는 단순히 '숫자'라고 정의할 수 있지만, 러스트나 C에서는 정수와 부동 소수점 값뿐만 아니라 **각기 다른 종류의 타입**들이 존재합니다.

**왜 이런 차이가 있을까요?** 간단히 말해, 시스템 프로그래밍 언어는 **데이터를 표현하는 데 메모리 공간을 얼마나 사용할지 명시적으로 지정**할 수 있게 해주기 때문입니다.

*   **비트와 바이트**: 컴퓨터의 모든 정보는 0과 1의 **비트(bit) 시퀀스**로 표현됩니다. 2비트 시퀀스는 0부터 3까지 4가지 값을 나타낼 수 있고, 비트를 하나 추가할 때마다 표현할 수 있는 값의 범위는 **두 배로 늘어납니다**.
*   **메모리 제한**: 프로그램이 실행될 때 모든 변수는 **메모리 어딘가에 위치하며, 이 메모리는 제한적**입니다.
*   **타입의 목적**: 이러한 다양한 타입들은 프로그램이 사용할 정보를 표현하는 데 **얼마나 많은 공간이 필요한지 컴파일러에게 명시적이고 정확하게 알려주는 '초능력'**을 제공합니다. 컴퓨터는 비트 대신 **8비트 그룹인 바이트(byte) 단위**로 작동하며, 이것이 8, 16, 32, 64비트 숫자들을 흔히 접하는 이유입니다.

### 1.2 변수 크기의 중요성: 메모리 효율성

변수의 크기를 명시하는 것이 왜 중요할까요? 실제 예를 들어보겠습니다.

*   **나이 표현 예시**: 사람의 나이를 프로그램에서 표현한다고 가정해봅시다. 나이는 보통 100을 넘지 않으므로, 64비트 부호 없는 정수(8바이트)를 사용한다면 7바이트는 **사용되지 않는 낭비된 공간**이 됩니다. 8비트 부호 없는 정수(1바이트)만으로도 256가지 값을 표현할 수 있으므로, 나이(최대 255를 넘지 않음)를 표현하는 데 충분합니다.
*   **스크립팅 언어의 낭비**: 스크립팅 언어에서는 변수를 선언할 때 개발자가 이 모든 것을 신경 쓸 필요가 없습니다. 인터프리터가 변수에 필요한 **메모리 공간을 어디에, 얼마나 할당할지 결정**합니다. 이로 인해 **필요한 것보다 훨씬 많은 메모리를 사용**하게 되는 경우가 거의 항상 발생합니다. 단일 변수에서는 7바이트 낭비가 대수롭지 않게 들릴 수 있지만, 수천 개의 나이와 같은 데이터를 다룬다면 **엄청난 메모리 낭비**로 이어집니다.

### 1.3 명시적 타이핑의 추가 이점: 안전성 및 예측 가능성

러스트와 같은 언어의 타이핑 시스템은 메모리 효율성 외에도 **코드의 안전성과 예측 가능성**을 높여줍니다.

*   **음수 값 방지**: 러스트의 타이핑 시스템은 숫자가 음수일 수 있는지 여부를 정의할 수 있게 해줍니다. 나이는 음수가 될 수 없으므로, **부호 없는 정수(unsigned integer)**를 사용함으로써 컴파일러에게 음수 값을 나이 변수에 할당하려는 모든 코드를 **거부하도록 지시**할 수 있습니다.
*   **타입 불일치 방지**: 자바스크립트에서는 정수와 부동 소수점 값을 단순히 더하는 것이 가능합니다. 이 경우 결과가 정수일지 부동 소수점일지, 혹은 연산 전에 인터프리터가 타입을 변환할지 등을 **코드만 보고는 알기 어렵습니다**. 개발자의 경험이나 숨겨진 문서를 통해서만 알 수 있다는 것은 좋지 않습니다.
*   **'풋건' 방지**: 러스트에서는 이러한 '풋건'을 피하기 위해 **명시적으로 무엇을 달성하려는지 표현**해야 합니다.

### 1.4 성능: 동적 타이핑 vs. 정적 타이핑

변수의 크기를 명시하는 것은 **성능에도 엄청난 영향**을 미칩니다.

*   **스크립팅 언어의 오버헤드 (동적 타이핑)**:
    *   스크립팅 언어의 인터프리터는 변수에 메모리를 할당한 후, 나중에 해당 변수가 필요할 때 그 비트들이 숫자, 문자열 또는 다른 무엇을 나타내는지 알기 위해 **각 값에 추가 정보(태그)**를 붙입니다.
    *   이 태그들은 **추가적인 메모리 공간(실제로는 여러 바이트)을 요구**합니다.
    *   더 중요한 문제는 이 접근 방식이 **간단한 산술 및 데이터 조작 작업에 큰 오버헤드를 부과**한다는 것입니다.
    *   이 태그들은 초기화되고, 읽고, 비교하고, 런타임에 작성되어야 하며, **이 모든 과정이 CPU 시간을 소모**합니다. 인터프리터는 사용자 코드를 실행하는 대신 이러한 **추가 단계를 실행하는 데 대부분의 시간**을 보냅니다.

*   **시스템 프로그래밍 언어의 효율성 (정적 타이핑)**:
    *   코드에서 변수의 **특정 타입과 크기 정보를 제공하도록 요구받을 때**, 컴파일러는 그 정보를 사용하여 **매우 효율적인 기계 코드**를 생성할 수 있습니다.
    *   예를 들어, 두 변수가 32비트 숫자임을 알면 컴파일러는 두 값을 가져와 더하고 결과를 저장하는 기계 코드를 생성합니다. **추가 메모리 사용도 없고, 추가 유효성 검사도 없습니다**.
    *   이것이 바로 **정적 타이핑 언어가 동적 타이핑 언어보다 일반적으로 몇 배나 빠른 주된 이유**입니다.

### 1.5 더 나아가: 고정 크기 외의 동적 크기 타입

이러한 '변수 크기'의 개념은 사용자 정의 데이터 타입에도 적용됩니다. 하지만 항상 고정 크기 타입만 필요한 것은 아닙니다.

*   **배열의 예**: 컴파일 시점에 배열의 크기를 알 수 없는 경우, 컴파일러는 코드를 거부합니다. 해결책은 크기를 명시하는 것이지만, 이는 해당 변수를 초기화할 때 **정확히 그만큼의 요소를 제공**해야 함을 의미합니다.
*   **동적 크기**: 런타임에 배열의 크기가 변해야 하거나 컴파일 시점에 크기를 알 수 없는 상황에서는 **특수 메모리 영역(예: 힙(Heap))**을 사용합니다. 이 경우 사용자 정의 타입은 배열 자체를 담는 대신, 해당 메모리 영역에 대한 **참조(reference)**와 배열의 크기 같은 추가 정보를 가지게 됩니다.
*   **스택(Stack)과 힙(Heap)**: 이처럼 메모리 영역의 개념은 좀 더 복잡해지며, 스택과 힙과 같은 개념은 별도의 심층적인 논의가 필요합니다.

### 1.6 결론

이제 **'변수의 크기'가 시스템 프로그래밍에서 왜 그토록 중요한지** 이해하셨기를 바랍니다. 이는 단순히 코딩 스타일의 문제가 아니라, **메모리 효율성, 프로그램의 안정성, 그리고 궁극적으로 성능에 직접적인 영향**을 미치는 근본적인 개념입니다. 이러한 저수준 개념들을 이해함으로써 여러분은 더 견고하고 효율적인 소프트웨어를 개발할 수 있을 것입니다.
