---
title: 1차시 5(빅데이터 분석):Numpy
layout: single
classes: wide
categories:
  - Numpy
toc: true # 이 포스트에서 목차를 활성화
toc_sticky: true # 목차를 고정할지 여부 (선택 사항)
---

## 1. NumPy, 왜 배우나요? 데이터 과학의 필수 도구
- 출처: [NumPy Full Python Course - Data Science Fundamentals](https://www.youtube.com/watch?v=4c_mwnYdbhQ)


> 넘설기속 자규무특 수변합통저
>
> (넘)파이 나라의 (설기속)이라는 관리는 (자)치 (규)약을 만들어 (무)역으로 (특)별한 값을 창출하고,\
> (수)군을 (변)혁하고 (합)하여 수군(통저)사가 되었다

NumPy는 파이썬(Python)에서 **숫자 계산**을 빠르고 효율적으로 할 수 있게 도와주는 특별한 도구예요. 특히 **벡터, 행렬, 배열** 같은 데이터를 다룰 때 강력한 힘을 발휘하죠.

  * **빠르고 효율적이에요**: NumPy는 파이썬으로 만들어졌지만, 실제 핵심 부분은 C언어로 되어 있어서 엄청나게 빠르답니다.
  * **데이터 과학의 기반**: 판다스(Pandas), 사이킷런(scikit-learn), 텐서플로우(TensorFlow) 등 데이터 과학과 머신러닝 분야에서 사용하는 대부분의 중요한 도구들이 바로 이 NumPy를 기반으로 하고 있어요. 그래서 데이터 과학 분야에 관심 있다면 NumPy는 꼭 알아야 하는 필수 지식이죠\!
  * **어마어마하게 많이 쓰여요**: 개발자들이 가장 많이 사용하는 도구 중 하나로 손꼽힐 만큼 널리 사용되고 있어요.

### 1.1 NumPy (설)치하고 사용하기

NumPy를 사용하려면 먼저 컴퓨터에 설치해야 해요.

1.  **설치**: 컴퓨터의 '명령 프롬프트'나 '터미널'을 열고 다음 명령어를 입력하세요.
    ```bash
    pip install numpy
    ```
2.  **가져오기 (Import)**: 파이썬 코드에서 NumPy를 사용하려면 항상 맨 위에 다음 코드를 추가해야 해요.
    ```python
    import numpy as np
    ```
    여기서 `as np`는 '앞으로 NumPy를 `np`라는 짧은 이름으로 부를게\!'라는 약속이에요. 이렇게 하면 코드를 더 짧게 쓸 수 있어서 편리하죠.

### 1.2 NumPy 배열의 (기)초

NumPy의 가장 중요한 개념은 바로 **배열(Array)**이에요. 파이썬의 '리스트(List)'와 비슷하게 여러 개의 값을 담을 수 있지만, 훨씬 강력하고 효율적이랍니다.

  * **배열 만들기**: 파이썬 리스트를 `np.array()` 안에 넣어서 만들 수 있어요.
    ```python
    my_list = [1, 2, 3]
    my_array = np.array(my_list)
    print(my_array)
    # 결과: [1 2 3] (리스트와 다르게 쉼표가 없어요!)
    ```
  * **빠른 이유**: NumPy 배열은 C언어로 최적화되어 있어서 계산이 훨씬 빨라요.
  * **데이터 타입이 같아야 해요**: 파이썬 리스트는 숫자, 글자 등 다양한 종류의 데이터를 한꺼번에 담을 수 있지만, NumPy 배열은 **모든 요소가 같은 종류의 데이터**여야 해요.
      * 만약 다른 종류의 데이터를 섞어서 넣으면, NumPy가 알아서 가장 넓은 범위의 데이터 타입(예: 숫자와 글자를 섞으면 모두 글자로)으로 바꿔서 저장해요.
      * 너무 복잡한 데이터 타입(예: 딕셔너리)을 섞으면 NumPy의 장점인 속도가 느려질 수 있으니 주의하세요.
  * **데이터 타입 지정**: 배열을 만들 때 `dtype`이라는 옵션을 사용해서 특정 데이터 타입을 명확하게 지정할 수도 있어요.
    ```python
    # 정수형 배열 만들기
    int_array = np.array([1, 2, 3], dtype='int32')
    # 실수형 배열 만들기
    float_array = np.array([1.0, 2.5, 3.0], dtype='float64')
    ```

### 1.3 NumPy 배열의 (속)성

만든 배열이 어떤 모습인지 궁금할 때가 있죠? 배열의 여러 정보를 알려주는 속성들이 있어요.

  * **`shape` (모양)**: 배열이 몇 줄, 몇 칸으로 되어 있는지 알려줘요. (예: `(3, 3)`은 3줄 3칸 배열)
  * **`ndim` (차원 수)**: 배열이 몇 차원인지 알려줘요. (예: 1차원, 2차원 등)
  * **`size` (전체 개수)**: 배열 안에 데이터가 총 몇 개 들어있는지 알려줘요.
  * **`dtype` (데이터 타입)**: 배열 안의 데이터가 어떤 종류인지 알려줘요. (예: `int32`, `float64`)

**예시**:

```python
# 2차원 배열 만들기 (3줄 3칸)
my_2d_array = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

print("배열의 모양:", my_2d_array.shape) # 결과: (3, 3)
print("배열의 차원:", my_2d_array.ndim) # 결과: 2
print("배열의 전체 요소 개수:", my_2d_array.size) # 결과: 9
print("배열 요소의 데이터 타입:", my_2d_array.dtype) # 결과: int32 (정수형)
```

### 1.4 특별한 배열 만들기: (자)동 채우기

특정 값으로 채워진 배열을 쉽게 만들 수 있어요.

  * **`np.full(shape, value)`**: 원하는 모양(`shape`)으로 만들고, 모든 칸을 원하는 값(`value`)으로 채워요.
  * **`np.zeros(shape)`**: 모든 칸을 0으로 채워요.
  * **`np.ones(shape)`**: 모든 칸을 1로 채워요.
  * **`np.empty(shape)`**: 그냥 빈 공간만 확보하고, 값을 채우지 않아요. 그래서 기존 메모리에 있던 알 수 없는 값들이 들어있을 수 있지만, `zeros`나 `ones`보다 빠를 수 있어요.

  ```python
    # 3x3 크기의 모든 칸을 7로 채운 배열
    full_array = np.full((3, 3), 7)
    print("full_array:\n", full_array)
    
    # 2x4 크기의 모든 칸을 0으로 채운 배열
    zeros_array = np.zeros((2, 4))
    print("zeros_array:\n", zeros_array)

    # 3x2 크기의 모든 칸을 1로 채운 배열
    ones_array = np.ones((3, 2))
    print("ones_array:\n", ones_array)

    # 2x2 크기의 빈 배열 (값은 임의의 값이 들어있을 수 있음)
    empty_array = np.empty((2, 2))
    print("empty_array:\n", empty_array)
  ```

### 1.5 (규)칙적인 숫자 배열 만들기

특정 규칙에 따라 숫자가 나열된 배열을 만들 때 유용해요.

  * **`np.arange(start, end, step_size)`**: `start`부터 `end` 직전까지 `step_size` 간격으로 숫자를 만들어요. (예: 0, 2, 4, ...)
  * **`np.linspace(start, end, num_values)`**: `start`와 `end` 사이를 `num_values`개로 똑같이 나눠서 숫자를 만들어요.

  ```python
    # 0부터 10 직전까지 2씩 증가하는 배열
    range_array = np.arange(0, 10, 2)
    print("range_array:", range_array)
    
    # 0부터 10까지 5개의 숫자를 균등하게 나눈 배열
    linspace_array = np.linspace(0, 10, 5)
    print("linspace_array:", linspace_array)    
  ```

### 1.6 (무)작위 값 만들기 

임의의 숫자를 만들 때 유용해요.

  * **`np.random.randint(low, high, size)`**: `low`부터 `high` 직전까지 범위에서 무작위 정수를 만들어요. `size`로 원하는 배열 모양을 지정할 수 있어요.
  * **`np.random.normal(loc, scale, size)`**: 정규 분포(평균 `loc`, 표준편차 `scale`)에 따라 무작위 값을 만들어요.
  * **`np.random.choice(배열, size)`**: 주어진 `배열`에서 무작위로 요소를 선택해요.

  ```python
    # 0부터 10 직전까지의 무작위 정수 하나
    random_int_single = np.random.randint(0, 10)
    print("무작위 정수 (하나):", random_int_single)

    # 1부터 100 직전까지의 무작위 정수 5개로 이루어진 1차원 배열
    random_int_array = np.random.randint(1, 100, size=5)
    print("무작위 정수 배열 (5개):", random_int_array)

    # 50부터 100 직전까지의 무작위 정수로 이루어진 2x3 배열
    random_int_2d = np.random.randint(50, 100, size=(2, 3))
    print("무작위 정수 2차원 배열 (2x3):\n", random_int_2d)
  ```

  ```python
    # 평균 0, 표준편차 1인 표준 정규 분포에서 10개의 무작위 실수
    normal_data = np.random.normal(loc=0, scale=1, size=10)
    print("정규 분포 무작위 실수:", normal_data)
  ```

  ```python
    fruits = np.array(['사과', '바나나', '딸기', '오렌지'])

    # fruits 배열에서 무작위로 하나 선택
    chosen_fruit = np.random.choice(fruits)
    print("선택된 과일 (하나):", chosen_fruit)

    # fruits 배열에서 3개를 무작위로 선택 (중복 가능)
    chosen_fruits_multi = np.random.choice(fruits, size=3)
    print("선택된 과일 (3개):", chosen_fruits_multi)

    # 중복을 제거하려면 np.random.choice(fruits, size=3, replace=False)
  ```

### 1.7 (특)별한 값 (NaN, Inf)

데이터를 다루다 보면 '숫자가 아님'이나 '무한대' 같은 특별한 값이 필요할 때가 있어요.

  * **`np.nan` (Not a Number)**: '숫자가 아님'을 나타내요. 데이터가 비어있거나, 계산 결과가 숫자가 아닐 때 사용해요.
  * **`np.inf` (Infinity)**: '무한대'를 나타내요. 예를 들어, 어떤 수를 0으로 나누면 무한대가 되죠.
  * **확인 함수**: `np.isnan(값)`으로 NaN인지, `np.isinf(값)`으로 Infinity인지 확인할 수 있어요.

  ```python
  # NaN 값 생성 및 확인
  a = np.nan
  print("a is NaN:", np.isnan(a))

  # Inf 값 생성 및 확인
  b = np.inf
  print("b is Inf:", np.isinf(b))

  # 유효하지 않은 연산
  d = np.sqrt(-1)
  print("sqrt(-1) is NaN:", np.isnan(d))
  ```

### 1.8 NumPy 배열로 (수)학 계산하기

NumPy의 가장 큰 장점 중 하나는 배열 단위로 편리하게 수학 계산을 할 수 있다는 점이에요.

  * **숫자 하나로 계산 (스칼라 연산)**: 배열에 숫자 하나를 곱하거나 더하면, **배열의 모든 요소**에 똑같이 적용돼요. 일반 파이썬 리스트와는 다르게 작동하죠\!
    ```python
    arr = np.array([1, 2, 3])
    print(arr * 2) # 결과: [2 4 6]
    ```
  * **배열끼리 계산**: 두 개의 NumPy 배열끼리 더하거나 곱하면, **같은 위치에 있는 요소끼리** 계산돼요.
    ```python
    arr1 = np.array([1, 2, 3])
    arr2 = np.array([4, 5, 6])
    print(arr1 + arr2) # 결과: [5 7 9] (1+4, 2+5, 3+6)
    ```
    **중요**: 배열끼리 계산할 때는 배열의 **모양이 같아야** 해요.

  * **다양한 수학 함수**: `np.sqrt()` (제곱근), `np.sin()` (사인), `np.exp()` (지수) 등 다양한 수학 함수를 배열에 바로 적용할 수 있어요. 이 함수들도 각 요소에 대해 계산돼요.
    ```python
    # 1차원 배열
    arr = np.array([1, 4, 9, 16])

    # 제곱근 계산
    sqrt_arr = np.sqrt(arr)
    print("제곱근:", sqrt_arr)

    # 사인 값 계산 (라디안 값 기준)
    sin_arr = np.sin(arr)
    print("사인 값:", sin_arr)

    # 지수 값 계산
    exp_arr = np.exp(arr)
    print("지수 값:", exp_arr)

    # 2차원 배열에도 동일하게 적용
    arr_2d = np.array([[1, 2], [3, 4]])
    sqrt_arr_2d = np.sqrt(arr_2d)
    print("\n2차원 배열의 제곱근:\n", sqrt_arr_2d)    
    ```

### 1.9 배열의 구조를 (변)경

데이터 분석을 하다 보면 배열의 모양을 바꾸거나, 특정 값을 추가/삭제해야 할 때가 많아요.

1.값 추가, 삽입, 삭제

  * **`np.append(배열, 값)`**: 배열의 끝에 값을 추가한 **새로운** 배열을 만들어요. (원본 배열은 바뀌지 않아요\!)
  * **`np.insert(배열, 위치, 값)`**: 지정된 `위치`에 값을 삽입한 **새로운** 배열을 만들어요.
  * **`np.delete(배열, 인덱스, axis)`**: 지정된 `인덱스`의 요소를 삭제해요. `axis`를 사용해서 행(가로줄, `axis=0`) 또는 열(세로줄, `axis=1`) 단위로 삭제할 수 있어요.

  ```python
    arr_original = np.array([1, 2, 3])

    arr_appended = np.append(arr_original, 4)
    print("원본 배열:", arr_original)
    print("추가된 배열:", arr_appended)
    
    arr_inserted = np.insert(arr_original, 3, 4) # 인덱스 3 (네 번째 위치)에 4 삽입
    print("삽입된 배열:", arr_inserted)

    arr_original = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    print("원본 배열:\n", arr_original)

    # 인덱스 1 (두 번째) 행 삭제
    arr_row_deleted = np.delete(arr_original, 1, axis=0)
    print("\n행 삭제 후 배열:\n", arr_row_deleted)    
  ```
  * axis는 다차원 배열에서 연산이 수행되는 **축(방향)**을 나타냅니다:
  * axis=0은 행을 따라 연산하지만, 결과는 열 단위로 나타납니다. 반대로, axis=1은 열을 따라 연산하지만 결과는 행 단위로 나타납니다.

2.모양 변경 (Reshape)

  * **`배열.reshape(새로운_모양)`**: 배열의 모양을 변경한 **새로운** 배열을 만들어요. 요소의 순서는 그대로 유지돼요.
  * **`배열.resize(새로운_모양)`**: **원본 배열 자체의** 모양을 변경해요. 반환하는 값은 없어요.

  ```python
    arr_1d = np.array([1, 2, 3, 4, 5, 6])
    print("원본 1차원 배열:", arr_1d)

    # 1차원 배열을 2행 3열의 2차원 배열로 변경
    arr_2d_reshaped = arr_1d.reshape((2, 3))
    print("\n2행 3열로 reshape:\n", arr_2d_reshaped)
    
    arr_1d.resize((3, 2))
    print("원본 배열 (resize 후):\n", arr_1d)
  ```

3.1차원으로 만들기 (Flattening)

다차원 배열을 한 줄짜리 배열로 만들 때 사용해요.

  * **`배열.flatten()`**: 1차원 **복사본**을 만들어요. 복사본을 바꿔도 원본은 바뀌지 않아요.
  * **`배열.ravel()`**: 1차원 **뷰(View)**를 만들어요. 뷰를 바꾸면 **원본 배열도 같이 바뀌어요**\! (메모리를 공유한다는 뜻)

  ```python
    arr_2d = np.array([[1, 2, 3], [4, 5, 6]])
    print("원본 2차원 배열:\n", arr_2d)

    arr_flat_copy = arr_2d.flatten()
    print("flatten으로 만든 복사본:", arr_flat_copy)

    arr_flat_copy[0] = 99 # 복사본 변경
    print("복사본 변경 후 원본:\n", arr_2d) # 원본은 바뀌지 않음

    arr_flat_view = arr_2d.ravel()
    print("ravel로 만든 뷰:", arr_flat_view)

    arr_flat_view[0] = 99 # 뷰 변경
    print("뷰 변경 후 원본:\n", arr_2d) # 원본도 같이 바뀜
  ```

4.행과 열 바꾸기 (Transposing)

테이블의 가로와 세로를 바꾸는 것처럼, 배열의 행과 열을 서로 바꿀 때 사용해요.

  * **`배열.transpose()`** 또는 **`배열.T`**: 행은 열로, 열은 행으로 바꿔줘요.
  
  ```python
    import numpy as np

    matrix = np.array([[1, 2, 3], [4, 5, 6]])
    print("원본 행렬:\n", matrix)

    # transpose() 사용
    transposed_matrix = matrix.transpose()
    print("\ntranspose() 후:\n", transposed_matrix)

    # .T 속성 사용
    transposed_matrix_T = matrix.T
    print("\n.T 사용 후:\n", transposed_matrix_T)
  ```

### 1.10 배열 (합)치고 나누기

여러 개의 배열을 하나로 합치거나, 하나의 배열을 여러 개로 나눌 수 있어요.

1.합치기 (Joining)

  * **`np.concatenate((배열1, 배열2), axis)`**: 여러 배열을 `axis` 방향으로 연결해요. `axis=0`은 위아래로(행을 따라), `axis=1`은 좌우로(열을 따라) 붙여요.
  * **`np.vstack((배열1, 배열2))`**: 수직으로(위아래로) 쌓아요. (`concatenate`의 `axis=0`과 비슷)
  * **`np.hstack((배열1, 배열2))`**: 수평으로(좌우로) 쌓아요. (`concatenate`의 `axis=1`과 비슷)

  ```python
    arr1 = np.array([[1, 2], [3, 4]])
    arr2 = np.array([[5, 6], [7, 8]])
    print("arr1:\n", arr1)
    print("arr2:\n", arr2)

    # axis=0 (행을 따라) 연결
    concatenated_row = np.concatenate((arr1, arr2), axis=0)
    print("\n행을 따라 합치기 (axis=0):\n", concatenated_row)

    # axis=1 (열을 따라) 연결
    concatenated_col = np.concatenate((arr1, arr2), axis=1)
    print("\n열을 따라 합치기 (axis=1):\n", concatenated_col)
  ```

  ```python
    arr1 = np.array([1, 2])
    arr2 = np.array([3, 4])

    stacked_v = np.vstack((arr1, arr2))
    print("수직으로 쌓기 (vstack):\n", stacked_v)
  ```

  ```python
    arr1 = np.array([1, 2])
    arr2 = np.array([3, 4])

    stacked_h = np.hstack((arr1, arr2))
    print("수평으로 쌓기 (hstack):\n", stacked_h)
  ```

2.나누기 (Splitting)

  * **`np.split(배열, 나눌_개수, axis)`**: 배열을 `나눌_개수`만큼 작은 배열로 나눠요. `axis`에 따라 행 또는 열을 기준으로 나눌 수 있어요.

  ```python
    import numpy as np

    arr_to_split = np.array([1, 2, 3, 4, 5, 6])

    # 3개로 나누기
    split_arrays = np.split(arr_to_split, 3)
    print("3개로 나눈 배열들:", split_arrays)
    # 결과: 3개로 나눈 배열들: [array([1, 2]), array([3, 4]), array([5, 6])]

    matrix_to_split = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])
    print("\n원본 행렬:\n", matrix_to_split)

    # 행을 기준으로 3개로 나누기 (axis=0)
    split_rows = np.split(matrix_to_split, 3, axis=0)
    print("\n행을 기준으로 나눈 배열들 (axis=0):\n", split_rows)

    # 열을 기준으로 2개로 나누기 (axis=1)
    split_cols = np.split(matrix_to_split, 2, axis=1) # 열의 개수가 짝수여야 함 (4개 열을 2개로 나누므로 2개씩)
    print("\n열을 기준으로 나눈 배열들 (axis=1):\n", split_cols)
    
  ```

### 1.11 배열에서 (통)계값 얻기: 집계 함수

배열 안에 있는 데이터의 통계값을 쉽게 계산할 수 있어요.

  * **`배열.min()`**: 가장 작은 값
  * **`배열.max()`**: 가장 큰 값
  * **`배열.mean()`**: 평균값
  * **`배열.std()`**: 표준 편차 (데이터가 평균에서 얼마나 떨어져 있는지)
  * **`배열.sum()`**: 모든 값의 합계
  * **`np.median(배열)`**: 중앙값 (데이터를 순서대로 나열했을 때 가운데 있는 값)

  ```python
  import numpy as np

  data_array = np.array([1, 7, 3, 9, 5, 2, 8, 4, 6])

  print("최소값:", data_array.min())
  # 결과: 최소값: 1
  print("최대값:", data_array.max())
  # 결과: 최대값: 9
  print("평균값:", data_array.mean())
  # 결과: 평균값: 5.0
  print("표준 편차:", data_array.std())
  # 결과: 표준 편차: 2.581988897471611
  print("합계:", data_array.sum())
  # 결과: 합계: 45
  print("중앙값:", np.median(data_array))
  # 결과: 중앙값: 5.0

  # 2차원 배열에서 통계값 (axis 지정)
  matrix_data = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
  print("\n원본 행렬:\n", matrix_data)

  # 전체 합계
  print("전체 합계:", matrix_data.sum())
  # 결과: 전체 합계: 45

  # 각 열의 합계 (axis=0)
  print("각 열의 합계 (axis=0):", matrix_data.sum(axis=0))
  # 결과: 각 열의 합계 (axis=0): [12 15 18] (1+4+7, 2+5+8, 3+6+9)

  # 각 행의 평균 (axis=1)
  print("각 행의 평균 (axis=1):", matrix_data.mean(axis=1))
  # 결과: 각 행의 평균 (axis=1): [2. 5. 8.] ((1+2+3)/3, (4+5+6)/3, (7+8+9)/3)
  ```

  * axis는 다차원 배열에서 연산이 수행되는 **축(방향)**을 나타냅니다:
  * axis=0은 행을 따라 연산하지만, 결과는 열 단위로 나타납니다. 반대로, axis=1은 열을 따라 연산하지만 결과는 행 단위로 나타납니다.

### 1.12 NumPy 배열 (저)장하고 불러오기

만든 NumPy 배열을 파일로 저장하거나, 파일에 저장된 배열을 다시 불러올 수 있어요.

  * **NumPy 전용 형식 (.npy 파일)**:
      * **저장**: `np.save('파일이름.npy', 배열)`
      * **불러오기**: `np.load('파일이름.npy')`
  * **CSV 파일 (쉼표로 구분된 텍스트 파일)**:
      * **저장**: `np.savetxt('파일이름.csv', 배열, delimiter=',')` (쉼표로 구분해서 저장)
      * **불러오기**: `np.loadtxt('파일이름.csv', delimiter=',')` (쉼표로 구분된 파일 불러오기)

  ```python
    import numpy as np
    import os

    # 저장할 배열 생성
    my_array_to_save = np.array([10, 20, 30, 40, 50])

    # .npy 파일로 저장
    np.save('my_data_array.npy', my_array_to_save)
    print("my_data_array.npy 파일이 저장되었습니다.")

    # 저장된 .npy 파일 불러오기
    loaded_array = np.load('my_data_array.npy')
    print("불러온 배열:", loaded_array)

    # 파일 삭제 (예제 실행 후 정리)
    if os.path.exists('my_data_array.npy'):
        os.remove('my_data_array.npy')
        print("my_data_array.npy 파일이 삭제되었습니다.")
  ```

  ```python
    import numpy as np
    import os

    # 저장할 배열 생성 (CSV는 보통 숫자 데이터에 사용)
    my_matrix_to_save = np.array([[1.1, 2.2, 3.3], [4.4, 5.5, 6.6]])

    # .csv 파일로 저장
    np.savetxt('my_matrix_data.csv', my_matrix_to_save, delimiter=',')
    print("my_matrix_data.csv 파일이 저장되었습니다.")

    # 저장된 .csv 파일 불러오기
    loaded_matrix = np.loadtxt('my_matrix_data.csv', delimiter=',')
    print("불러온 행렬:\n", loaded_matrix)
    
    # 파일 삭제 (예제 실행 후 정리)
    if os.path.exists('my_matrix_data.csv'):
        os.remove('my_matrix_data.csv')
        print("my_matrix_data.csv 파일이 삭제되었습니다.")
  ```

### 1.13 Numpy 확률분포함수

1. `np.random.randint(low, high, size)` \\
**정수 난수 생성** — 지정된 범위에서 **균등하게** 랜덤 정수 뽑기  
- `low` 이상, `high` 미만의 정수 중에서 선택  
- 예: `randint(1, 7)` → 주사위처럼 1~6 사이 정수  
- `size`로 배열 크기 지정 가능

2. `np.random.exponential(scale, size)` \\
**지수분포 난수** — **기다리는 시간**을 모델링할 때 사용  
- 주로 “이벤트가 다음으로 발생할 때까지의 시간”을 표현  
- `scale` = 평균 대기 시간 (1/λ)  
- 예: 고객이 도착하는 간격, 기계 고장 간격 등

3. `np.random.poisson(lam, size)` \\
**포아송분포 난수** — **단위 시간 내 발생 횟수**를 모델링  
- `lam` = 평균 발생 횟수 (예: 하루 평균 5건의 사고)  
- 예: 1시간 동안 전화 걸려오는 횟수, 웹사이트 방문자 수
- `exponential`은 “시간 간격”, `poisson`은 “횟수” → 서로 관련 있음!

4. `np.random.normal(loc, scale, size)` \\
**정규분포 난수** — **종 모양 분포**, 가장 흔함  
- `loc` = 평균 (μ), `scale` = 표준편차 (σ)  
- 예: 키, 시험 점수, 오차 등 자연계/사회계 현상

5. `np.random.uniform(low, high, size)` \\
**연속 균등분포 난수** — 범위 내 모든 실수가 **동일 확률**  
- `low` 이상, `high` 미만의 실수  
- 예: 0~1 사이 난수 생성 기본 (`low=0, high=1`)

6. `np.random.choice(a, size, replace, p)` \\
**리스트/배열에서 랜덤 선택** — 복권 뽑기처럼  
- `a`: 선택할 대상 리스트 (예: `[1,2,3,4,5]`)  
- `p`: 각 항목 선택 확률 (생략 시 균등)  
- `replace`: 중복 허용 여부 (True=복원추출)  
- 예: `choice(['A','B','C'], p=[0.5,0.3,0.2])`

7. `np.random.random()` \\
**연속 균등분포** - 0 이상 1 미만의 실수 난수를 생성하는 함수
- np.random.uniform(0, 1) 과 완전히 동일한 기능
- `size`로 크기 지정 가능

8. `np.random.randn()` \\
**표준 정규 분포** -  평균 0, 표준 편차 1에서 난수 생성
- 인자(d0, d1, ..., dn)은 차원수
- 인자를 지정하지 않으면 float 반환

9. `np.random.rand()` \\
**연속 균등분포** - 0 이상 1 미만의 실수 난수를 생성하는 함수
- np.random.rand(100, 3)  : 100개의 샘플, 3개의 특성
- np.random.rand(100)     : 100개의 타겟 값
- np.random.rand(5, 8, 8, 1) : 이미지 데이터,4차원(배치크기, 높이, 너비, 채널수)

**한 줄 요약**

| 함수 | 용도 | 특징 |
|------|------|------|
| `randint` | 정수 난수 | 균등, 정수만 |
| `exponential` | 대기 시간 | 지수분포, 양수만 |
| `poisson` | 발생 횟수 | 이산, 음수 X |
| `normal` | 일반적인 분포 | 종모양, 실수 |
| `uniform` | 실수 균등분포 | 모든 값 확률 같음 |
| `choice` | 리스트에서 뽑기 | 가중치/중복 조절 가능 |

헷갈릴 땐 이렇게 생각하세요:
- **숫자 뽑기?** → `randint`, `uniform`  
- **횟수?** → `poisson`  
- **시간?** → `exponential`  
- **일반적인 값?** → `normal`  
- **리스트에서 골라야 해?** → `choice`
