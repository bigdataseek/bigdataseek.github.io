---
title: 20차시 1:IBM TECH(API Essentials)
layout: single
classes: wide
categories:
  - API
toc: true # 이 포스트에서 목차를 활성화
toc_sticky: true # 목차를 고정할지 여부 (선택 사항)
---

## 1. API와 API 게이트웨이
- 출처: [What is an API Gateway?](https://www.youtube.com/watch?v=hWRRdICvMNs&list=PLOspHqNVtKAAAq9pHWlEiRUVcYMCcu4X0)

### 1.1 API란?

- **정의:** 애플리케이션 간의 통신을 가능하게 하는 소프트웨어 인터페이스 (Application Programming Interface)  
  - API는 서로 다른 애플리케이션이 데이터를 주고받거나 기능을 활용할 수 있도록 연결하는 중간자 역할을 합니다. 
  - 예를 들어, 소셜 미디어 계정으로 웹사이트에 로그인하거나, 모바일 앱에서 실시간 날씨 정보를 가져오는 경우 API가 사용됩니다.  
- **예시:** 인스타그램 사용, 항공권 가격 확인 등  
  - 인스타그램에서 사진을 업로드하거나 친구의 게시물을 확인할 때, 또는 항공권 가격 비교 사이트에서 여러 항공사의 데이터를 한 번에 조회할 때 API가 이를 가능하게 합니다. 이러한 예시는 API가 일상에서 얼마나 광범위하게 활용되는지를 보여줍니다.  
- **중요성:** 애플리케이션의 성패를 좌우하며, 보안, 확장, 속도 향상을 위한 추가 인프라 필요  
  - API는 애플리케이션의 핵심 요소로, 제대로 설계되고 관리되지 않으면 성능 저하, 보안 취약점, 사용자 경험 악화로 이어질 수 있습니다. 
  - 이를 방지하려면 보안 강화, 확장성 확보, 속도 최적화를 위한 추가적인 서버나 네트워크 인프라가 필수적입니다.

### 1.2 마이크로서비스 아키텍처와 API 증가

- **변화:** 기존의 monolithic 애플리케이션을 작은 마이크로서비스로 분할  
  - 과거 monolithic 아키텍처는 모든 기능을 하나의 거대한 애플리케이션에 통합했지만, 마이크로서비스 아키텍처는 이를 작은 단위의 독립적인 서비스로 나누어 개발, 배포, 확장을 개별적으로 관리할 수 있게 합니다.  
- **장점:** 애플리케이션의 확장성, 가용성, 효율성 향상  
  - 마이크로서비스는 특정 서비스에 대한 수요가 증가할 때 해당 부분만 확장할 수 있어 자원을 효율적으로 사용하며, 서비스 간 독립성 덕분에 한 서비스의 장애가 전체 시스템에 영향을 미치지 않아 가용성이 높아집니다.  
- **문제점:** 클라이언트와 마이크로서비스 간의 API 호출 증가, 보안 관리 필요  
  - 마이크로서비스 수가 많아지면 클라이언트가 호출해야 하는 API도 증가하여 네트워크 지연이나 복잡성이 커질 수 있습니다. 
  - 또한, 각 서비스마다 별도의 보안 관리가 필요해 보안 취약점 노출 위험이 증가합니다.

### 1.3 API 게이트웨이

- **역할:** 클라이언트와 마이크로서비스 사이에 위치하여 API 트래픽을 안전하게 관리  
  - API 게이트웨이는 클라이언트 요청을 받아 적절한 마이크로서비스로 전달하고, 응답을 다시 클라이언트에게 보내는 중개자 역할을 합니다. 
  - 이 과정에서 트래픽 모니터링, 보안 강화, 성능 최적화 등의 기능을 수행합니다.  
- **주요 이점:**  
  - **클라이언트 성능 향상:** API 요청을 통합하여 라우팅, 지연시간 감소, 왕복 횟수 감소  
    - 여러 API 호출을 하나의 요청으로 묶어 처리함으로써 클라이언트의 대기 시간을 줄이고, 네트워크 왕복 횟수를 줄여 응답 속도를 높입니다.  
  - **보안 강화:** DoS 공격 등 악성 공격으로부터 보호, 인증/인가 기능 추가  
    - DDoS 공격 같은 악의적인 트래픽을 차단하고, 사용자 인증 및 권한 부여를 처리하여 마이크로서비스를 안전하게 보호합니다.  
  - **프로토콜 변환:** 클라이언트-마이크로서비스 간 프로토콜 변환 (예: HTTPS -> HTTP), SSL 종료를 통한 성능 향상  
    - 클라이언트는 보안이 중요한 HTTPS로 요청하고, 내부 마이크로서비스는 부하를 줄이기 위해 HTTP로 처리할 수 있도록 프로토콜을 변환합니다. 
    - 또한 SSL 종료를 통해 암호화 작업을 게이트웨이에서 처리하여 마이크로서비스의 성능을 개선합니다.  
  - **공통 기능 오프로드:** rate limiting, API 모니터링, 로깅 등 공통 기능을 API 게이트웨이에서 처리하여 마이크로서비스 부담 감소  
    - 요청 속도 제한, 사용량 모니터링, 로그 기록 등의 공통 기능을 게이트웨이에서 처리함으로써 마이크로서비스는 핵심 비즈니스 로직에만 집중할 수 있습니다.

### 1.4 BFF (Back-end for Front-end) 아키텍처

- **개념:** 트래픽 급증 또는 기능 확장에 대비하여 추가 API 게이트웨이 도입  
  - BFF 아키텍처는 특정 클라이언트 유형(예: 웹, 모바일, 타사 API)에 특화된 API 게이트웨이를 별도로 두어 각 클라이언트의 요구 사항에 맞춘 최적화된 API를 제공합니다.  
- **적용:** 웹, 모바일, 타사 API 통합 등 각 클라이언트 유형에 맞는 API 게이트웨이 구축  
  - 예를 들어, 웹 클라이언트용, 모바일 앱용, 타사 서비스 통합용 API 게이트웨이를 각각 만들어 클라이언트별 특성에 맞는 API를 제공합니다.  
- **장점:** 트래픽 분산, 확장성 향상  
  - 클라이언트 유형별로 트래픽을 분산 처리함으로써 특정 클라이언트의 트래픽 급증이 다른 클라이언트에 영향을 미치지 않으며, 필요에 따라 개별 게이트웨이를 확장할 수 있어 유연성이 높아집니다.

### 5. SSL 종료 (SSL Termination)란?

- **설명:** API 게이트웨이에서 SSL 암호화 데이터를 해독하고 오프로드하는 프로세스  
  - SSL 종료는 클라이언트와 API 게이트웨이 간의 SSL/TLS 암호화 통신을 게이트웨이에서 처리한 뒤, 마이크로서비스와의 통신은 암호화 없이 진행하여 마이크로서비스의 부하를 줄이는 기술입니다. 
  - 이를 통해 마이크로서비스는 암호화/복호화 작업 없이 비즈니스 로직 처리에 집중할 수 있어 성능이 향상됩니다.

## 2. API 관리의 필요성
- 출처: [Why API Management?](https://www.youtube.com/watch?v=DBZTNzrZC3E&list=PLOspHqNVtKAAAq9pHWlEiRUVcYMCcu4X0&index=2)

### **2.1 API 개발 관련 용어**  

* **서비스 API (System of Record API)**  
  - 금융 거래, 고객 데이터 등 **핵심 비즈니스 로직**을 처리하는 API  
  - 예: 은행의 계좌 이체 API, ERP 시스템의 재고 관리 API  
  - **보안 요구사항:** PCI-DSS, GDPR 등 규정 준수 필수  

* **인터랙션 API (Experience API)**  
  - 사용자 경험(UX) 최적화를 위한 **추상화 계층**  
  - 예: 모바일 앱 전용 최적화 API, 멀티채널 통합 API  
  - **장점:** 프론트엔드와 백엔드의 **느슨한 결합** 가능  

### **2.2 API 관리의 3대 핵심 가치**  

1. **유연성 (Agility)**  
- **게이트웨이 중심 아키텍처**  
  - Kong, Apigee 등 게이트웨이가 API 호출의 **단일 진입점** 역할  
  - 라우팅, 버전 관리, 프로토콜 변환(예: REST → gRPC) 지원  
- **표준화 도구**  
  - OpenAPI/Swagger를 이용해 **계약 우선 설계(Contract-First Design)** 구현  
  - API 문서 자동 생성 및 Sandbox 테스트 환경 제공  
- **내부 혁신 가속화**  
  - 모놀리스 → 마이크로서비스 전환 시 **기존 클라이언트 영향도 제로**  
  - A/B 테스트, 카나리아 배포를 API 게이트웨이에서 통합 관리  

2. **보안 (Security)**  
- **정교한 접근 제어**  
  - OAuth 2.0, JWT를 활용한 **세분화된 권한 관리**  
  - 지역별 차단(Geo-Fencing), 이상 탐지(Anomaly Detection) 적용  
- **트래픽 제어**  
  - API Key별 **계층적 Rate Limiting** (예: 무료 계층 100회/분, 유료 계층 10,000회/분)  
  - DDoS 방어를 위한 **서킷 브레이커** 패턴 구현  
- **수익화 모델**  
  - Stripe 연동으로 **API 사용량 기반 과금** 시스템 구축  
  - 프리미엄 기능(예: 실시간 데이터)을 **유료 티어**로 제공  

3. **분석 (Observability)**  
- **실시간 모니터링**  
  - Prometheus, Grafana로 **P99 레이턴시**, 에러율 추적  
  - OpenTelemetry을 활용한 **분산 트레이싱**  
- **사용자 인사이트**  
  - **Heatmap 분석**으로 가장 활발한 API 엔드포인트 식별  
  - 사용자 행동 패턴(예: 주말 저녁 트래픽 폭증)에 따른 **자동 확장(Auto-Scaling)**  
- **데이터 기반 의사결정**  
  - 사용량이 낮은 API는 **태양계 모델(Solar System Model)** 적용해 폐기  
  - 개발자 포털 검색 로그 분석으로 **새로운 수요 예측**  

---

### **2.3 결론: API 관리의 진화 방향**  
API 관리는 이제 **"생산성 플랫폼"**으로 진화하고 있습니다.  
- **AI 연계:** 자연어로 API 생성(Copilot for APIs), 자동화된 스키마 추론  
- **멀티클라우드 지원:** AWS/Azure/GCP 간 **일관된 관리 정책** 적용  
- **Low-Code 통합:** API 관리 플랫폼과 MuleSoft 등의 **IPAAS(Integration Platform as a Service)** 융합  


## 3. REST API
- 출처: [REST API 란 무엇입니까?](https://www.youtube.com/watch?v=lsMQRaeKNDk&list=PLOspHqNVtKAAAq9pHWlEiRUVcYMCcu4X0&index=3)

### **3.1 REST API란?**

*   Representational State Transfer의 약자로, 업계 표준 소프트웨어 아키텍처 스타일입니다.  
    * Roy Fielding이 2000년 논문에서 처음 제안했으며, HTTP 프로토콜의 장점을 최대한 활용
*   클라이언트-서버 간의 통신을 위한 표준화 방식으로, 특정 플랫폼이나 언어에 종속되지 않는 범용적인 통신
*   REST API를 사용하는 웹 서비스를 "Restful 웹 서비스", REST 원칙을 잘 지켜 설계된 API를 의미

### **3.2 REST API의 장점**

1.  **단순하고 표준화된 통신 방식**  
    * HTTP 표준 프로토콜을 사용하므로, 데이터 형식(주로 JSON/XML)이나 요청 방식(GET/POST 등)을 매번 고민할 필요 없이 일관된 개발이 가능합니다.
    * 직관적인 리소스 기반 URL 구조로 개발자 친화적입니다.

2.  **확장 가능성 및 무상태성(Stateless)**  
    * 각 요청이 독립적으로 처리되므로 서버 확장이 용이합니다. (Scale-out에 유리)
    * 세션 정보를 저장할 필요가 없어 서버 부하가 감소하고 장애 복구가 간편합니다.

3.  **높은 성능**  
    * HTTP 캐싱 메커니즘을 활용할 수 있어 반복 요청 시 네트워크 트래픽이 감소합니다.
    * 클라이언트-서버 분리 아키텍처로 각 컴포넌트의 독립적인 진화가 가능합니다.

### **3.3 REST API의 기본 구성 요소**

*   **요청 (Request):**
    *   멱등성: 동일한 요청을 반복해도 서버의 상태가 한 번만 변경되는 것을 보장
    *   **HTTP 메서드 (동작):**
        *   POST: 리소스 생성 (멱등성 없음)
        *   GET: 리소스 조회 (안전한 메서드, 멱등성 있음)
        *   PUT: 전체 리소스 갱신 (멱등성 있음)
        *   PATCH: 부분 리소스 수정 (멱등성 없을 수 있음)
        *   DELETE: 리소스 삭제 (멱등성 있음)
    *   **엔드포인트 (Endpoint):**  
        * 일반적으로 `도메인/api/리소스명/{id}` 형태 (예: `icecream.com/api/flavors/1`)  
        * 버전 관리 시 `api/v1/flavors`처럼 표기하기도 함
    *   **파라미터:**  
        * 쿼리 파라미터(예: `?limit=10`), 경로 파라미터(예: `/flavors/1`) 구분
    *   **헤더:**  
        * `Content-Type`, `Authorization` 등 메타데이터 포함

*   **응답 (Response):**
    * 상태 코드 (예: 200 OK, 404 Not Found)
    * Body는 일반적으로 JSON 형식으로 반환
    * 페이징 처리 시 `next_cursor` 등의 링크 포함 가능

### **3.4 아이스크림 가게 예시**
*   **현재 재고 맛 표시 (GET):**
    *   요청: GET /api/flavors
    *   응답: `[{"name": "딸기"}, {"name": "민트초코"}]`
*   **민트초코 품절 -> 초코맛으로 변경 (PUT):**
    *   요청: PUT /api/flavors/1, 바디: `{"name": "초코"}`
    *   전체교체:다른 필드가 있는 경우 NULL로 초기화됨!
    *   응답: `{"id": 1, "name": "초코"}`   
*   **"RESTful 라즈베리" 신규 맛 추가 (POST):**
    *   요청: POST /api/flavors, 바디: `{"name": "RESTful 라즈베리"}`
    *   응답: `{"id": 2, "name": "RESTful 라즈베리"}`
*   **맛 정보 리소스의 일부 필드만 변경 (PATCH):**
    * 요청: `PATCH /api/flavors/1`, 바디: `{"price": 3500}`  


### **3.5 클라우드 애플리케이션 개발과의 연관성**  
* 마이크로서비스 아키텍처에서 서비스 간 통신의 기본 수단으로 사용  
* AWS API Gateway, Lambda 등 클라우드 서비스와의 연동에 최적화  
* Kubernetes 환경에서 Ingress와 조합해 서비스 노출에 활용


## 4. 기업이 API를 안전하고 효율적으로 관리하는 방법
- 출처: [API 관리 란 무엇입니까?](https://www.youtube.com/watch?v=fh3VaXLzH5Y&list=PLOspHqNVtKAAAq9pHWlEiRUVcYMCcu4X0&index=4)

### **4.1 API 관리란?**

*   기업 및 멀티 클라우드 환경에서 API를 구축, 게시, 관리하는 프로세스
*   API를 저장하는 장소 그 이상으로, 중앙 집중식으로 관리하고 확장 가능한 플랫폼 제공
*   API 공유 및 소통을 활성화하고, 접근 제어, 사용량 통계 수집, 보안 정책 적용을 보장

### **4.2 API란? (레스토랑 비유)**

*   **주방:** 애플리케이션 또는 서비스
*   **메뉴:** API 정의 (어떤 기능을 사용할 수 있는지)
*   **웨이터:** API (애플리케이션과 상호 작용하는 방식, 복잡성을 이해할 필요 없이 기능 사용)
*   **손님:** 사용자 (API를 통해 요청하고 응답 받음)
*   **특징:** API는 정보 제공 가능 (레스토랑에서 손님이 재료를 제공하여 요리에 영향을 줄 수 있는 것처럼)

### **4.3 API 활용 예시 (쇼핑 애플리케이션)**

*   **백엔드 서비스:**
    *   연락처 정보 데이터베이스
    *   재고 데이터베이스
*   **프론트엔드 서비스:**
    *   장바구니 (재고 API 사용)
    *   결제 (연락처 정보, 재고 API 모두 사용)
    *   리뷰 (연락처 정보 API만 사용)
*   각 서비스는 백엔드 서비스의 정보를 변환하여 자체 API를 통해 노출 (퍼블릭 API)
*   백엔드 서비스 자체를 퍼블릭 API로 노출 가능 (예: 연락처 정보 변경 API)

### **4.4 API 관리 시스템의 4가지 핵심 요소**

1.  **API 게이트웨이:**
    *   웹 클라이언트와 시스템/서비스 사이에 위치
    *   요청 라우팅, 데이터 합성, 프로토콜 변환 처리
    *   보안 인증 및 권한 부여 (OAuth, OpenID, JWT 등 최신 보안 기술 사용)
    *   데이터 집계 (웹 클라이언트의 요청을 받아 여러 서비스와 통신 후 하나의 응답으로 반환)
2.  **개발자 포털:**
    *   개발자가 API 문서 탐색, 접근, 공유 가능한 셀프 서비스 허브
    *   API 정의 (메뉴)의 메뉴 역할
    *   팀 간 커뮤니케이션 간소화, 출시 시간 단축, 개발 비용 절감
    *   수백, 수천 개의 API에 대한 중앙 집중식 접근 제공
3.  **API 라이프사이클 관리자:**
    *   API를 빌딩 블록으로 간주
    *   API 구축, 테스트, 온보딩, 관리, 폐기 지원
    *   각 단계에서 API 관리 및 적절한 버전 관리 보장
4.  **보고 및 분석:**
    *   API 가용성, 응답 시간, 전반적인 상태를 모니터링
    *   자동 기록 및 분석 솔루션 통합
    *   통합 문제 진단 및 해결
    *   애플리케이션 및 서비스에 대한 정보에 입각한 의사 결정 지원

### **4.5 실제 시나리오**

*   **은행 모바일 앱 로그인:**
    *   통신 회사가 전화번호 인증 API를 구축하여 수익 창출
    *   API 관리 시스템의 보고 기능을 통해 API 사용 현황 파악, 가격 책정, 수익 확보
*   **차량 공유 앱 (NoSQL 데이터베이스 사용):**
    *   개발자 포털을 통해 차량, 여정, 시간 슬롯 등 객체 정의 및 관계 명확화
    *   NoSQL 데이터베이스의 유연성 및 확장성 활용 + 관계형 데이터베이스의 제어력 확보
    *   데이터 쿼리 성능 향상
*   **은행의 제3자 상품/서비스 제공:**
    *   API 게이트웨이를 통해 접근 및 보안 중앙 집중화
    *   통합 로그인 경험 제공
    *   고객 동의하에 제3자에게 정보 공유
    *   높은 보안 표준 유지


## 5. REST API와 OpenAPI의 관계
- 출처: [REST API 및 OpenAPI : 양자 택일이 아닙니다](https://www.youtube.com/watch?v=pRS9LRBgjYg&list=PLOspHqNVtKAAAq9pHWlEiRUVcYMCcu4X0&index=5)


### **5.1 문제 상황 심층 분석**

* 신규 개발자 Mark는 기존 REST API 기반 아이스크림 재고 관리 웹 앱의 복잡성을 마주하게 됩니다.
    * 다양한 엔드포인트, 요청/응답 형식, 인증 방식 등이 복잡하게 얽혀 있어 코드 분석에 많은 시간과 노력이 필요합니다.
    * 특히, API 변경 이력이나 최신 업데이트 정보를 파악하기 어려워 유지보수에 어려움
* API 문서가 없거나 불완전한 경우, Mark는 API 개발자와 지속적인 소통을 해야 하며, 이 과정에서 시간 낭비와 오해가 발생할 수 있습니다.

### **5.2 OpenAPI의 역할 확장**

* OpenAPI 정의는 REST API의 기능과 사용법을 명확하게 설명하는 것뿐만 아니라, 다음과 같은 추가적인 역할을 수행합니다.
    * API의 명세서로서, 개발 팀 내 커뮤니케이션을 원활하게 하고 협업 효율성을 높입니다.
    * API 테스트 자동화 도구와의 연동을 통해 API의 안정성과 신뢰성을 확보합니다.
    * API 게이트웨이와의 연동을 통해 API 관리 및 보안 정책 적용을 용이하게 합니다.
* Mark는 OpenAPI 정의 파일을 통해 API의 전체적인 구조와 흐름을 빠르게 파악하고, 필요한 정보를 쉽게 얻을 수 있습니다.

### **5.3 OpenAPI 심층 이해:**

* **OpenAPI Specification:**
    * REST API의 엔드포인트, 요청/응답 형식, 인증 방식, 오류 코드 등을 정의하는 표준 명세입니다.
    * 다양한 프로그래밍 언어와 도구에서 지원되므로, 플랫폼에 독립적으로 API를 개발하고 관리
* **OpenAPI Definition:**
    * OpenAPI Specification에 따라 작성된 파일은 API의 기능과 사용법을 명확하게 정의하는 문서 역할
    * YAML, JSON 형식으로 작성되어 사람이 읽고 이해하기 쉽고, 기계가 파싱하여 다양한 작업을 수행

### **5.4 OpenAPI 사용의 이점 심화**

* **표준화된 형식:**
    * API 문서의 일관성을 유지하고, 개발 팀 간의 협업 효율성을 높입니다.
    * 다양한 도구와의 호환성을 확보하여 API 개발 및 관리 비용을 절감합니다.
* **가이드라인 제공:**
    * API 사용자에게 명확하고 상세한 사용법을 제공하여 API 활용도를 높입니다.
    * API 오류 발생 시 문제 해결을 위한 정보를 제공하여 개발 생산성을 향상시킵니다.
* **REST API 확장:**
    * OpenAPI 정의를 활용하여 API 문서 자동 생성, 클라이언트 SDK 자동 생성, API 테스트 자동화 등 다양한 작업을 수행할 수 있습니다.
    * API 관리 플랫폼과의 연동을 통해 API 보안, 성능 모니터링, 버전 관리 등을 효율적으로 수행

### **5.5 OpenAPI 정의 파일 예시 상세 분석 (icecream.yaml)**

* **기본 API 정보:**
    * API 제목, 설명, 연락처 정보, 라이선스 정보 등을 포함하여 API에 대한 전반적인 정보를 제공합니다.
* **API 요청 설명:**
    * 각 엔드포인트별로 요청 파라미터, 요청 헤더, 요청 본문 등을 상세하게 정의하여 API 요청 방식을 명확하게 설명합니다.
* **API 응답 설명:**
    * 각 응답 코드별로 응답 본문, 응답 헤더 등을 상세하게 정의하여 API 응답 형식을 명확하게 설명합니다.
* **응답 예시:**
    * 실제 응답 데이터를 샘플로 제공하여 API 사용자가 응답 형식을 쉽게 이해하고 활용할 수 있도록 돕습니다.

### 5.6 icecream.yaml 샘플

* 다음은 `icecream.yaml` 파일의 간단한 샘플 예시입니다. 이 예시는 아이스크림 맛 목록을 조회하고, 특정 아이스크림 맛의 정보를 조회하는 API를 정의합니다.

```yaml
openapi: 3.0.0
info:
  title: 아이스크림 재고 관리 API
  version: 1.0.0
paths:
  /flavors:
    get:
      summary: 모든 아이스크림 맛 목록 조회
      responses:
        '200':
          description: 성공적인 응답
          content:
            application/json:
              schema:
                type: array
                items:
                  type: object
                  properties:
                    id:
                      type: integer
                      description: 아이스크림 맛 ID
                    name:
                      type: string
                      description: 아이스크림 맛 이름
                    stock:
                      type: integer
                      description: 남은 재고 수량
  /flavors/{flavorId}:
    get:
      summary: 특정 아이스크림 맛 정보 조회
      parameters:
        - name: flavorId
          in: path
          required: true
          schema:
            type: integer
            description: 조회할 아이스크림 맛 ID
      responses:
        '200':
          description: 성공적인 응답
          content:
            application/json:
              schema:
                type: object
                properties:
                  id:
                    type: integer
                    description: 아이스크림 맛 ID
                  name:
                    type: string
                    description: 아이스크림 맛 이름
                  stock:
                    type: integer
                    description: 남은 재고 수량
        '404':
          description: 아이스크림 맛을 찾을 수 없음
```

**주요 내용 설명:**

* **openapi:** OpenAPI 버전 정의 (3.0.0)
* **info:** API 기본 정보 (제목, 버전)
* **paths:** API 엔드포인트 정의
    * `/flavors`: 모든 아이스크림 맛 목록 조회 엔드포인트
        * `get`: GET 메소드 정의
        * `responses`: 응답 코드 정의
            * `200`: 성공적인 응답 (JSON 형식의 아이스크림 맛 목록 반환)
    * `/flavors/{flavorId}`: 특정 아이스크림 맛 정보 조회 엔드포인트
        * `get`: GET 메소드 정의
        * `parameters`: 경로 매개변수 정의 (flavorId)
        * `responses`: 응답 코드 정의
            * `200`: 성공적인 응답 (JSON 형식의 아이스크림 맛 정보 반환)
            * `404`: 아이스크림 맛을 찾을 수 없음


## 6. API와 SDK 
- 출처: [API vs. SDK : 차이점은 무엇입니까?](https://www.youtube.com/watch?v=kG-fLp9BTRo&list=PLOspHqNVtKAAAq9pHWlEiRUVcYMCcu4X0&index=6)

### 6.1 동물병원 모바일 앱 개발 예시 심층 분석

* **구체적인 시나리오:**
    * 동물병원 접수 직원은 모바일 앱을 통해 반려동물의 사진을 촬영하고, 클라우드 기반 시각 인식 서비스에 전송합니다.
    * 시각 인식 서비스는 사진을 분석하여 반려동물의 종류, 이름, 특징 등을 인식하고, 해당 정보를 모바일 앱에 반환합니다.
    * 이 과정에서 모바일 앱은 클라우드 서비스와 데이터를 주고받아야 합니다.
* **핵심 질문 확장:**
    * 모바일 앱은 어떤 방식으로 클라우드 서비스에 사진 데이터를 전송하고, 인식 결과를 받아올 수 있을까?
    * 데이터 전송 과정에서 보안 및 성능 문제는 어떻게 해결해야 할까요?
    * 다양한 모바일 플랫폼(iOS, Android)에서 일관된 방식으로 클라우드 서비스를 사용할 수 있을까요?

### 6.2 API (Application Programming Interface) 심층 이해

* **정의 확장:**
    * API는 소프트웨어 애플리케이션들이 서로 상호작용할 수 있도록 정의된 규칙의 집합입니다.
    * API는 애플리케이션 간의 데이터 교환, 기능 호출, 서비스 연동 등을 가능하게 합니다.
* **역할 확장:**
    * API는 클라우드 서비스의 기능을 모바일 앱과 같은 외부 애플리케이션에서 사용할 수 있도록 공개하는 역할을 합니다.
    * API는 클라이언트-서버 아키텍처에서 클라이언트와 서버 간의 통신을 담당합니다.
* **특징 심층 분석:**
    * **통신:** API는 요청과 응답이라는 두 가지 주요 메시지 형식을 통해 애플리케이션 간의 통신을 지원
    * **추상화:** API는 복잡한 내부 로직을 숨기고, 필요한 데이터와 기능만 노출하여 개발자가 서비스 내부 구현에 대한 지식 없이도 서비스를 사용할 수 있도록 합니다.
    * **표준화:** REST, SOAP, GraphQL 등과 같은 표준화된 API 아키텍처는 다양한 플랫폼과 언어 간의 호환성을 높이고 개발 효율성을 향상시킵니다.
* **REST API 구성 요소 심층 분석:**
    * **요청 (Request):**
        * **Operation (HTTP 메서드):** POST, PUT, GET, DELETE 등 다양한 HTTP 메서드는 API의 기능을 정의합니다. 예를 들어, POST는 데이터 생성, GET은 데이터 조회, PUT은 데이터 수정, DELETE는 데이터 삭제에 사용됩니다.
        * **Parameters:** API 요청에 필요한 추가 정보를 전달합니다. 예를 들어, 파일 이름, 검색어, 페이지 번호 등이 매개변수로 사용될 수 있습니다.
        * **Endpoint:** API 엔드포인트는 API 서버의 주소와 API 기능을 식별하는 경로를 포함합니다.
    * **응답 (Response):**
        * API 응답은 일반적으로 JSON 또는 XML 형식의 데이터를 포함하며, 요청 결과와 필요한 정보를 클라이언트에게 전달합니다.

### 6.3 SDK (Software Development Kit) 심층 이해

* **정의 확장:**
    * SDK는 특정 플랫폼 또는 서비스에 대한 애플리케이션 개발을 지원하는 도구, 라이브러리, 문서의 모음
    * SDK는 API 호출을 간소화, 개발자가 특정 플랫폼 또는 서비스의 기능을 쉽게 사용할 수 있도록 지원합니다.
* **역할 확장:**
    * SDK는 API 사용을 위한 코드 라이브러리, 샘플 코드, 문서 등을 제공하여 개발자가 API를 직접 구현하는 데 필요한 시간과 노력을 줄여줍니다.
    * SDK는 API 호출 과정에서 발생하는 오류 처리, 데이터 변환, 인증 등의 복잡한 작업을 자동화하여 개발 생산성을 향상시킵니다.
* **특징 심층 분석:**
    * SDK는 특정 프로그래밍 언어 또는 플랫폼에 최적화된 도구와 라이브러리를 제공하여 개발자가 효율적으로 애플리케이션을 개발할 수 있도록 지원합니다.
    * SDK는 API 문서, 샘플 코드, 튜토리얼 등을 제공하여 개발자가 API 사용법을 쉽게 이해하고 적용할 수 있도록 돕습니다.
* **예시 확장:**
    * 모바일 앱 개발자는 Java SDK를 사용하여 클라우드 시각 인식 API를 호출하고, 인식 결과를 Java 객체로 쉽게 처리할 수 있습니다.
    * SDK는 API 요청 생성, 데이터 변환, 오류 처리 등의 복잡한 작업을 자동화하여 개발자가 비즈니스 로직에 집중할 수 있도록 지원합니다.

### 6.4 API와 SDK의 관계

| 구분 | API                                       | SDK                                                  |
| ---- | ----------------------------------------- | ---------------------------------------------------- |
| 역할 | 앱/서비스 간 통신 규약                   | API를 더 쉽게 사용할 수 있도록 돕는 도구 모음, 코드 라이브러리 |
| 사용 | 직접 요청/응답 처리 (Raw Data 처리 필요) | SDK를 통해 간편하게 API 호출 및 데이터 처리          |

### 6.5 API 및 SDK 활용 효과

*   클라우드 앱 개발 워크플로우 간소화
*   개발자는 복잡한 API 요청/응답 처리 대신 비즈니스 로직에 집중 가능
*   생산성 향상


## 7. 클라우드 API 솔루션 아키텍처
- 출처: [Architecting a Cloud Native API Solution](https://www.youtube.com/watch?v=sKfep-UmZeM&list=PLOspHqNVtKAAAq9pHWlEiRUVcYMCcu4X0&index=7)

### **7.1 코드로서의 인프라(Infrastructure as Code, IaC)**

코드로서의 인프라는 인프라 설정을 코드 형태로 정의하고, 이를 통해 자동화 및 일관성을 유지하는 방식입니다. 이를 활용하면 인프라 구축 및 관리가 보다 체계적으로 이루어질 수 있으며, 변경 사항이 쉽게 추적 가능합니다.

1. **소스 컨트롤 (Artifact Repository) 활용**
* **주요 도구:** Git (가장 널리 사용되는 분산 버전 관리 시스템)
* **저장 대상:** 시스템 구축과 관련된 모든 구성 요소를 저장 및 관리
    * **서버 설정 파일:** 개발(Dev), 테스트(Test), 프로덕션(Production) 환경별 설정 파일 포함
    * **API 정의 파일:** API 1, API 2, API 3 등의 주요 API 사양 문서 및 스키마 정의
    * **Pipeline 빌드 관련 파일:** CI/CD 작업을 자동화하는 스크립트 및 실행 파일

2. **코드로서의 인프라 장점**
* 인프라를 코드로 정의하여 **일관성 유지** 및 **자동화** 가능
* **가시성 확보 및 협업 강화:** 변경 사항을 명확히 추적하고 팀 간 협업이 쉬워짐
* **시스템 오류 발생 시 복구 용이:** 인프라 설정이 코드로 정의되어 있어 간단한 롤백 및 재구축 가능

### **7.2 Kubernetes 클러스터 기반 환경 구축**

Kubernetes는 컨테이너화된 애플리케이션을 자동으로 배포하고 관리하는 오픈소스 플랫폼입니다. API 배포 시 Kubernetes 클러스터를 활용하면 안정성과 확장성을 확보할 수 있습니다.

1. **클러스터의 물리적 자원**
* **노드(Node):** CPU, 메모리(Memory), 디스크 저장 공간(Disk Space) 등의 물리적 자원으로 구성됨

2. **개발 환경 (Dev Environment)에서의 활용**
* 개발자는 새로운 API (예: API 4)를 개발하고 이를 Kubernetes 클러스터에서 실행
* API 4 개발이 완료되면 CI/CD Pipeline이 빌드를 자동으로 트리거하여 테스트 및 배포 진행

### **7.3 Pipeline 빌드를 통한 API 배포**

CI/CD Pipeline을 활용하면 코드 변경 사항이 자동으로 반영되며, 테스트 및 배포가 신속하게 이루어집니다.

1. **배포 트리거 방식**
* 개발자가 API 정의 파일을 소스 컨트롤(Git 등)에 푸시하면 Web Hook이 작동하여 자동으로 Pipeline 실행

2. **Pipeline Task 예시**
* **Test 환경 구축**  
  - Kubernetes 클러스터 내에서 테스트 환경(Test Environment) 존재 여부 확인 후 필요 시 자동 구축  
  - Test 서버 설정 파일을 기반으로 환경 구성 
* **API 배포 및 테스트 수행**  
  - API 4를 테스트 환경에 배포  
  - 테스트 Suite 실행을 통해 API 정상 동작 여부 확인

3. **자동화된 배포 프로세스**
* **개발 -> 테스트 환경 자동 배포:** 개발자가 코드 변경 사항을 푸시하면, 미리 정의된 Pipeline에 따라 API가 자동으로 테스트 환경으로 승격됨
* **배포 속도 향상 및 운영 부담 감소:** 수작업 없이 자동으로 테스트 및 검증 가능


### **7.4 안정적인 프로덕션 배포 전략: Canary 배포**

Canary 배포는 신규 API를 점진적으로 릴리스하여 안정성을 검증하는 방식입니다.

1. **Canary 환경 구축**
* **Canary 환경:** 기존 프로덕션 환경과 동일한 복제본을 생성 (API 1, 2, 3 포함)
* Canary 배포는 **실제 사용자 트래픽의 일부만 신규 API에 할당**하여 운영 안정성을 보장함

2. **Canary 배포 과정**
* **사용자 요청(End User Call) → Gateway → Load Balancer**
* **Load Balancer:** 전체 트래픽 중 일부(예: 1%)를 Canary 환경으로 라우팅, 나머지는 기존 프로덕션 환경 유지
* **API 4 검증:** Canary 환경에서 실 트래픽을 활용한 테스트를 수행 후 안정성이 입증되면 전체 배포 진행

### **7.5 로깅 및 메트릭 수집**

시스템의 성능 및 안정성을 유지하기 위해 **로깅(logging) 및 메트릭(metric) 수집**이 필수적입니다.

1. **활용 기술**
* **Prometheus:** 시계열(time-series) 데이터 수집 및 모니터링
* **Grafana:** 메트릭을 시각화하여 대시보드로 제공 (그래프, 경고 시스템 등)

2. **로깅 및 메트릭 활용 대상**
* **비즈니스 분석가 (Business Analyst):** API 사용 패턴 및 성능 데이터 기반 비즈니스 인사이트 확보
* **운영 관리자 (Operations Manager):** 시스템 장애 분석 및 성능 최적화
* **아키텍트 (Architect):** 전체 시스템의 구조 설계 및 성능 튜닝에 활용

### **7.6 Kubernetes vs. OpenShift**

Kubernetes와 OpenShift는 모두 컨테이너 오케스트레이션을 위한 플랫폼이지만, 제공하는 기능과 운영 방식에서 차이가 있습니다.

1. **Kubernetes의 특징**
* 컨테이너 오케스트레이션을 위한 표준 플랫폼
* 기본적으로 Load Balancer, CI/CD Pipeline, 모니터링 도구(Prometheus, Grafana) 등을 별도로 설치해야 함

2. **OpenShift의 특징**
* Kubernetes 기반의 엔터프라이즈급 플랫폼
* **Pipeline 도구, 로깅/메트릭 시스템, RBAC(역할 기반 접근 제어) 등 기본 제공**
* 보안 및 접근 제어 기능이 강화되어 기업 환경에서 선호됨

### **7.7 결론 및 장점**

* **코드로서의 인프라(IaC) 도입:** 협업 강화, 가시성 확보, 신속한 시스템 복구 가능
* **API 배포 속도 향상 및 리스크 최소화:** 개발 → 테스트 → Canary → 프로덕션 단계별 자동화 및 안정성 검증
* **모니터링 및 로깅을 통한 운영 최적화:** 실시간 성능 분석 및 장애 대응 능력 강화

## 8. API 활용 사례
- 출처: [Top API Use Cases](https://www.youtube.com/watch?v=hFRpTVZpz8M&list=PLOspHqNVtKAAAq9pHWlEiRUVcYMCcu4X0&index=8)

### **8.1 접근 방식**  

1. **단순한 활용 사례부터 시작**  
- API 도입 초기에는 복잡한 기술적 요소를 한꺼번에 적용하기보다, 비교적 단순한 활용 사례를 먼저 적용하고 점진적으로 발전시키는 방식이 효과적이다. 
- 예를 들어, 기존 데이터를 API로 노출하는 간단한 단계에서 시작하여, 이후에는 자동화, 개인화, 파트너십 확장 등으로 발전할 수 있다.

2. **방법론 제시**  
- API를 통해 비즈니스 가치를 극대화할 수 있는 주요 활용 영역을 6가지로 정리하여 제시한다. 각 활용 방식은 기업의 기존 인프라와 시장 환경에 따라 차별화된 전략을 적용할 수 있다.

### **8.2 API 활용 방법론 6가지**  
1. **모바일/내부 개발**  
모바일 애플리케이션이나 내부 시스템에서 API를 활용하여 효율성을 증대하고 고객 경험을 개선
- **일반 정보 제공:**  
  - 모든 사용자에게 동일한 데이터를 제공하는 방식. 
  - 예를 들어, 금융권에서는 API를 통해 실시간 환율 정보를 제공하거나, 이커머스 기업은 상품 목록과 가격 정보를 노출할 수 있다.
- **개인화된 정보 제공:**  
  - 고객 맞춤형 정보를 API로 제공하여 개인화된 경험을 극대화할 수 있다. 
  - 예를 들어, 금융권에서는 계좌 잔액이나 거래 내역을 API로 제공하고, 이커머스에서는 고객의 최근 주문 상태를 조회할 수 있도록 한다.
- **모바일 기기 기능 활용:**  
  - 스마트폰의 GPS, 카메라, 센서 등을 API와 결합하여 새로운 서비스 모델을 개발할 수 있다. 
  - 예를 들어, 사용자가 모바일 앱을 통해 자신의 위치를 기반으로 가까운 매장을 검색하거나, 카메라를 이용해 상품 바코드를 스캔하여 정보를 조회하는 기능을 구현할 수 있다.

2. **파트너십 (B2B 연계)**  
기업 간 협업을 촉진하고, API를 통해 효율적인 데이터 공유 및 서비스 통합을 가능하게 한다.
- **기존 파트너와의 정보 공유 최적화:**  
  - 기존에 수작업으로 이루어지던 데이터 교환 과정을 API 기반으로 자동화하여 운영 효율성 제고
  - 예를 들어, 물류 업체와 온라인 쇼핑몰 간의 실시간 재고 및 배송 정보 공유가 가능하다.
- **파트너 온보딩 간소화:**  
  - 새로운 파트너사가 기존 시스템과 쉽게 연동할 수 있도록 API 문서화 및 개발자 포털을 제공한다. 
  - 예를 들어, 금융권에서는 외부 핀테크 업체들이 은행 API를 활용해 대출 심사 진행을 지원
3. **대외 공개 (Public API 활용)**  
API를 외부 개발자나 제3자 서비스에 공개하여 새로운 비즈니스 기회를 창출한다.
- **비교 서비스와의 연계:**  
  - 자사 제품, 가격, 가용성을 API를 통해 제공하여 가격 비교 사이트나 리뷰 플랫폼에서 자사의 경쟁력 제고
  - 예를 들어, 여행업계에서는 항공권 및 호텔 예약 API를 공개하여 다양한 플랫폼에서 검색할 수 있도록 한다.
- **인접 산업과의 협업:**  
  - API를 통해 다른 산업과의 연계를 확대하여 고객 기반을 확장할 수 있다. 
  - 예를 들어, 자동차 구매자에게 자동차 대출 API를 제공하여 금융권과 자동차 판매업체 간의 협업을 강화
4. **소셜 미디어 연계**  
API를 활용하여 소셜 미디어에서의 브랜드 관리 및 고객 참여도를 높인다.
- **실시간 브랜드 언급 모니터링 및 대응:**  
  - API를 활용해 소셜 미디어에서 기업 및 제품에 대한 긍정적 또는 부정적 언급을 실시간으로 모니터링하고, 필요 시 즉각적인 대응을 할 수 있다.
- **키워드 기반 고객 인사이트 확보:**  
  - 특정 키워드에 대한 언급을 분석하여 고객의 관심사를 파악하고, 맞춤형 콘텐츠 또는 프로모션을 제공할 수 있다.
- **커뮤니티 및 인플루언서와의 연계:**  
  - API를 통해 소셜 미디어 플랫폼에서 브랜드 콘텐츠를 공유하고, 인플루언서 또는 커뮤니티와 협력하여 브랜드 인지도를 높일 수 있다.
5. **기기 통합 (IoT 및 하드웨어 연계)**  
다양한 물리적 기기와 API를 연동하여 서비스 혁신을 이끌어낼 수 있다.
- **ATM, IoT 디바이스, 자동차 센서 등의 활용:**  
  - API를 통해 ATM 위치를 제공하거나, 자동차 센서를 활용한 사고 감지 시스템을 구축하는 등의 사례가 있다.
- **스마트홈 및 웨어러블 기기 연동:**  
  - API를 활용하여 스마트홈 기기나 헬스케어 기기와 데이터를 연동할 수 있다. 
  - 예를 들어, 헬스케어 앱이 스마트워치 데이터를 분석하여 건강 관리 조언을 제공하는 방식이 가능하다.
6. **가치 있는 데이터 활용 (데이터 경제화)**  
데이터를 수집하고 가공하여 내부적으로 활용하거나, 새로운 비즈니스 모델을 구축할 수 있다.
- **내부 데이터 활용 극대화:**  
  - 기업 내부에서 데이터를 보다 쉽게 접근할 수 있도록 API를 제공하고, 이를 기반으로 데이터 분석 및 의사 결정을 최적화할 수 있다.
- **데이터 상품화:**  
  - 익명화된 데이터를 제3자와 공유하거나 판매하여 새로운 수익원을 창출할 수 있다. 
  - 예를 들어, 교통 정보 API를 통해 실시간 도로 상황 데이터를 제공하거나, 소비자 구매 패턴 데이터를 광고주에게 제공하는 방식이 있다.

### **8.3 활용 사례 예시**  

| 활용 영역 | 활용 사례 |
|---|---|
| **모바일/내부 개발** | 계좌 정보 조회, 맞춤형 금융 상품 추천 |
| **파트너십** | 공급망 데이터 공유, 물류 배송 API |
| **대외 공개** | 가격 비교 사이트와 연계, 여행업 API |
| **소셜 미디어** | 실시간 고객 피드백 분석, 소셜 리스닝 |
| **기기 통합** | 자동차 사고 감지, ATM 위치 공유 |
| **가치 있는 데이터** | 마케팅 데이터 분석, 실시간 교통 데이터 |

### **8.4 고급 활용 시나리오 (에코시스템 구축)**  
API를 활용하여 산업 간 협업을 촉진하고, 복합적인 서비스 제공이 가능하다.

- **사고 발생 시 자동화 프로세스:**  
  자동차 사고 발생 시, 차량 센서 API를 통해 자동으로 긴급 신고, 보험 접수, 교통 정보 업데이트가 이루어짐.

- **기차 지연 시 맞춤형 서비스 제공:**  
  지연 정보를 기반으로 ATM에서 고객의 기호에 맞는 할인 쿠폰 제공.

- **기후 변화 대응 솔루션:**  
  날씨 API를 기반으로 폭풍 경로 예측, 맞춤형 대피 계획 및 교통 안내 제공.

## 9. API, 서비스, 마이크로서비스의 차이점
- 출처: [What's the Difference Between APIs, Services and Microservices?](https://www.youtube.com/watch?v=qGFRbOq4fmQ&list=PLOspHqNVtKAAAq9pHWlEiRUVcYMCcu4X0&index=9)

### **9.1 API (Business API/Web API)**

*   **정의:** 기업의 비즈니스 자산을 앱 개발자나 다른 시스템이 Self-service 방식으로 접근할 수 있도록 패키징하여 제공하는 인터페이스.  
*   **역할:** 애플리케이션과 서비스 간의 연결을 간소화하고, 다양한 플랫폼에서 쉽게 활용할 수 있도록 지원.  
*   **목표:** 비즈니스 자산을 안전하게 노출하고, 개발자 및 외부 소비자의 활용을 촉진하여 더 많은 서비스 및 시장 기회를 창출.


### **9.2 서비스 (Service-Oriented Architecture, SOA)**

*   **정의:** 특정 비즈니스 기능(예: 고객 신용 확인, 계좌 개설 등)을 캡슐화하여 재사용할 수 있도록 만든 독립적인 소프트웨어 구성 요소.  
*   **기술적 흐름:**  
    - **과거:** 주로 SOAP(Simple Object Access Protocol) 기반의 통신을 사용.  
    - **현재:** RESTful 서비스와 같은 보다 가벼운 프로토콜도 활용.  
*   **목표:** 비즈니스 로직을 모듈화하여 재사용성을 극대화하고, 기업 내부 및 외부 시스템 간의 연결을 원활하게 하는 것.


### **9.3 API와 서비스의 공통점 및 차이점**

1. 공통점
*   둘 다 서로 다른 시스템을 연결하고, 통합을 원활하게 하는 역할을 수행.  
*   재사용성과 확장성을 고려하여 설계됨.  

2. 차이점  

| 구분               | 서비스 (SOA)                                                                      | API (Web API)                                                                        |
|-------------------|---------------------------------------------------------------------------------|--------------------------------------------------------------------------------------|
| **주요 초점**      | 내부 시스템 간의 연결 및 재사용                                                  | 외부 소비자(개발자 포함) 중심의 빠른 접근 및 제공                                      |
| **목표**          | 엔터프라이즈 내 서비스 재사용 극대화, 단일 뷰(고객, 계정 등) 제공                 | 외부 개발자 및 파트너가 쉽게 활용하도록 지원하여 새로운 시장 개척                         |
| **대상**          | 내부 사용자 및 제한된 파트너 (보안과 교육 필요)                                    | 내부 개발자뿐만 아니라 대규모 외부 개발자 커뮤니티 대상                                |
| **중점 사항**      | 효율성 및 비용 절감, 안정성, 변경 최소화                                          | 학습 용이성, 속도, 사용 편의성 (Less to Learn)                                        |
| **기반 시스템**    | 시스템 오브 레코드 (System of Record), 엔터프라이즈 서비스 버스 (ESB) 사용          | 시스템 오브 레코드 기반 서비스 활용, API Gateway를 통한 관리                          |
| **변화 속도**      | 느림 (높은 보안 및 거버넌스 필요)                                                 | 빠름 (시장 변화에 신속 대응)                                                          |
| **방향성**        | 공급자 중심 (Provider-oriented)                                                  | 소비자 중심 (Consumer-focused)                                                      |
| **통합 방식**      | 엔터프라이즈 시스템 간의 강력한 통합이 필요                                        | 경량화된 API 호출을 통해 빠르고 유연한 연동 가능                                      |
| **주요 고려 사항** | 연결성, 재사용, 보안                                                              | Self-service 소비, 성능, 확장성                                                       |
| **거버넌스**      | 강력한 거버넌스 필요 (변경이 적음)                                                 | 빠른 속도를 위해 최소한의 거버넌스 적용                                               |

### **9.4 API와 서비스의 협력 관계**
*   API는 내부 서비스(예: SOA 기반 서비스)를 외부 개발자가 쉽게 접근할 수 있도록 래핑(Wrapping)하여 제공.  
*   API는 기존 서비스의 변경과 독립적으로 빠르게 생성 및 수정 가능.  
*   API를 활용하면 Self-service 방식으로 내부 및 외부 개발자가 필요할 때 쉽게 사용할 수 있음.


### **9.5 좋은 API 설계를 위한 3가지 핵심 질문**
1.  **대상은 누구인가?**  
    - 내부 사용자, 파트너, 일반 소비자 등 API의 주요 사용자를 정의해야 함.  
2.  **그들은 무엇을 원하는가?**  
    - API의 소비자들이 어떤 기능을 필요로 하는지 파악하고, 적절한 방식으로 제공해야 함.  
3.  **어떤 조건으로 공유할 것인가?**  
    - 보안, 접근 권한, 속도 제한 등 API의 정책을 설정하여 관리해야 함.  


### **9.6 마이크로서비스 (Microservices)란?**
*   **정의:** 애플리케이션을 개별적으로 관리할 수 있는 작은 단위의 서비스로 분리하여 독립적으로 개발, 배포, 운영할 수 있도록 설계한 아키텍처 스타일.  
*   **특징:**  
    - 특정 비즈니스 기능을 담당하는 개별 서비스들이 독립적으로 실행됨.  
    - 서로 다른 기술 스택을 활용할 수 있으며, 특정 서비스에 대한 변경이 전체 시스템에 영향 없음.  
    - 빠른 개발 및 배포 주기를 가능하게 함.  
*   **목표:** 프로젝트 개발 속도를 향상시키고, 유지보수를 용이하게 하며, 시스템의 확장성을 증대.

### **9.7 API와 마이크로서비스의 관계**
*   마이크로서비스는 시스템 오브 레코드의 데이터를 직접 활용하거나, 기존 서비스의 앞단에서 동작 가능.
*   API는 마이크로서비스에 대한 접근을 제어하는 게이트웨이 역할을 수행.  
*   API를 활용하면 마이크로서비스를 다양한 소비자(내부, 외부 개발자)에 맞게 최적화된 방식으로 제공 가능.  


## 10. API 게이트웨이 없이 마이크로서비스와 직접 통신
- 출처: [Scaling an Online Store Without an API Gateway](https://www.youtube.com/watch?v=OAdOa31EH4o&list=PLOspHqNVtKAAAq9pHWlEiRUVcYMCcu4X0&index=11)

### 10.1 시나리오

Indie's Custom Threads는 티셔츠를 맞춤 제작 및 판매하는 E-커머스 플랫폼으로, 웹 애플리케이션, 모바일 앱, 그리고 제3자 API와의 통합을 통해 사용자에게 서비스를 제공합니다.  

1. **사용자 행동 예시**
- 사용자는 웹사이트 또는 모바일 앱을 통해 원하는 티셔츠를 검색하고 구매합니다.
- Facebook 같은 제3자 플랫폼에서 제품 리뷰를 확인하거나, 외부 리뷰 API를 통해 사용자 평가를 가져옵니다.  
- **예시 리뷰:** *"티셔츠 착용감은 좋지만, 폴리에스터 50% 때문에 피부에 발진이 생겼어요."*

2. **클라이언트 종류**
- **웹 애플리케이션**: 웹 브라우저를 통해 상품 검색 및 구매 가능  
- **모바일 클라이언트**: iOS 및 Android 앱을 통해 쇼핑 가능  
- **제3자 API 서비스**: Facebook 연동, 리뷰 API 등 외부 플랫폼과의 통합 지원  


### 10.2 제품 상세 UI와 마이크로서비스 구성  

Indie's Custom Threads는 기존 모놀리식(Monolithic) 애플리케이션을 마이크로서비스 아키텍처로 전환하였으며, 각 주요 기능을 독립적인 마이크로서비스로 운영합니다.

- **주요 마이크로서비스 예시**  
    - **제품 정보 서비스:** 제품의 색상, 사이즈, 소재 등 상세 정보 제공  
    - **가격 서비스:** 티셔츠 가격, 할인율, 프로모션 정보 관리  
    - **주문 서비스:** 사용자의 구매 내역 및 결제 상태 조회  
    - **재고 서비스:** 각 제품의 재고 현황 관리  
    - **리뷰 서비스:** 사용자가 남긴 리뷰 저장 및 제공  

각 서비스는 독립적으로 운영되며, 특정 기능을 담당하는 API를 제공합니다.

### 10.3 아키텍처 패턴: API 게이트웨이 없는 직접 통신  

이 시스템에서는 **API 게이트웨이를 사용하지 않고**, 클라이언트(웹, 모바일 앱 등)가 개별 마이크로서비스와 직접 통신하는 방식을 채택했습니다.  

- **예제 흐름**
    - 사용자가 제품 상세 페이지에서 특정 티셔츠의 정보를 확인하면 → **제품 정보 서비스**에 직접 요청  
    - 제품의 가격을 확인하면 → **가격 서비스**에 직접 요청  
    - 주문을 완료하면 → **주문 서비스**와 **재고 서비스**가 각각 업데이트됨  

이처럼 클라이언트는 필요한 정보를 여러 마이크로서비스에 직접 요청하여 데이터를 가져옵니다.

### 10.4 직접 통신 방식의 문제점 (확장 시 발생하는 이슈)

API 게이트웨이 없이 마이크로서비스에 직접 요청하는 방식은 간단해 보이지만, 애플리케이션이 확장될수록 다음과 같은 문제점이 발생할 수 있습니다.

1. **과도한 네트워크 왕복 (Round Trips)**
- 클라이언트가 여러 개의 마이크로서비스와 개별적으로 통신해야 하므로, 요청 수가 증가하면서 응답 속도가 느려질 가능성이 큼.
- 예를 들어, 사용자가 티셔츠 색상을 변경할 때 **제품 정보 서비스, 가격 서비스, 재고 서비스** 등에 여러 개의 API 요청을 보내야 함.
- 결과적으로 네트워크 지연(latency)이 증가하고 사용자 경험이 저하될 위험이 있음.

2. **교차 관심사 (Cross-Cutting Concerns)**
- 마이크로서비스 간 프로토콜 차이로 인해 클라이언트가 여러 가지 요청 방식을 고려해야 함.
  - 예: 클라이언트는 HTTP를 사용하지만, 일부 서비스는 내부적으로 AMQP(Message Queue) 기반으로 동작할 수도 있음.
- 다양한 클라이언트(Web, iOS, Android, 제3자 서비스)를 지원하기 어려워짐.

3. **보안 취약성 증가**
- 모든 마이크로서비스가 외부에 직접 노출되므로 **보안 리스크**가 커짐.
- 각 서비스별로 **인증(Authentication), 인가(Authorization), 로깅(Logging)** 등의 보안 정책을 개별적으로 적용해야 하므로 관리가 복잡해짐.

4. **서비스 간 결합도 증가 (Coupling)**
- 특정 마이크로서비스가 다운되면, 이와 의존성이 있는 다른 서비스도 영향을 받을 수 있음.
- 예를 들어, 주문 서비스가 장애를 겪으면 재고 서비스의 업데이트도 정상적으로 이루어지지 않을 가능성이 있음.
- 클라이언트가 여러 개의 서비스와 직접 연결되므로, 새로운 서비스 추가나 변경이 있을 때 클라이언트 코드도 함께 수정해야 하는 부담이 있음.

### 10.5 결론: API 게이트웨이 도입 고려 필요  

**API 게이트웨이 없이 직접 통신하는 방식은 초기 개발 속도를 높이고 간단한 시스템에서 유용할 수 있음.** 하지만, 다음과 같은 이유로 **확장성과 유지보수 관점에서 한계점**이 존재합니다.

- **소규모 애플리케이션**에서는 단순한 구조로 인해 빠른 개발 가능  
- **대규모 애플리케이션**에서는 API 요청이 증가하면서 관리 부담 및 성능 문제가 발생  
- **애플리케이션이 성장하고 기능이 복잡해질 경우**, 다음과 같은 이유로 API 게이트웨이를 도입하는 것이 좋습니다.

1. **요청 최적화 및 성능 향상**  
   - API 게이트웨이는 여러 마이크로서비스 요청을 한 번에 처리할 수 있도록 **BFF(Backend for Frontend) 패턴**을 적용 가능  
   - 클라이언트가 단일 엔드포인트에 요청을 보내면, 게이트웨이가 내부적으로 필요한 마이크로서비스에 요청을 분산하여 병렬 처리  

2. **보안 강화**  
   - 게이트웨이에서 인증 및 인가를 관리하여 **각 마이크로서비스가 직접 외부에 노출되지 않도록 보호**  
   - 요청 필터링, SSL/TLS 암호화, API 키 검증 등의 기능을 제공  

3. **서비스 간 결합도 감소 및 유지보수 용이**  
   - 클라이언트가 직접 여러 마이크로서비스와 통신하는 대신, 게이트웨이 하나만 참조하도록 설계 가능  
   - 마이크로서비스를 변경해도 클라이언트 코드 수정이 최소화됨  

**결론:**  
- **소규모 애플리케이션**에서는 API 게이트웨이 없이 직접 통신이 가능하지만,  
- **확장성과 유지보수를 고려한다면 API 게이트웨이를 도입하는 것이 바람직함.**  

## 11. REST vs. GraphQL
- 출처: [GraphQL vs REST: Which is Better for APIs?](https://www.youtube.com/watch?v=PTfZcN20fro&list=PLOspHqNVtKAAAq9pHWlEiRUVcYMCcu4X0&index=12)

### **11.1 개요**  

- REST와 GraphQL은 애플리케이션들이 인터넷을 통해 데이터를 교환하고 상호 작용할 수 있도록 설계된 API(Application Programming Interface) 구축 기술이다. 
- REST는 전통적인 방식으로 널리 사용되며, 
- GraphQL은 보다 유연하고 효율적인 데이터 요청을 지원하는 최신 접근 방식이다. 
- 각 방식은 서로 다른 장점을 제공하며, 개발 환경과 요구 사항에 따라 적절한 선택이 필요하다.  

### **11.2 REST**  

1. **특징**  
*   클라이언트는 원하는 데이터를 얻기 위해 여러 개의 요청을 보내야 할 수도 있으며, 응답으로 반환된 데이터에서 필요한 정보를 추려야 한다.  
*   REST는 "REpresentational State Transfer"의 약자로, 분산 시스템에서 리소스를 관리하는 구조적 패턴을 제공한다.  
*   HTTP 요청을 사용하여 서버의 리소스와 상호 작용하는 아키텍처 스타일이며, 정해진 엔드포인트에서 리소스를 CRUD(Create, Read, Update, Delete) 방식으로 처리한다.  
*   URL을 통해 리소스를 지정하고, HTTP 메서드를 활용해 데이터를 요청하거나 변경한다.  
*   캐싱이 용이하여 성능 최적화가 가능하지만, 클라이언트가 불필요한 데이터를 포함한 응답을 받을 가능성이 있다.  

2. **구성 요소**  
*   **리소스(Resource):** REST의 핵심 개념으로, 각 리소스는 고유한 URI(Uniform Resource Identifier)를 가진다.  
*   **HTTP 메서드:**  
        - **GET:** 데이터를 조회한다.  
        - **POST:** 새로운 데이터를 생성한다.  
        - **PUT:** 기존 데이터를 수정한다.  
        - **DELETE:** 데이터를 삭제한다.  
*   **응답(Response):** 서버는 JSON 또는 XML 형식으로 클라이언트가 요청한 데이터를 반환한다.  
*   **쿼리 매개변수(Query Parameters):** 클라이언트가 데이터 필터링, 정렬, 페이지네이션 등을 수행할 때 사용한다.  

### **11.3 GraphQL**  

1. **특징**  
*   클라이언트는 필요로 하는 데이터만 정확하게 요청할 수 있어, 과도한 데이터 전송(Over-fetching)이나 부족한 데이터 요청(Under-fetching) 문제를 방지할 수 있다.  
*   GraphQL은 "Graph Query Language"의 약자로, API에서 데이터를 유연하게 가져올 수 있도록 설계된 쿼리 언어이다.  
*   단일 API 엔드포인트를 통해 여러 개의 데이터 소스에서 필요한 정보를 한 번의 요청으로 가져옴.
*   중첩된 데이터 요청이 가능하여 복잡한 관계를 가진 데이터 모델을 효율적으로 다룰 수 있다.  
*   요청 구조가 명확하여 API 소비자가 원하는 데이터의 구조를 예측할 수 있다.  

2. **구성 요소**  
*   **스키마(Schema):**  
        - API가 제공하는 데이터의 구조를 정의하는 청사진 역할을 하며, 데이터 유형과 관계를 명확하게 규정한다.  
*   **쿼리(Query):**  
        - 클라이언트가 요청하는 데이터 구조를 직접 지정하며, REST의 GET 요청과 유사하다.  
        - 예: 특정 사용자 정보와 해당 사용자의 게시글을 한 번의 요청으로 조회 가능하다.  
*   **Resolver:**  
        - 쿼리를 처리하여 데이터를 반환하는 함수로, 데이터베이스, API 또는 기타 외부 소스로부터 데이터를 가져온다.  
        - 여러 데이터 소스에서 데이터를 조합해 원하는 형태로 가공할 수 있다.  
*   **Mutation:**  
        - 서버의 데이터를 수정하는 역할을 하며, REST의 POST, PUT, DELETE 요청과 유사하다.  
        - 예: 새로운 사용자를 생성하거나 기존 정보를 업데이트하는 요청을 처리한다.  

### **11.4 공통점**  
*   애플리케이션 간 데이터를 주고받기 위한 API 구축 방식이다.  
*   HTTP 프로토콜을 통해 데이터를 전송하며, 클라이언트-서버 모델을 기반으로 동작한다.  
*   JSON(JavaScript Object Notation)을 주된 데이터 포맷으로 사용하여 요청과 응답을 처리할 수 있다.  
*   다양한 프레임워크 및 라이브러리를 활용하여 API 개발을 간소화할 수 있다.  

### **11.5 차이점 비교**  

| 특징           | REST                                           | GraphQL                                                                   |
|--------------|---------------------------------------------|-------------------------------------------------------------------------|
| **데이터 요청 방식** | 각 엔드포인트에서 고정된 데이터 구조로 응답             | 클라이언트가 원하는 데이터 구조를 직접 정의하여 요청 가능                     |
| **요청 횟수**  | 여러 엔드포인트에 대한 다중 요청이 필요할 수 있음          | 단일 요청으로 여러 리소스를 한 번에 조회 가능                                |
| **응답 크기**  | 필요하지 않은 데이터도 포함될 수 있음                  | 필요한 데이터만 요청하여 응답 크기를 줄일 수 있음                              |
| **API 버전 관리** | 엔드포인트를 새로 추가하여 버전 관리 (예: /v1, /v2)       | 단일 엔드포인트에서 스키마 변경을 통해 관리 가능                               |
| **캐싱 지원**  | 브라우저 및 CDN을 활용한 캐싱이 용이함                  | 기본적으로 캐싱 지원이 부족하여 별도의 최적화 필요                            |
| **학습 곡선**  | 기존 REST API와 유사하여 익숙한 방식                     | 새로운 쿼리 언어 학습이 필요할 수 있음                                       |
| **적합한 사용 사례** | 정형화된 CRUD API, 단순한 데이터 제공에 적합            | 복잡한 관계를 가진 데이터 조회, 다양한 데이터 소스 통합 API에 적합            |

### **11.6 결론**  

REST와 GraphQL은 각각 고유한 장점과 단점을 가지며, 특정 요구 사항에 따라 적절한 방식을 선택하는 것이 중요하다.  

* REST는 간단한 CRUD 기반 API에서 효과적이며, 캐싱을 통한 성능 최적화가 가능하다.  
* GraphQL은 클라이언트가 원하는 데이터만 효율적으로 요청할 수 있어, 복잡한 데이터 구조를 가진 애플리케이션에 적합하다.  

특히 기존 REST API를 보완하는 방식으로 GraphQL을 도입하는 것도 가능하며, 실제 많은 기업이 두 가지 방식을 혼합하여 사용하고 있다. API를 설계할 때는 성능, 유지보수, 데이터 구조의 복잡성을 고려하여 최적의 방법을 선택하는 것이 중요하다.