---
title: 7차시 8:Java
layout: single
classes: wide
categories:
  - React
toc: true # 이 포스트에서 목차를 활성화
toc_sticky: true # 목차를 고정할지 여부 (선택 사항)
---

## 1. 자바 프로그래밍 입문

### 1.1 변수와 자료형

1.변수(Variable)란?
*   개념
    - **변수**는 데이터를 저장하기 위한 메모리 공간에 붙인 이름입니다
    - 프로그램에서 데이터를 임시로 보관하고 사용하기 위한 컨테이너라고 생각하시면 됩니다
    - 변수에는 다양한 종류의 데이터(숫자, 문자, 참/거짓 등)를 저장할 수 있습니다

* 변수의 특징
    ```java
    // 변수 선언과 사용의 기본 형태
    자료형 변수이름 = 값;
    ```

* 예시
    ```java
    int age = 25;           // 나이를 저장하는 변수
    String name = "홍길동";  // 이름을 저장하는 변수
    ```

2.자료형(Data Type)이란?
* 개념
    - **자료형**은 변수에 저장할 데이터의 종류와 크기를 정의합니다
    - 자바는 "강유형(Strongly Typed)" 언어로, 모든 변수는 사용 전에 반드시 자료형을 선언해야 합니다

3.기본 자료형(Primitive Types)

*   정수형

    | 자료형 | 크기 | 범위 | 설명 |
    |--------|------|------|------|
    | `byte` | 1 byte | -128 ~ 127 | 가장 작은 정수형 |
    | `short` | 2 bytes | -32,768 ~ 32,767 | 짧은 정수 |
    | `int` | 4 bytes | -2¹⁵ ~ 2¹⁵-1 | 가장 일반적인 정수형 |
    | `long` | 8 bytes | -2⁶³ ~ 2⁶³-1 | 큰 정수 (접미사 L 사용) |

* 실수형

    | 자료형 | 크기 | 범위 | 설명 |
    |--------|------|------|------|
    | `float` | 4 bytes | 약 ±3.4×10³⁸ | 단정밀도 실수 (접미사 f 사용) |
    | `double` | 8 bytes | 약 ±1.7×10³⁰⁸ | 배정밀도 실수 (기본 실수형) |

* 문자형

    | 자료형 | 크기 | 범위 | 설명 |
    |--------|------|------|------|
    | `char` | 2 bytes | 0 ~ 65,535 | 유니코드 문자 저장 |

* 논리형

    | 자료형 | 크기 | 범위 | 설명 |
    |--------|------|------|------|
    | `boolean` | 1 byte | true / false | 참 또는 거짓 값 |


4.참조 자료형(Reference Types)
* 개념
    - 기본 자료형이 아닌 모든 타입은 참조 자료형입니다
    - 실제 데이터가 저장된 메모리 주소를 참조합니다

* 주요 참조 자료형
    - `String`: 문자열을 저장하는 클래스
    - `Array`: 배열
    - `Class`: 사용자 정의 클래스
    - `Interface`: 인터페이스

5.변수 선언 규칙
* 올바른 변수 이름 규칙
    1. **첫 글자**: 문자, 밑줄(_), 달러 기호($)
    2. **나머지 글자**: 문자, 숫자, 밑줄, 달러 기호
    3. **대소문자 구분**: `age`와 `Age`는 다른 변수
    4. **예약어 사용 불가**: `int`, `class` 등은 변수명으로 사용 불가
    5. **의미 있는 이름 사용**: `a1`보다 `studentAge`가 더 좋음

* 네이밍 컨벤션
    - **카멜 케이스(Camel Case)**: `studentName`, `totalScore`
    - **의미 있는 이름**: `a` ❌ → `age` ✅

6.변수의 생명주기
* 스코프(Scope)
    - 변수가 접근 가능한 범위를 의미합니다
    - 변수는 선언된 블록 `{}` 내에서만 접근 가능합니다

    ```java
    public class Example {
        public void method() {
            int localVar = 10;  // 이 메서드 내에서만 사용 가능
            // ...
        }
        
        // 여기서 localVar 사용 불가
    }
    ```

7.자료형 선택 가이드
* 선택 기준
    1. **저장할 데이터의 종류**에 따라 선택
    2. **메모리 효율성** 고려
    3. **필요한 범위**에 맞는 자료형 선택

* 예시
    ```java
    // 나이: 0~150 정도 → byte 충분
    byte age = 25;

    // 인구 수: 수백만 ~ 수십억 → int 또는 long
    int population = 50000000;

    // 평균 점수: 소수점 필요 → double
    double averageScore = 89.5;

    // 성별: 한 문자 → char
    char gender = 'M';

    // 합격 여부: 참/거짓 → boolean
    boolean isPassed = true;
    ```

8.핵심 정리
- **변수**는 데이터를 저장하는 메모리 공간
- **자료형**은 저장할 데이터의 종류와 크기를 정의
- **기본 자료형** 8가지: 정수, 실수, 문자, 논리형
- **참조 자료형**: 문자열, 배열, 클래스 등
- 변수 이름은 **의미 있게**, **규칙을 지켜서** 지어야 함

```java
public class VariableExample {
    public static void main(String[] args) {
        // 기본형 변수 선언
        int age = 25;
        double height = 175.5;
        char grade = 'A';
        boolean isStudent = true;

        // 참조형 변수 (String)
        String name = "홍길동";

        // 출력
        System.out.println("이름: " + name);
        System.out.println("나이: " + age);
        System.out.println("키: " + height);
        System.out.println("등급: " + grade);
        System.out.println("학생 여부: " + isStudent);
    }
}
```

### 1.2 연산자

1.연산자의 기본 개념

*   **연산자(Operator)**란?
    - 특정 연산을 수행하기 위해 사용되는 기호
    - 예: `+`, `-`, `*`, `/` 등

*   **피연산자(Operand)**란?
    - 연산의 대상이 되는 값
    - 예: `a + b`에서 `a`와 `b`는 피연산자

2.연산자의 종류

*   산술 연산자 (Arithmetic Operators)
    - 기본적인 수학 연산을 수행
    - `+` (덧셈), `-` (뺄셈), `*` (곱셈), `/` (나눗셈), `%` (나머지)

    ```java
    int result = 10 + 5;  // 15
    ```

*   대입 연산자 (Assignment Operators)
    - 변수에 값을 저장할 때 사용
    - `=` (기본 대입), `+=`, `-=`, `*=`, `/=`, `%=` (복합 대입)

    ```java
    int x = 10;  // x에 10을 대입
    x += 5;      // x = x + 5와 동일
    ```

*   비교 연산자 (Comparison Operators)
    - 두 값을 비교하여 true/false 반환
    - `==` (같음), `!=` (다름), `>` (큼), `<` (작음), `>=` (크거나 같음), `<=` (작거나 같음)

    ```java
    boolean isEqual = (10 == 5);  // false
    ```

*   논리 연산자 (Logical Operators)
    - 논리적인 조건을 결합
    - `&&` (AND), `||` (OR), `!` (NOT)

    ```java
    boolean result = (10 > 5) && (3 < 7);  // true
    ```

*   증감 연산자 (Increment/Decrement Operators)
    - 변수의 값을 1 증가 또는 감소
    - `++` (증가), `--` (감소)
    - 전위형(prefix)과 후위형(postfix) 존재

    ```java
    int x = 5;
    x++;  // x는 6이 됨
    ```

*   삼항 연산자 (Ternary Operator)
    - 조건에 따라 다른 값을 반환
    - `조건 ? 값1 : 값2`

    ```java
    int result = (10 > 5) ? 1 : 0;  // 1
    ```

*   비트 연산자 (Bitwise Operators)
    - 비트 단위로 연산 수행
    - `&` (AND), `|` (OR), `^` (XOR), `~` (NOT), `<<` (왼쪽 시프트), `>>` (오른쪽 시프트)

3.연산자 우선순위
*   연산자들은 실행 순서에 따라 우선순위가 있습니다:
    1. `()`, `[]` (괄호, 배열)
    2. `++`, `--` (후위 증감)
    3. `++`, `--`, `+`, `-`, `!`, `~` (전위 증감, 단항)
    4. `*`, `/`, `%` (곱셈, 나눗셈, 나머지)
    5. `+`, `-` (덧셈, 뺄셈)
    6. `<<`, `>>`, `>>>` (시프트)
    7. `<`, `<=`, `>`, `>=` (비교)
    8. `==`, `!=` (동등)
    9. `&` (비트 AND)
    10. `^` (비트 XOR)
    11. `|` (비트 OR)
    12. `&&` (논리 AND)
    13. `||` (논리 OR)
    14. `? :` (삼항)
    15. `=`, `+=`, `-=`, `*=`, `/=`, `%=` (대입)

4.중요 개념 정리
- **형 변환(Type Casting)**: 서로 다른 데이터 타입 간의 연산 시 자동 또는 명시적 변환 발생
- **단항/이항/삼항 연산자**: 피연산자의 개수에 따른 분류
- **부작용(Side Effect)**: 연산자가 변수의 값을 변경하는 효과


```java
public class OperatorExample {
    public static void main(String[] args) {
        int a = 10, b = 3;

        // 산술 연산자
        System.out.println("a + b = " + (a + b));
        System.out.println("a / b = " + (a / b));
        System.out.println("a % b = " + (a % b));

        // 비교 연산자
        System.out.println("a > b : " + (a > b));

        // 논리 연산자
        boolean result = (a > 5) && (b < 5);
        System.out.println("논리 결과: " + result);

        // 증감 연산자
        a++;
        System.out.println("a++ 결과: " + a);

        // 삼항 연산자
        String msg = (a > b) ? "a가 큽니다" : "b가 큽니다";
        System.out.println(msg);
    }
}
```

### 1.3 제어문

1.조건문 (Conditional Statements)

* if 문
    - **가장 기본적인 조건문**
    - 조건식이 true일 때만 코드 블록 실행

    ```java
    if (조건식) {
        // 조건이 true일 때 실행되는 코드
    }
    ```

* if-else 문
    - 조건식이 true일 때와 false일 때 각각 다른 코드 실행
    
    ```java
    if (조건식) {
        // 조건이 true일 때 실행
    } else {
        // 조건이 false일 때 실행
    }
    ```

*   if-else if-else 문
    - 여러 조건을 순차적으로 검사

    ```java
    if (조건식1) {
        // 조건식1이 true일 때
    } else if (조건식2) {
        // 조건식2가 true일 때
    } else {
        // 모든 조건이 false일 때
    }
    ```

* switch 문
    - 하나의 변수나 표현식을 여러 case 값과 비교
    - break 문으로 각 case를 구분
    - default는 모든 case에 해당하지 않을 때 실행

    ```java
    switch (변수) {
        case 값1:
            // 변수가 값1일 때 실행
            break;
        case 값2:
            // 변수가 값2일 때 실행
            break;
        default:
            // 모든 case에 해당하지 않을 때 실행
    }
    ```

2.반복문 (Loop Statements)

* for 문
    - **정해진 횟수만큼 반복**할 때 적합
    - 초기화, 조건식, 증감식으로 구성
    
    ```java
    for (초기화; 조건식; 증감식) {
        // 조건식이 true인 동안 반복 실행
    }
    ```

* while 문
    - **조건이 true인 동안 계속 반복**
    - 반복 횟수가 명확하지 않을 때 적합
    
    ```java
    while (조건식) {
        // 조건식이 true인 동안 반복 실행
    }
    ```

* do-while 문
    - **먼저 코드를 실행한 후 조건 검사**
    - 최소 한 번은 무조건 실행
    
    ```java
    do {
        // 먼저 실행되고, 이후 조건 검사
    } while (조건식);
    ```

3.분기문 (Branching Statements)

*   break 문
    - 반복문이나 switch 문을 **즉시 종료**

*   continue 문
    - 현재 반복을 건너뛰고 **다음 반복으로 이동**

*   return 문
    - 메서드 실행을 종료하고 **값을 반환**

*   제어문의 중요 개념
    1. **조건식**: true/false를 반환하는 boolean 표현식
    2. **코드 블록**: {}로 묶인 명령문들의 집합
    3. **스코프(Scope)**: 변수가 유효한 범위
    4. **중첩**: 제어문 안에 다른 제어문을 사용 가능

```java
import java.util.Scanner;

public class ControlStatementExample {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        // 조건문
        System.out.print("점수를 입력하세요: ");
        int score = sc.nextInt();

        if (score >= 90) {
            System.out.println("A학점");
        } else if (score >= 80) {
            System.out.println("B학점");
        } else {
            System.out.println("C학점 이하");
        }

        // switch-case
        System.out.print("요일 번호(1~7): ");
        int day = sc.nextInt();

        switch (day) {
            case 1 -> System.out.println("월요일");
            case 2 -> System.out.println("화요일");
            case 3 -> System.out.println("수요일");
            default -> System.out.println("기타 요일");
        }

        // 반복문
        System.out.println("for문 예제:");
        for (int i = 1; i <= 5; i++) {
            System.out.println("i = " + i);
        }

        System.out.println("while문 예제:");
        int n = 3;
        while (n > 0) {
            System.out.println("남은 횟수: " + n);
            n--;
        }

        sc.close();
    }
}
```

### 1.4 배열(Array)

1.배열이란?

*   **배열(Array)**은 **같은 타입**의 데이터 여러 개를 하나의 변수로 다루기 위한 자료구조입니다.

*   주요 특징:
    - **고정된 크기**: 한번 생성된 배열의 크기는 변경할 수 없음
    - **인덱스(Index) 기반**: 0부터 시작하는 숫자 인덱스로 각 요소에 접근
    - **동일한 자료형**: 배열의 모든 요소는 같은 데이터 타입을 가짐
    - **연속된 메모리 공간**: 요소들이 메모리에 연속적으로 저장됨

2.배열 선언 방식

*   방법 1: 선언과 생성을 분리
    ```java
    // 선언
    자료형[] 배열이름;
    // 또는
    자료형 배열이름[];

    // 생성
    배열이름 = new 자료형[크기];
    ```

*   방법 2: 선언과 생성을 동시에
    ```java
    자료형[] 배열이름 = new 자료형[크기];
    ```

3.다양한 배열 선언 예시

* 기본 자료형 배열
    ```java
    int[] numbers = new int[5];        // 정수형 배열 (5개 요소)
    double[] scores = new double[10];  // 실수형 배열
    boolean[] flags = new boolean[3];  // 불린형 배열
    char[] letters = new char[8];      // 문자형 배열
    ```

* 참조 자료형 배열
    ```java
    String[] names = new String[4];    // 문자열 배열
    ```

4.배열 초기화

* 방법 1: 선언 후 개별 초기화
    ```java
    int[] scores = new int[3];
    scores[0] = 85;
    scores[1] = 90;
    scores[2] = 78;
    ```

*   방법 2: 선언과 동시에 초기화
    ```java
    int[] scores = new int[]{85, 90, 78};
    // 또는
    int[] scores = {85, 90, 78};  // 더 간단한 방식
    ```

5.배열의 구조와 접근

* 배열 구조 이해하기
    ```
    int[] arr = {10, 20, 30, 40, 50};

    인덱스:   0    1    2    3    4
    값:     10   20   30   40   50
    ```

* 배열 요소 접근
    ```java
    int[] numbers = {10, 20, 30, 40, 50};

    // 요소 읽기
    System.out.println(numbers[0]);  // 10 출력
    System.out.println(numbers[2]);  // 30 출력

    // 요소 수정
    numbers[1] = 25;  // 두 번째 요소를 20에서 25로 변경
    ```

6.배열의 길이와 주의사항

*   배열 길이 확인
    ```java
    int[] arr = {1, 2, 3, 4, 5};
    System.out.println(arr.length);  // 5 출력
    ```

*   주의사항
    1. **유효하지 않은 인덱스 접근**
    ```java
    int[] arr = new int[3];
    System.out.println(arr[5]);  // ArrayIndexOutOfBoundsException 발생!
    ```
    2. **배열 크기는 변경 불가**
    ```java
    int[] arr = new int[3];
    arr.length = 5;  // 컴파일 에러!
    ```

7.다차원 배열

*   2차원 배열 선언
    ```java
    // 2x3 크기의 2차원 배열
    int[][] matrix = new int[2][3];

    // 초기화
    int[][] matrix = {
        {1, 2, 3},
        {4, 5, 6}
    };
    ```

*   2차원 배열 접근
    ```java
    int[][] matrix = {
        {1, 2, 3},
        {4, 5, 6}
    };

    System.out.println(matrix[0][1]);  // 2 출력
    System.out.println(matrix[1][2]);  // 6 출력
    ```

8.배열의 장단점

*   장점
    - **빠른 접근**: 인덱스를 통한 직접 접근으로 조회 속도가 빠름
    - **메모리 효율**: 연속된 메모리 공간 사용
    - **간단한 구조**: 이해하고 사용하기 쉬움

* 단점
    - **고정된 크기**: 배열 생성 후 크기 변경 불가
    - **메모리 낭비**: 필요한 크기보다 크게 생성하면 메모리 낭비
    - **삽입/삭제 비효율**: 중간에 요소를 추가하거나 삭제할 때 비효율적

9.핵심 개념 정리

|------|------|
| **인덱스** | 0부터 시작하는 배열 요소의 위치 |
| **length** | 배열의 크기를 알려주는 필드 |
| **new** | 배열 생성 연산자 |
| **초기값** | 숫자형: 0,<br> boolean: false,<br> 참조형: null |


```java
public class ArrayExample {
    public static void main(String[] args) {
        // 1차원 배열
        int[] scores = {90, 85, 78};

        System.out.println("첫 번째 점수: " + scores[0]);
        scores[1] = 88; // 값 수정
        System.out.println("수정된 두 번째 점수: " + scores[1]);

        // 반복문으로 출력
        for (int i = 0; i < scores.length; i++) {
            System.out.println("점수[" + i + "]: " + scores[i]);
        }

        // 2차원 배열
        int[][] matrix = {
            {1, 2},
            {3, 4}
        };
        System.out.println("matrix[1][1] = " + matrix[1][1]);
    }
}
```

### 1.5 ArrayList
1.기본 개념
*   ArrayList는 내부적으로 동적 배열($Object\[\]$)을 사용하여 요소를 저장합니다.
*   순서 보장: 요소는 추가된 순서대로 인덱스(0부터 시작)를 통해 관리됩니다.
*   중복 허용: 동일한 요소를 여러 번 저장할 수 있습니다.
*   null 허용: null 요소를 포함할 수 있습니다.
*   비동기화: 스레드 안전하지 않으므로 멀티스레드 환경에서는 Collections.synchronizedList()나 CopyOnWriteArrayList를 고려해야 합니다.

2.장점
*   동적 크기 조정: 요소 추가/삭제 시 자동으로 크기가 조정됨.
*   풍부한 기능: 컬렉션 프레임워크의 다양한 메서드(addAll, removeIf, stream 등) 제공.
*   유연성: 제네릭을 통해 타입 안정성 확보 가능.

3.CRUD 샘플 예제
```java
import java.util.ArrayList;
import java.util.List;

public class ArrayListCRUDExample {
    public static void main(String[] args) {
        // ArrayList 생성
        List<String> fruits = new ArrayList<>();

        // 1. Create (생성): 요소 추가
        fruits.add("Apple");        // 인덱스 0
        fruits.add("Banana");       // 인덱스 1
        fruits.add("Orange");       // 인덱스 2
        fruits.add(1, "Mango");     // 인덱스 1에 삽입 (Banana가 뒤로 밀림)
        System.out.println("After Create: " + fruits); // 출력: [Apple, Mango, Banana, Orange]

        // 2. Read (조회): 요소 읽기
        String firstFruit = fruits.get(0); // 인덱스 0 조회
        System.out.println("First fruit: " + firstFruit); // 출력: Apple
        boolean containsBanana = fruits.contains("Banana"); // 특정 요소 존재 여부 확인
        System.out.println("Contains Banana? " + containsBanana); // 출력: true

        // 3. Update (수정): 요소 수정
        fruits.set(2, "Grape"); // 인덱스 2의 요소를 Grape로 수정
        System.out.println("After Update: " + fruits); // 출력: [Apple, Mango, Grape, Orange]

        // 4. Delete (삭제): 요소 삭제
        fruits.remove("Mango"); // 특정 요소 삭제
        fruits.remove(0);       // 인덱스 0 삭제
        System.out.println("After Delete: " + fruits); // 출력: [Grape, Orange]

        // 추가: 리스트 크기 및 비어 있는지 확인
        System.out.println("Size: " + fruits.size()); // 출력: 2
        System.out.println("Is empty? " + fruits.isEmpty()); // 출력: false

        // 추가: 전체 리스트 순회
        System.out.print("All fruits: ");
        for (String fruit : fruits) {
            System.out.print(fruit + " "); // 출력: Grape Orange
        }
    }
}
```

4.코드 설명

*   Create:
    - add(E element): 리스트 끝에 요소 추가.
    - add(int index, E element): 지정된 인덱스에 요소 삽입(기존 요소는 뒤로 밀림).

* Read:
    - get(int index): 특정 인덱스의 요소 반환.
    - contains(Object o): 리스트에 특정 요소가 있는지 확인.

* Update:
    - set(int index, E element): 지정된 인덱스의 요소를 새로운 값으로 교체.

* Delete:
    - remove(Object o): 특정 요소 제거(첫 번째로 발견된 요소).
    - remove(int index): 지정된 인덱스의 요소 제거.

*   추가 팁
    - 제네릭 사용: ArrayList<String>처럼 제네릭을 사용하여 타입 안정성을 확보하세요.
    - 성능 고려: 중간 삽입/삭제가 빈번하면 LinkedList를 고려할 수 있지만, 일반적으로 ArrayList가 더 범용적
    - 컬렉션 메서드 활용: addAll, clear, subList, stream 등 다양한 메서드로 생산성을 높일 수 있습니다.

### 1.6 HashMap
*   HashMap은 해시 테이블(hash table)을 기반으로 구현된 자료구조로, 키(Key)를 값(Value)에 매핑하여 데이터를 효율적으로 저장하고 검색할 수 있도록 설계되었습니다.
    - 키(Key): 고유한 식별자로, 데이터를 검색하거나 저장할 때 사용됩니다.
    - 값(Value): 키에 매핑된 실제 데이터입니다.
    - 해시 테이블: 내부적으로 배열과 연결 리스트(또는 트리)를 조합하여 데이터를 저장합니다.

* HashMap은 Map 인터페이스를 구현하며, 순서가 보장되지 않고, 키의 중복을 허용하지 않습니다. 값은 중복될 수 있습니다.

1.HashMap 생성 및 데이터 추가(Create)

```java
import java.util.HashMap;

public class HashMapExample {
    public static void main(String[] args) {
        // HashMap 생성
        HashMap<String, Integer> studentScores = new HashMap<>();
        
        // 데이터 추가 - put()
        studentScores.put("김철수", 85);
        studentScores.put("이영희", 92);
        studentScores.put("박민수", 78);
        studentScores.put("정수진", 95);
        
        // putAll()을 사용한 데이터 일괄 추가
        HashMap<String, Integer> additionalScores = new HashMap<>();
        additionalScores.put("최윤서", 88);
        additionalScores.put("한지원", 91);
        
        studentScores.putAll(additionalScores);
        
        System.out.println("전체 학생 점수: " + studentScores);
    }
}
```

2.데이터 조회(Read)

```java
import java.util.HashMap;
import java.util.Map;

public class HashMapReadExample {
    public static void main(String[] args) {
        HashMap<String, String> capitalCities = new HashMap<>();
        capitalCities.put("한국", "서울");
        capitalCities.put("일본", "도쿄");
        capitalCities.put("미국", "워싱턴DC");
        capitalCities.put("영국", "런던");
        capitalCities.put("프랑스", "파리");
        
        // 특정 키로 값 조회 - get()
        String koreaCapital = capitalCities.get("한국");
        System.out.println("한국의 수도: " + koreaCapital);
        
        // 존재하지 않는 키 조회
        String chinaCapital = capitalCities.get("중국");
        System.out.println("중국의 수도: " + chinaCapital); // null 출력
        
        // getOrDefault() - 키가 없을 때 기본값 반환
        String chinaCapitalWithDefault = capitalCities.getOrDefault("중국", "정보 없음");
        System.out.println("중국의 수도: " + chinaCapitalWithDefault);
        
        // 키 존재 여부 확인 - containsKey()
        boolean hasJapan = capitalCities.containsKey("일본");
        System.out.println("일본 데이터 존재?: " + hasJapan);
        
        // 값 존재 여부 확인 - containsValue()
        boolean hasSeoul = capitalCities.containsValue("서울");
        System.out.println("서울 데이터 존재?: " + hasSeoul);
        
        // Map 크기 확인 - size()
        System.out.println("저장된 국가 수: " + capitalCities.size());
        
        // Map이 비어있는지 확인 - isEmpty()
        System.out.println("비어있는가?: " + capitalCities.isEmpty());
    }
}
```

3.데이터 수정(Update)

```java
import java.util.HashMap;

public class HashMapUpdateExample {
    public static void main(String[] args) {
        HashMap<String, Integer> productPrices = new HashMap<>();
        productPrices.put("사과", 1000);
        productPrices.put("바나나", 2000);
        productPrices.put("오렌지", 1500);
        
        System.out.println("원래 가격: " + productPrices);
        
        // put()을 이용한 수정 (기존 키에 새로운 값 할당)
        productPrices.put("사과", 1200); // 사과 가격 인상
        System.out.println("사과 가격 인상 후: " + productPrices);
        
        // compute()를 이용한 수정
        productPrices.compute("바나나", (key, value) -> value + 500); // 500원 인상
        System.out.println("바나나 가격 인상 후: " + productPrices);
        
        // computeIfPresent() - 키가 존재할 때만 수정
        productPrices.computeIfPresent("오렌지", (key, value) -> value - 300); // 300원 할인
        productPrices.computeIfPresent("포도", (key, value) -> value + 1000); // 실행되지 않음
        System.out.println("오렌지 할인 후: " + productPrices);
        
        // merge()를 이용한 병합
        HashMap<String, Integer> newPrices = new HashMap<>();
        newPrices.put("사과", 1100);
        newPrices.put("포도", 3000);
        
        newPrices.forEach((key, value) -> 
            productPrices.merge(key, value, (oldValue, newValue) -> newValue)
        );
        System.out.println("merge 이후: " + productPrices);
    }
}
```

4.데이터 삭제(Delete)

```java
import java.util.HashMap;

public class HashMapDeleteExample {
    public static void main(String[] args) {
        HashMap<Integer, String> employeeMap = new HashMap<>();
        employeeMap.put(101, "김대리");
        employeeMap.put(102, "이과장");
        employeeMap.put(103, "박사원");
        employeeMap.put(104, "정차장");
        employeeMap.put(105, "최부장");
        
        System.out.println("삭제 전: " + employeeMap);
        
        // 특정 키로 삭제 - remove(key)
        String removedValue = employeeMap.remove(103);
        System.out.println("삭제된 값: " + removedValue);
        System.out.println("103번 삭제 후: " + employeeMap);
        
        // 키-값 쌍으로 삭제 - remove(key, value)
        boolean isRemoved = employeeMap.remove(104, "정차장");
        System.out.println("104번 삭제 성공?: " + isRemoved);
        
        boolean isNotRemoved = employeeMap.remove(105, "잘못된값");
        System.out.println("105번 잘못된 값으로 삭제 시도?: " + isNotRemoved);
        
        System.out.println("삭제 시도 후: " + employeeMap);
        
        // 모든 데이터 삭제 - clear()
        employeeMap.clear();
        System.out.println("clear() 이후: " + employeeMap);
        System.out.println("비어있는가?: " + employeeMap.isEmpty());
    }
}
```

5.전체 데이터 순회하기

```java
import java.util.HashMap;
import java.util.Map;

public class HashMapIterateExample {
    public static void main(String[] args) {
        HashMap<String, Integer> fruitInventory = new HashMap<>();
        fruitInventory.put("Apple", 10);
        fruitInventory.put("Banana", 15);
        fruitInventory.put("Orange", 8);
        fruitInventory.put("Grape", 20);
        
        // 1. keySet()을 이용한 순회
        System.out.println("=== keySet()으로 순회 ===");
        for (String fruit : fruitInventory.keySet()) {
            int quantity = fruitInventory.get(fruit);
            System.out.println(fruit + ": " + quantity + "개");
        }
        
        // 2. entrySet()을 이용한 순회 (더 효율적)
        System.out.println("\n=== entrySet()으로 순회 ===");
        for (Map.Entry<String, Integer> entry : fruitInventory.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue() + "개");
        }
        
        // 3. values()를 이용한 값만 순회
        System.out.println("\n=== values()로 순회 ===");
        for (int quantity : fruitInventory.values()) {
            System.out.println("재고량: " + quantity + "개");
        }
        
        // 4. forEach()와 람다 표현식
        System.out.println("\n=== forEach()로 순회 ===");
        fruitInventory.forEach((fruit, quantity) -> {
            System.out.println(fruit + ": " + quantity + "개");
        });
    }
}
```

### 1.7 메서드(함수)

```java
public class MethodExample {

    // 매개변수와 반환값이 있는 메서드
    static int add(int x, int y) {
        return x + y;
    }

    // void 메서드
    static void greet(String name) {
        System.out.println("안녕하세요, " + name + "님!");
    }

    // 가변 인자
    static int sumAll(int... nums) {
        int sum = 0;
        for (int n : nums) {
            sum += n;
        }
        return sum;
    }

    public static void main(String[] args) {
        int result = add(3, 5);
        System.out.println("3 + 5 = " + result);

        greet("홍길동");

        int total = sumAll(1, 2, 3, 4, 5);
        System.out.println("총합 = " + total);
    }
}
```

### 1.6 String 클래스 기초

```java
public class StringExample {
    public static void main(String[] args) {
        String str1 = "Hello";
        String str2 = new String("Java");

        // 문자열 메서드 활용
        System.out.println("길이: " + str1.length());
        System.out.println("2번째 문자: " + str1.charAt(1));
        System.out.println("부분 문자열: " + str2.substring(0, 2));
        System.out.println("포함 여부: " + str2.contains("va"));
        System.out.println("대문자 변환: " + str1.toUpperCase());

        // String vs StringBuilder
        StringBuilder sb = new StringBuilder("안녕");
        sb.append(" 자바");
        System.out.println(sb);
    }
}
```

### 1.7 입출력 기초

```java
import java.util.Scanner;

public class InputOutputExample {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        System.out.print("이름을 입력하세요: ");
        String name = sc.nextLine();

        System.out.print("나이를 입력하세요: ");
        int age = sc.nextInt();

        System.out.printf("안녕하세요, %s님! 나이는 %d세입니다.%n", name, age);

        sc.close();
    }
}
```



### 1.8 보충 개념

1.형 변환(Type Casting)

```java
public class CastingExample {
    public static void main(String[] args) {
        int i = 10;
        double d = i;   // 자동 형 변환
        System.out.println("자동 변환: " + d);

        double x = 9.7;
        int y = (int) x; // 강제 형 변환
        System.out.println("강제 변환: " + y);

        // Wrapper 클래스
        Integer num = Integer.valueOf(100); // Boxing
        int value = num.intValue();         // Unboxing
        System.out.println("Wrapper 클래스 사용: " + value);
    }
}
```

2.스코프(Scope)

```java
public class ScopeExample {
    int instanceVar = 10; // 인스턴스 변수
    static int classVar = 20; // 클래스 변수

    public static void main(String[] args) {
        int localVar = 5; // 지역 변수
        System.out.println("지역 변수: " + localVar);
        System.out.println("클래스 변수: " + classVar);
    }
}
```

3.null의 이해

```java
public class NullExample {
    public static void main(String[] args) {
        String str = null;

        if (str == null) {
            System.out.println("문자열이 null입니다.");
        }

        // NullPointerException 방지
        if (str != null && str.length() > 0) {
            System.out.println("문자열 길이: " + str.length());
        } else {
            System.out.println("문자열이 비어있거나 null입니다.");
        }
    }
}
```
