---
title: 7차시 7:React 2
layout: single
classes: wide
categories:
  - React
toc: true # 이 포스트에서 목차를 활성화
toc_sticky: true # 목차를 고정할지 여부 (선택 사항)
---

## 0.**실습용 게시판 만들기**
### 0.1 역할 분담
- 컴포넌트 목록을 그룹핑하면 이해하기 쉽다. 핵심은 "하나의 컴포넌트는 하나의 역할만 담당한다"는 원칙.

| 그룹 | 컴포넌트 | 역할 (초보자에게 설명할 내용) |
|------|----------|------------------------------|
| 최상위 관리자 | App.js | **총괄 본부** 역할. 로그인 정보, 게시물 목록 등 앱 전체에서 중요한 데이터(상태)를 관리하고, 각 페이지/컴포넌트의 노출을 조율합니다. |
| 페이지/뷰 | LoginPage.js, BoardList.js | **큰 화면** 역할. 특정 기능에 필요한 컴포넌트들을 모아 하나의 화면을 구성합니다. |
| 기능 단위 | Header.js, PostForm.js, CommentSection.js | **독립된 기능 모듈** 역할. 로그인 상태 표시, 새 게시물 작성, 댓글 묶음 표시 등 특정 기능을 담당합니다. |
| 최소 단위 | PostItem.js, CommentItem.js | **낱개 항목** 역할. 하나의 게시물 또는 하나의 댓글 등 반복되는 최소 단위 UI를 깔끔하게 표현하는 데 집중합니다. |


### 0.2 데이터 흐름
실습에서 가장 중요한 두 가지 데이터 흐름을 중점적으로 이해해야.
1. 게시물 데이터의 흐름 (하향식):
- App.js (전체 게시물 목록 상태 관리) → BoardList.js (목록 표시) → PostItem.js (개별 게시물 표시)
- 설명: 전체 데이터는 위(App)에서 아래(PostItem)로 흘러가며, 데이터가 변경되면 자동으로 아래 컴포넌트들(목록)이 업데이트됩니다.

2. 사용자 입력의 흐름 (상향식):
- PostForm.js (사용자 입력) → App.js (데이터 처리/상태 변경)
- 설명: 사용자가 게시물 폼에 내용을 입력하고 '저장'을 누르면, 이 데이터는 상위 컴포넌트인 App.js로 전달되어 전체 게시물 상태를 변경합니다.

### 0.3 권장 구현 순서

- **Phase 1: 기초 뼈대**
  1. **BoardList + PostItem** 조합부터 시작
    - 하드코딩 데이터로 게시물 목록 표시
    - 가장 시각적 피드백이 빠른 부분

  2. **Header** 추가
    - 정적 사용자 정보 표시

- **Phase 2: CRUD 구현**
  3. **PostForm** 추가
    - 게시물 작성 기능
    - 상태 끌어올리기(State Lifting) 개념 도입

  4. **수정/삭제 기능**
    - PostItem에 액션 버튼 추가

- **Phase 3: 상호작용 확장**
  5. **CommentSection + CommentItem**
    - 댓글 목록 표시

  6. **CommentForm**
    - 댓글 추가 기능

- **Phase 4: 인증 및 상태관리**
  7. **LoginPage**
    - 로그인 상태 관리

  8. **전체 상태 통합**
    - App.js에서 전체 상태 관리


## 1. App.js
- 전체 상태 관리 및 조율

```js
import React, { useState } from 'react';

import {LoginPage} from './components/LoginPage'
import {Header} from './components/Header'
import {PostForm} from './components/PostForm'
import {BoardList} from './components/BoardList'


// ==================== App.js ====================
function App() {
  const [user, setUser] = useState(null);
  const [posts, setPosts] = useState([]);
  const [editingId, setEditingId] = useState(null);
  const [formData, setFormData] = useState({ title: '', content: '' });

  const handleLogin = (username) => {
    setUser(username);
  };

  const handleLogout = () => {
    setUser(null);
    setEditingId(null);
    setFormData({ title: '', content: '' });
  };

  const handleSubmit = () => {
    if (!formData.title.trim() || !formData.content.trim()) {
      alert('제목과 내용을 입력해주세요');
      return;
    }

    if (editingId) {
      setPosts(posts.map(post =>
        post.id === editingId
          ? { ...post, title: formData.title, content: formData.content, updatedAt: new Date().toLocaleString('ko-KR') }
          : post
      ));
      setEditingId(null);
    } else {
      const newPost = {
        id: Date.now(),
        title: formData.title,
        content: formData.content,
        author: user,
        createdAt: new Date().toLocaleString('ko-KR'),
        updatedAt: new Date().toLocaleString('ko-KR'),
        comments: []
      };
      setPosts([newPost, ...posts]);
    }
    setFormData({ title: '', content: '' });
  };

  const handleDelete = (id) => {
    if (window.confirm('정말 삭제하시겠습니까?')) {
      setPosts(posts.filter(post => post.id !== id));
    }
  };

  const handleEdit = (post) => {
    setEditingId(post.id);
    setFormData({ title: post.title, content: post.content });
  };

  const handleAddComment = (postId, commentText) => {
    if (!commentText.trim()) return;
    setPosts(posts.map(post =>
      post.id === postId
        ? {
            ...post,
            comments: [...post.comments, {
              id: Date.now(),
              author: user,
              content: commentText,
              createdAt: new Date().toLocaleString('ko-KR')
            }]
          }
        : post
    ));
  };

  const handleDeleteComment = (postId, commentId) => {
    setPosts(posts.map(post =>
      post.id === postId
        ? { ...post, comments: post.comments.filter(c => c.id !== commentId) }
        : post
    ));
  };

  if (!user) {
    return <LoginPage onLogin={handleLogin} />;
  }

  return (
    <div>
      <Header user={user} onLogout={handleLogout} />
      
      <main style= {% raw %}{{ maxWidth: '800px', margin: '0 auto', padding: '20px' }}{% endraw %}>
        <PostForm
          formData={formData}
          setFormData={setFormData}
          editingId={editingId}
          onSubmit={handleSubmit}
          onCancel={() => {
            setEditingId(null);
            setFormData({ title: '', content: '' });
          }}
        />
        <BoardList
          posts={posts}
          currentUser={user}
          onEdit={handleEdit}
          onDelete={handleDelete}
          onAddComment={handleAddComment}
          onDeleteComment={handleDeleteComment}
        />
      </main>
    </div>
  );
}

export default App;

```

### **1.1 전반적인 구조와 목적**
- **단일 페이지 애플리케이션(SPA)** 형태로, 로그인 → 게시판 사용 흐름을 구현.
- **기능 범위**: 사용자 로그인/로그아웃, 게시글 작성/수정/삭제, 댓글 작성/삭제.
- **상태 관리**: `useState` 훅만 사용 → 복잡한 상태 관리 라이브러리 없이 React 기본 개념에 집중 가능.

### **1.2 핵심 React 개념 학습 포인트**
* **상태(State) 관리**
  - `user`: 현재 로그인한 사용자 이름 (null이면 로그아웃 상태).
  - `posts`: 게시글 목록 (각 게시글은 `id`, `title`, `content`, `author`, `createdAt`, `updatedAt`, `comments` 포함).
  - `editingId`: 수정 중인 게시글 ID.
  - `formData`: 입력 중인 제목/내용.

- **이벤트 핸들링**
  - `handleLogin`, `handleLogout`, `handleSubmit`, `handleEdit`, `handleDelete` 등
  - 폼 제출, 삭제 확인(`window.confirm`), 입력 유효성 검사(`trim()` 사용) 포함 → **실제 앱에서 필요한 UX 처리**를 경험.

- **불변성(Immutability) 준수**
  - 게시글/댓글 수정·삭제 시 `map`, `filter` 등을 사용해 기존 배열을 직접 변경하지 않고 **새 배열 생성**.
  - React에서 상태를 변경할 때 반드시 지켜야 할 핵심 원칙을 자연스럽게 실천.

- **컴포넌트 분리**
  - 각 기능별로 컴포넌트 분리 (`LoginPage`, `Header`, `PostForm`, `BoardList`, `PostItem`, `CommentSection` 등)
  - **재사용성**, **가독성**, **유지보수성** 향상 → React의 컴포넌트 기반 아키텍처 이해에 도움.

- **조건부 렌더링**
  - `if (!user) return <LoginPage ... />` → 로그인 여부에 따라 다른 화면 표시.
  - React에서 **UI를 상태에 따라 동적으로 제어**하는 방식을 잘 보여줌.

### **1.3. 개선 고려 사항**
- **ID 생성**: `Date.now()`는 충돌 가능성이 있음 → 실제 프로젝트에서는 UUID나 백엔드 ID 사용 권장.
- **데이터 영속성**: 새로고침 시 데이터 사라짐 → `localStorage`나 서버 연동으로 보완 가능.



## 2. LoginPage.js
- 로그인 화면

```js
import {useState} from 'react';

// ==================== LoginPage.js ====================
function LoginPage({ onLogin }) {
  const [input, setInput] = useState('');

  const handleSubmit = () => {
    if (input.trim()) {
      onLogin(input);
      setInput('');
    }
  };

  const loginStyle = {
    container: {
      display: 'flex',
      justifyContent: 'center',
      alignItems: 'center',
      height: '100vh',
      backgroundColor: '#f0f0f0'
    },
    box: {
      backgroundColor: 'white',
      padding: '30px',
      border: '1px solid #ddd',
      width: '300px'
    },
    title: {
      textAlign: 'center',
      marginBottom: '20px',
      fontSize: '24px'
    },
    inputBox: {
      marginBottom: '15px'
    },
    label: {
      display: 'block',
      marginBottom: '5px',
      fontWeight: 'bold'
    },
    input: {
      width: '100%',
      padding: '8px',
      border: '1px solid #ccc',
      boxSizing: 'border-box'
    },
    button: {
      width: '100%',
      padding: '10px',
      backgroundColor: '#007bff',
      color: 'white',
      border: 'none',
      cursor: 'pointer',
      fontSize: '16px'
    }
  };
  //&&:조건부 실행, Enter키일 때만 handleSubmit() 실행, 아니면 false 반환
  return (
    <div style={loginStyle.container}>
      <div style={loginStyle.box}>
        <h1 style={loginStyle.title}>게시판</h1>
        <div style={loginStyle.inputBox}>
          <label style={loginStyle.label}>사용자명</label>
          <input
            type="text"
            value={input}
            onChange={(e) => setInput(e.target.value)}
            onKeyPress={(e) => e.key === 'Enter' && handleSubmit()}
            placeholder="사용자명을 입력하세요"
            style={loginStyle.input}
          />
        </div>
        <button onClick={handleSubmit} style={loginStyle.button}>로그인</button>
      </div>
    </div>
  );
}

export {LoginPage}

```

### 2.1 **컴포넌트 구조 및 목적**
- `LoginPage`는 사용자명을 입력받아 로그인을 처리하는 UI 컴포넌트입니다.
- 로그인 성공 시 부모 컴포넌트에 사용자명을 전달하기 위해 `onLogin` 콜백 함수를 props로 받습니다.
- 상태는 `useState`를 사용해 `input`이라는 단일 문자열 상태로 관리합니다.

### 2.2 **기능 분석**
- **입력 처리**:  
  - `<input>` 요소는 제어된 컴포넌트(controlled component)로, `value={input}`과 `onChange` 핸들러를 통해 상태와 동기화됩니다.
- **로그인 트리거**:  
  - "로그인" 버튼 클릭 시 `handleSubmit` 함수가 실행됩니다.
  - 또한 `onKeyPress` 이벤트로 Enter 키 입력 시에도 로그인이 가능하도록 UX를 개선했습니다.
- **유효성 검사**:  
  - `input.trim()`을 통해 공백만 있는 입력은 무시되며, 유효한 사용자명이 있을 때만 `onLogin`이 호출
  - 로그인 후 입력 필드는 초기화됩니다(`setInput('')`).

### 2.3 **스타일링 방식**
- 인라인 스타일 객체(`loginStyle`)를 사용하여 컴포넌트 내부에 스타일을 정의했습니다.
  - 장점: 파일 분리 없이 빠르게 스타일 적용 가능.
  - 단점: 재사용성과 유지보수성이 낮음. 대규모 프로젝트에서는 CSS-in-JS나 CSS 모듈, 전역 스타일 시스템(예: Tailwind, styled-components)을 고려하는 것이 일반적입니다.

### 2.4 개선 여지
  - 비밀번호 입력 없이 사용자명만으로 로그인 → 실제 서비스에서는 보안상 부족.
  - 오류 메시지나 로딩 상태 등 피드백 UI가 없음.
  - 접근성(예: `<label>`의 `htmlFor`, ARIA 속성) 고려 필요.

### 2.5 **보안 및 실제 적용 측면**
- 이 코드는 **프로토타입 또는 학습용**으로 적합합니다.
- 실제 서비스에서는 다음을 추가해야 합니다:
  - HTTPS 통신
  - 비밀번호 입력 및 인증
  - CSRF/XSS 방지
  - 서버 측 인증 로직과 연동


## 3. Header.js
- 헤더 (사용자명, 로그아웃)

```js
// ==================== Header.js ====================
function Header({ user, onLogout }) {
  const headerStyle = {
    container: {
      backgroundColor: '#333',
      color: 'white',
      padding: '15px',
      display: 'flex',
      justifyContent: 'space-between',
      alignItems: 'center'
    },
    title: {
      margin: 0,
      fontSize: '20px'
    },
    userInfo: {
      display: 'flex',
      gap: '15px',
      alignItems: 'center'
    },
    button: {
      padding: '8px 15px',
      backgroundColor: '#dc3545',
      color: 'white',
      border: 'none',
      cursor: 'pointer'
    }
  };

  return (
    <header style={headerStyle.container}>
      <h1 style={headerStyle.title}>게시판</h1>
      <div style={headerStyle.userInfo}>
        <span>{user}님</span>
        <button onClick={onLogout} style={headerStyle.button}>로그아웃</button>
      </div>
    </header>
  );
}

export {Header}

```

### 3.1 **컴포넌트 구조 및 목적**
- **역할**: 사용자 인증 상태를 반영한 헤더 UI를 제공하며, 로그아웃 기능을 포함합니다.
- **props**:
  - `user`: 현재 로그인한 사용자의 이름(또는 식별자)을 나타내는 문자열.
  - `onLogout`: 로그아웃 버튼 클릭 시 실행되는 콜백 함수.

### 3.2 **스타일링 방식**
- **인라인 스타일 사용**: JavaScript 객체(`headerStyle`)로 모든 스타일을 정의하고, JSX 요소에 `style` 속성으로 적용.
  - 장점: 컴포넌트 내에서 스타일을 완전히 캡슐화할 수 있음.
  - 단점: 재사용성과 유지보수 측면에서 CSS 클래스나 CSS-in-JS 라이브러리보다 제한적일 수 있음.

### 3.3 **UI 구성 요소**
- **좌측**: `<h1>` 태그로 "게시판"이라는 고정된 제목 표시.
- **우측**:
  - 사용자 이름 표시 (`{user}님`)
  - 빨간색 "로그아웃" 버튼 (`#dc3545`는 Bootstrap의 danger 색상과 유사)

### 3.4 **상호작용**
- 로그아웃 버튼 클릭 시 `onLogout` 함수가 호출되어 부모 컴포넌트에서 정의된 로그아웃 로직이 실행됨.
- 이는 **부모-자식 간의 함수 전달**(Callback) 패턴으로, React에서 상태 변경을 자식 컴포넌트에서 트리거하는 일반적인 방식입니다.


## 4. PostForm.js
- 게시물 작성/수정 폼

```js
// ==================== PostForm.js ====================
function PostForm({ formData, setFormData, editingId, onSubmit, onCancel }) {
  const formStyle = {
    container: {
      backgroundColor: 'white',
      padding: '20px',
      border: '1px solid #ddd',
      marginBottom: '20px'
    },
    title: {
      marginTop: 0,
      marginBottom: '15px'
    },
    field: {
      marginBottom: '15px'
    },
    label: {
      display: 'block',
      marginBottom: '5px',
      fontWeight: 'bold'
    },
    input: {
      width: '100%',
      padding: '8px',
      border: '1px solid #ccc',
      boxSizing: 'border-box'
    },
    textarea: {
      width: '100%',
      padding: '8px',
      border: '1px solid #ccc',
      boxSizing: 'border-box',
      fontFamily: 'Arial'
    },
    buttonGroup: {
      display: 'flex',
      gap: '10px'
    },
    button: {
      padding: '10px 20px',
      backgroundColor: '#007bff',
      color: 'white',
      border: 'none',
      cursor: 'pointer'
    },
    cancelButton: {
      padding: '10px 20px',
      backgroundColor: '#6c757d',
      color: 'white',
      border: 'none',
      cursor: 'pointer'
    }
  };

  return (
    <div style={formStyle.container}>
      <h2 style={formStyle.title}>{editingId ? '게시물 수정' : '새 게시물 작성'}</h2>
      
      <div style={formStyle.field}>
        <label style={formStyle.label}>제목</label>
        <input
          type="text"
          value={formData.title}
          onChange={(e) => setFormData({ ...formData, title: e.target.value })}
          placeholder="제목을 입력하세요"
          style={formStyle.input}
        />
      </div>

      <div style={formStyle.field}>
        <label style={formStyle.label}>내용</label>
        <textarea
          value={formData.content}
          onChange={(e) => setFormData({ ...formData, content: e.target.value })}
          placeholder="내용을 입력하세요"
          rows="5"
          style={formStyle.textarea}
        />
      </div>

      <div style={formStyle.buttonGroup}>
        <button onClick={onSubmit} style={formStyle.button}>
          {editingId ? '수정' : '작성'}
        </button>
        {editingId && (
          <button onClick={onCancel} style={formStyle.cancelButton}>취소</button>
        )}
      </div>
    </div>
  );
}

export {PostForm}

```

### **4.1 컴포넌트 목적**
`PostForm`은 **게시물 작성 또는 수정을 위한 입력 폼 컴포넌트**입니다.  
- 새 게시물을 작성할 때와 기존 게시물을 수정할 때 모두 재사용됩니다.
- 상태(`formData`)와 상태 변경 함수(`setFormData`)를 부모로부터 props로 받아 사용합니다.

### **4.2 주요 Props**
- `formData`: 현재 입력 중인 제목(`title`)과 내용(`content`)을 담은 객체.
- `setFormData`: `formData`를 업데이트하는 함수.
- `editingId`: 수정 모드 여부를 판단하는 식별자 (존재하면 수정 모드).
- `onSubmit`: 폼 제출 시 호출되는 함수 (작성 또는 수정 처리).
- `onCancel`: 수정 모드에서 취소 버튼 클릭 시 호출되는 함수.

### **4.3 UI/스타일 구조**
- **인라인 스타일**로 모든 요소의 스타일을 정의 (`formStyle` 객체 사용).
- 반응형은 고려되지 않았으나, `width: '100%'`와 `boxSizing: 'border-box'`로 기본적인 레이아웃 안정성 확보.
- 버튼은 두 가지:
  - **제출 버튼**: 작성/수정에 따라 라벨 변경.
  - **취소 버튼**: 수정 모드일 때만 표시됨.

### **4.4 동작 흐름**
- 사용자가 제목 또는 내용을 입력하면, `onChange` 이벤트 핸들러가 `setFormData`를 통해 상태를 업데이트.
- 제출 버튼 클릭 시 `onSubmit` 호출 → 부모 컴포넌트에서 실제 저장/수정 로직 처리.
- 수정 중 취소 버튼 클릭 시 `onCancel` 호출 → 일반적으로 폼 초기화 또는 목록으로 복귀.

### 4.5 **개선 고려사항**
- **인라인 스타일의 한계**: 규모가 커지면 유지보수 어려움 → CSS-in-JS나 CSS 모듈 도입 고려.
- **폼 유효성 검사**: 현재는 없음 → 제목/내용 필수 입력 여부 등 검증 로직 추가 권장.


## 5. BoardList.js
- 게시물 목록

```js
// ==================== BoardList.js ====================
import {PostItem} from './PostItem';

function BoardList({ posts, currentUser, onEdit, onDelete, onAddComment, onDeleteComment }) {
  return (
    <div>
      {posts.length === 0 ? (
        
        <div style = {% raw %} {{ backgroundColor: 'white', padding: '20px', textAlign: 'center', color: '#999', border: '1px solid #ddd' }}{% endraw %}>
          작성된 게시물이 없습니다.
        </div>
        
      ) : (
        posts.map(post => (
          <PostItem
            key={post.id}
            post={post}
            currentUser={currentUser}
            onEdit={onEdit}
            onDelete={onDelete}
            onAddComment={onAddComment}
            onDeleteComment={onDeleteComment}
          />
        ))
      )}
    </div>
  );
}

export {BoardList}

```

### 5.1 **컴포넌트 역할**
- `BoardList`는 게시물(posts) 목록을 표시하는 **컨테이너 컴포넌트**입니다.
- 실제 게시물 항목은 별도의 `PostItem` 컴포넌트에 위임하여 **재사용성과 관심사 분리**를 달성합니다.

### 5.2 **Props 구조**
다음과 같은 props를 외부에서 받아 사용합니다:
- `posts`: 게시물 배열 (각 게시물은 `id`를 포함한 객체)
- `currentUser`: 현재 로그인한 사용자 정보
- `onEdit`, `onDelete`: 게시물 수정/삭제 핸들러
- `onAddComment`, `onDeleteComment`: 댓글 추가/삭제 핸들러

이를 통해 **부모 컴포넌트에서 상태와 로직을 관리**하고, `BoardList`는 순수하게 UI를 렌더링하는 역할에 집중합니다.

### 5.3 **렌더링 로직**
- **게시물 없음**: `posts.length === 0`일 경우, "작성된 게시물이 없습니다"라는 안내 메시지를 스타일과 함께 표시.
- **게시물 있음**: `posts.map()`을 사용해 각 게시물을 `PostItem` 컴포넌트로 렌더링하며, 필요한 props를 전달.

### 5.4 **스타일링**
- 게시물이 없을 때만 인라인 스타일을 사용해 시각적 피드백 제공:
  - 배경: 흰색
  - 패딩, 텍스트 정렬, 글자색, 테두리 등으로 사용자 친화적인 UI 구성

### 5.5 **디자인 원칙 반영**
- **조건부 렌더링**: 게시물 존재 여부에 따라 다른 UI를 표시
- **리스트 렌더링 최적화**: 각 `PostItem`에 고유한 `key={post.id}` 제공
- **프로퍼티 전달**: 모든 상호작용(수정, 삭제, 댓글 등)을 콜백 함수로 위임 → 상태 관리의 일관성 유지


## 6. PostItem.js
- 개별 게시물

```js
// ==================== PostItem.js ====================
import {CommentSection} from './CommentSection';

function PostItem({ post, currentUser, onEdit, onDelete, onAddComment, onDeleteComment }) {
  const postStyle = {
    container: {
      backgroundColor: 'white',
      padding: '20px',
      border: '1px solid #ddd',
      marginBottom: '15px'
    },
    header: {
      display: 'flex',
      justifyContent: 'space-between',
      alignItems: 'flex-start',
      marginBottom: '10px'
    },
    titleSection: {
      flex: 1
    },
    title: {
      margin: 0,
      marginBottom: '5px',
      fontSize: '18px'
    },
    meta: {
      color: '#666',
      fontSize: '12px'
    },
    buttons: {
      display: 'flex',
      gap: '5px'
    },
    editBtn: {
      padding: '5px 10px',
      backgroundColor: '#007bff',
      color: 'white',
      border: 'none',
      cursor: 'pointer',
      fontSize: '12px'
    },
    deleteBtn: {
      padding: '5px 10px',
      backgroundColor: '#dc3545',
      color: 'white',
      border: 'none',
      cursor: 'pointer',
      fontSize: '12px'
    },
    content: {
      marginBottom: '15px',
      lineHeight: '1.6'
    },
    commentSection: {
      borderTop: '1px solid #ddd',
      paddingTop: '15px',
      marginTop: '15px'
    }
  };

  return (
    <div style={postStyle.container}>
      <div style={postStyle.header}>
        <div style={postStyle.titleSection}>
          <h3 style={postStyle.title}>{post.title}</h3>
          <p style={postStyle.meta}>
            작성자: {post.author} | {post.createdAt}
          </p>
        </div>
        {post.author === currentUser && (
          <div style={postStyle.buttons}>
            <button onClick={() => onEdit(post)} style={postStyle.editBtn}>수정</button>
            <button onClick={() => onDelete(post.id)} style={postStyle.deleteBtn}>삭제</button>
          </div>
        )}
      </div>

      <p style={postStyle.content}>{post.content}</p>

      <div style={postStyle.commentSection}>
        <CommentSection
          post={post}
          currentUser={currentUser}
          onAddComment={onAddComment}
          onDeleteComment={onDeleteComment}
        />
      </div>
    </div>
  );
}

export {PostItem}

```

### 6.1 **목적 및 역할**
- **PostItem**은 게시물(Post) 하나를 화면에 렌더링하는 UI 컴포넌트입니다.
- 게시물의 제목, 작성자, 작성일, 본문 내용을 표시하고,  
  현재 로그인한 사용자(`currentUser`)가 해당 게시물의 작성자일 경우 **수정/삭제 버튼**을 제공합니다.
- 또한 하단에 **댓글 섹션**(CommentSection)을 포함하여 댓글 기능을 통합합니다.

### 6.2 **구조 및 구성 요소**

1. **Props**
   - `post`: 게시물 데이터 객체 (`title`, `author`, `content`, `createdAt`, `id` 등 포함)
   - `currentUser`: 현재 로그인한 사용자 이름 (또는 ID)
   - `onEdit`, `onDelete`: 게시물 수정/삭제를 트리거하는 콜백 함수
   - `onAddComment`, `onDeleteComment`: 댓글 추가/삭제를 위한 콜백 함수

2. **스타일 정의**
   - 모든 스타일이 **JavaScript 객체로 인라인 정의**되어 있음 (CSS-in-JS 방식)
   - 컨테이너, 헤더, 버튼, 콘텐츠, 댓글 섹션 등 각 요소에 대한 스타일이 명확히 분리됨
   - 반응형이나 재사용성 측면에서는 한계가 있으나, 간단한 프로토타입이나 학습용으로 적합

3. **조건부 렌더링**
   - `{post.author === currentUser && (...)}`:  
     현재 사용자가 게시물 작성자일 때만 **수정/삭제 버튼**을 표시 → 권한 기반 UI 구현

4. **하위 컴포넌트 사용**
   - `<CommentSection />`을 통해 댓글 기능을 모듈화하여 재사용성과 관심사 분리(SoC)를 달성


### 6.3 **장점**
- **단일 책임 원칙**(SRP): 게시물 표시에 집중하며, 댓글은 별도 컴포넌트로 위임
- **명확한 props 인터페이스**: 부모 컴포넌트와의 상호작용이 직관적
- **간결한 조건부 렌더링**: 권한 기반 UI를 간단히 구현

### 6.4 **개선 여지**
- **스타일 관리**: 인라인 스타일 대신 CSS 모듈, styled-components, 또는 외부 CSS 파일 사용을 고려하면 유지보수성이 향상됨
- **보안/검증**: `post.author === currentUser` 비교가 문자열 기반이므로, 실제 앱에서는 **ID 기반 비교**가 더 안전함 (예: `post.authorId === currentUser.id`)


## 7. CommentSection.js
- 댓글 섹션

```js
import {CommentItem} from './CommentItem.js'
import {CommentForm} from './CommentForm.js'

// ==================== CommentSection.js ====================
function CommentSection({ post, currentUser, onAddComment, onDeleteComment }) {
  return (
    <div>
      <h4 style={% raw %}{{ marginTop: 0 }}{% endraw %}>댓글 ({post.comments.length})</h4>
      <div style={% raw %}{{ marginBottom: '15px' }}{% endraw %}>
        {post.comments.map(comment => (
          <CommentItem
            key={comment.id}
            comment={comment}
            postId={post.id}
            currentUser={currentUser}
            onDelete={onDeleteComment}
          />
        ))}
      </div>
      <CommentForm onSubmit={(text) => onAddComment(post.id, text)} />
    </div>
  );
}

export {CommentSection}

```

### 7.1 **구성 요소**
1. **외부 컴포넌트 임포트**
   - `CommentItem`: 개별 댓글을 표시하고 삭제 기능을 제공하는 컴포넌트.
   - `CommentForm`: 새로운 댓글을 입력하고 제출할 수 있는 폼 컴포넌트.

2. **props로 전달되는 데이터 및 함수**
   - `post`: 현재 게시물 객체. `comments` 배열과 `id`를 포함.
   - `currentUser`: 현재 로그인한 사용자 정보.
   - `onAddComment`: 새 댓글을 추가할 때 호출되는 콜백 함수.
   - `onDeleteComment`: 댓글을 삭제할 때 호출되는 콜백 함수.

### 7.2 **렌더링 구조**
- **댓글 수 표시**: `<h4>` 태그로 "댓글 (N)" 형태로 댓글 개수 표시.
- **댓글 목록**: `post.comments` 배열을 `map`으로 순회하며 각 댓글에 대해 `CommentItem`을 렌더링.
  - 각 `CommentItem`에는 고유 `key`, 댓글 데이터, 게시물 ID, 현재 사용자 정보, 삭제 핸들러가 전달됨.
- **댓글 작성 폼**: `CommentForm`을 하단에 배치하며, 폼 제출 시 `onAddComment(post.id, text)` 호출.

### 7.3 **역할과 책임**
- **UI 조합**: `CommentItem`과 `CommentForm`을 조합하여 댓글 섹션 전체를 구성.
- **데이터 흐름**: 상태(예: 댓글 목록)는 외부에서 관리되며, 이 컴포넌트는 단지 **프레젠테이션** 역할을 수행 (컨테이너/프레젠테이션 패턴).
- **이벤트 위임**: 실제 댓글 추가/삭제 로직은 부모 컴포넌트에서 관리되며, 여기서는 단지 이벤트를 전달함.


## 8. CommentItem.js
- 개별 댓글

```js
// ==================== CommentItem.js ====================
function CommentItem({ comment, postId, currentUser, onDelete }) {
  const commentStyle = {
    container: {
      backgroundColor: '#f9f9f9',
      padding: '10px',
      marginBottom: '10px',
      border: '1px solid #eee'
    },
    header: {
      display: 'flex',
      justifyContent: 'space-between',
      marginBottom: '5px'
    },
    meta: {
      color: '#666',
      fontSize: '12px'
    },
    content: {
      color: '#333'
    },
    deleteBtn: {
      color: '#dc3545',
      backgroundColor: 'transparent',
      border: 'none',
      cursor: 'pointer',
      fontSize: '12px'
    }
  };

  return (
    <div style={commentStyle.container}>
      <div style={commentStyle.header}>
        <span style={commentStyle.meta}>
          <strong>{comment.author}</strong> - {comment.createdAt}
        </span>
        {comment.author === currentUser && (
          <button
            onClick={() => onDelete(postId, comment.id)}
            style={commentStyle.deleteBtn}
          >
            삭제
          </button>
        )}
      </div>
      <p style={commentStyle.content}>{comment.content}</p>
    </div>
  );
}

export {CommentItem}

```

### **8.1 컴포넌트 개요**
- **목적**: 게시물(post)에 달린 단일 댓글을 렌더링하고, 작성자 본인인 경우 삭제 기능을 제공하는 **React 함수형 컴포넌트**입니다.
- **프롭스**(Props):
  - `comment`: 댓글 데이터 객체 (`author`, `createdAt`, `content`, `id` 등을 포함)
  - `postId`: 해당 댓글이 속한 게시물의 ID
  - `currentUser`: 현재 로그인한 사용자 이름
  - `onDelete`: 댓글 삭제를 트리거하는 콜백 함수

### **8.2 스타일링 방식**
- **인라인 스타일**(Inline Styles) 사용:
  - 모든 스타일이 JavaScript 객체(`commentStyle`)로 정의되어 있음.
  - 장점: 로컬 스코프 유지, 별도 CSS 파일 불필요
  - 단점: 재사용성 낮음, 반응형/미디어 쿼리 지원 어려움


### **8.3 주요 로직**
- **조건부 렌더링**:
  - `comment.author === currentUser`일 때만 삭제 버튼이 표시됨 → **권한 기반 UI**
- **삭제 동작**:
  - 삭제 버튼 클릭 시 `onDelete(postId, comment.id)` 호출 → 부모 컴포넌트에서 실제 삭제 로직 처리

### **8.4 개선 가능성**
- **시맨틱 구조**: `<div>`와 `<p>`를 사용하여 기본적인 구조는 갖추고 있으나, 더 나은 접근성을 위해 `<article>` 또는 `<section>` 사용 고려 가능
- **스타일 분리**: CSS-in-JS 라이브러리(예: styled-components)나 별도 CSS 모듈로 이동하여 유지보수성 향상
- **에러 처리**: `comment`나 `currentUser`가 `undefined`일 경우 대비
- **날짜 포맷팅**: `comment.createdAt`이 원시 문자열이라면, 국제화(i18n) 또는 `Date` 객체 기반 포맷팅 적용 고려


## 9. CommentForm.js
- 댓글 입력 폼

```js
// ==================== CommentForm.js ====================
import {useState} from 'react';

function CommentForm({ onSubmit }) {
  const [input, setInput] = useState('');

  const handleSubmit = () => {
    onSubmit(input);
    setInput('');
  };

  const formStyle = {
    container: {
      display: 'flex',
      gap: '5px'
    },
    input: {
      flex: 1,
      padding: '8px',
      border: '1px solid #ccc'
    },
    button: {
      padding: '8px 15px',
      backgroundColor: '#007bff',
      color: 'white',
      border: 'none',
      cursor: 'pointer'
    }
  };

  return (
    <div style={formStyle.container}>
      <input
        type="text"
        value={input}
        onChange={(e) => setInput(e.target.value)}
        onKeyPress={(e) => e.key === 'Enter' && handleSubmit()}
        placeholder="댓글을 입력하세요"
        style={formStyle.input}
      />
      <button onClick={handleSubmit} style={formStyle.button}>등록</button>
    </div>
  );
}

export {CommentForm}

```

### **9.1 목적과 기능**
- `CommentForm` 컴포넌트는 사용자가 댓글을 입력하고 제출할 수 있는 간단한 폼(form)을 제공합니다.
- 입력된 텍스트는 부모 컴포넌트로 전달되며, 입력 필드는 제출 후 초기화됩니다.

### **9.2 주요 구성 요소**

- **상태 관리 (`useState`)**
  - `input` 상태: 사용자가 입력한 텍스트를 저장합니다.
  - `setInput`: 입력 필드의 값이 변경될 때마다 상태를 갱신합니다.

- **이벤트 핸들러**
  - `handleSubmit`:  
    - `onSubmit` 콜백을 통해 현재 입력값을 부모 컴포넌트에 전달합니다.  
    - 이후 입력 필드를 빈 문자열로 초기화하여 UI를 리셋합니다.
  - `onChange`: 입력 필드 값 변경 시 상태를 업데이트.
  - `onKeyPress`: Enter 키 입력 시 `handleSubmit`을 호출하여 폼 제출을 지원.

- **스타일링**
  - 인라인 스타일 객체(`formStyle`)를 사용하여:
    - 컨테이너: Flexbox로 구성, 자식 요소 간 간격(gap) 적용.
    - 입력 필드: 유연한 너비(`flex: 1`), 기본 테두리 및 패딩.
    - 버튼: 파란 배경, 흰색 텍스트, 포인터 커서, 테두리 없음.

### **9.3 개선 여지**
- **유효성 검사**: 빈 문자열 제출 방지 (`input.trim()` 체크).
- **버튼 타입 명시**: `<button type="button">`으로 명확히 지정 (폼 내부에서 의도치 않은 제출 방지).
- **스타일 분리**: 재사용성과 유지보수를 위해 CSS 모듈 또는 스타일드 컴포넌트 고려.
