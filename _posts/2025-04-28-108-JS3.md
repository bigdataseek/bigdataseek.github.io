---
title: 7차시 6:JavaScript 3
layout: single
classes: wide
categories:
  - JS
toc: true # 이 포스트에서 목차를 활성화
toc_sticky: true # 목차를 고정할지 여부 (선택 사항)
---

## 1. 비동기가 뭔가요? 🤔

### 1.1 일상생활 비유
**동기(Synchronous) 방식**: 식당에서 주문하고 음식이 나올 때까지 **서서 기다리기**
- 음식 나올 때까지 아무것도 못함
- 다음 손님은 앞 사람이 끝날 때까지 대기

**비동기(Asynchronous) 방식**: 주문하고 **진동벨 받고 자리에 앉아서 기다리기**
- 음식 준비되는 동안 다른 일 할 수 있음
- 여러 주문을 동시에 처리 가능



### 1.2 코드로 이해하기

```js
// 동기 방식 (Synchronous)
console.log('1. 주문합니다');
console.log('2. 음식을 만듭니다...(5초 대기)');
console.log('3. 음식 완성!');
console.log('4. 다음 손님 주문 받기');

// 출력 순서: 1 → 2 → 3 → 4 (순서대로)

// 비동기 방식 (Asynchronous)
console.log('1. 주문합니다');
setTimeout(() => {
  console.log('3. 음식 완성!');
}, 3000); // 3초 후 실행
console.log('2. 다른 일 하기');

// 출력 순서: 1 → 2 → (3초 후) 3
// 음식 만드는 동안 다른 일을 먼저 함!
```



### 1.3 왜 비동기가 필요한가?

JavaScript는 **단일 스레드(Single Thread)** 언어입니다.
- 한 번에 한 가지 일만 처리 가능
- 시간이 오래 걸리는 작업이 있으면 전체가 멈춤 (Blocking)

**시간이 걸리는 작업들:**
```js
// 1. 서버에서 데이터 가져오기 (네트워크 요청)
fetch('https://api.example.com/data') // 1~2초

// 2. 파일 읽기
readFile('large-file.txt') // 수 초

// 3. 타이머
setTimeout(() => {}, 5000) // 5초

// 4. 사용자 입력 대기
prompt('이름을 입력하세요') // 사용자가 입력할 때까지
```

비동기 처리가 없으면 **화면이 멈춰버립니다!** ❌



## 2. 콜백(Callback) 함수 - 비동기의 시작

### 2.1 콜백 함수란?
**"나중에 호출될 함수"** - 작업이 끝나면 실행해줄 함수를 미리 전달

```js
// 기본 개념
function greeting(name) {
  console.log(`안녕하세요, ${name}님!`);
}

function processUser(callback) {
  const name = '철수';
  callback(name); // 콜백 함수 호출
}

processUser(greeting); // '안녕하세요, 철수님!'
```



### 2.2 setTimeout - 가장 기본적인 비동기

```js
// 기본 문법
setTimeout(함수, 시간);

// 예제 1: 3초 후 실행
console.log('시작');
setTimeout(() => {
  console.log('3초 후 실행됨!');
}, 3000);
console.log('끝');

// 출력:
// 시작
// 끝
// (3초 후) 3초 후 실행됨!

// 예제 2: 실용적인 사용
function showMessage(message, delay) {
  setTimeout(() => {
    console.log(message);
  }, delay);
}

showMessage('1초 후', 1000);
showMessage('2초 후', 2000);
showMessage('3초 후', 3000);
```



### 2.3 setInterval - 반복 실행

```js
// 기본 문법
setInterval(함수, 간격);

// 예제: 1초마다 실행
let count = 0;
const timer = setInterval(() => {
  count++;
  console.log(`${count}초 경과`);
  
  if (count === 5) {
    clearInterval(timer); // 타이머 중지
    console.log('타이머 종료!');
  }
}, 1000);

// 출력:
// 1초 경과
// 2초 경과
// 3초 경과
// 4초 경과
// 5초 경과
// 타이머 종료!
```



### 2.4 콜백 지옥 (Callback Hell) ⚠️

콜백이 중첩되면 코드가 복잡해집니다.

```js
// 나쁜 예: 콜백 지옥
setTimeout(() => {
  console.log('1. 사용자 정보 가져오기');
  setTimeout(() => {
    console.log('2. 사용자 게시물 가져오기');
    setTimeout(() => {
      console.log('3. 게시물 댓글 가져오기');
      setTimeout(() => {
        console.log('4. 댓글 작성자 정보 가져오기');
        // 계속 중첩... 😱
      }, 1000);
    }, 1000);
  }, 1000);
}, 1000);

// 코드가 오른쪽으로 계속 들여쓰기 됨 (가독성 최악!)
```

**이 문제를 해결하기 위해 Promise가 등장했습니다!** 👇



## 3. Promise - 비동기의 혁명 ⭐⭐⭐

### 3.1 Promise란?
**"미래에 완료될 작업을 표현하는 객체"**

비유: 
- 음식점에서 받는 **진동벨 번호표**
- 지금은 음식이 없지만, 나중에 받을 것이라는 **약속(Promise)**



### 3.2 Promise의 3가지 상태

```js
// 1. Pending (대기): 아직 결과가 없음
// 2. Fulfilled (이행): 성공적으로 완료됨
// 3. Rejected (거부): 실패함

const promise = new Promise((resolve, reject) => {
  // 비동기 작업 수행
  const success = true;
  
  if (success) {
    resolve('성공!'); // Fulfilled 상태로
  } else {
    reject('실패!');  // Rejected 상태로
  }
});
```



### 3.3 Promise 기본 사용법

```js
// Promise 생성
function delay(ms) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(`${ms}ms 대기 완료!`);
    }, ms);
  });
}

// Promise 사용
delay(2000)
  .then((result) => {
    console.log(result); // '2000ms 대기 완료!'
    return '다음 작업';
  })
  .then((result) => {
    console.log(result); // '다음 작업'
  })
  .catch((error) => {
    console.error('에러 발생:', error);
  });
```



### 3.4 실전 예제: 사용자 데이터 가져오기

```js
// 가짜 API 함수들
function getUser(id) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (id > 0) {
        resolve({ id: id, name: '철수', age: 25 });
      } else {
        reject('잘못된 사용자 ID');
      }
    }, 1000);
  });
}

function getPosts(userId) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve([
        { id: 1, title: '첫 게시물', userId: userId },
        { id: 2, title: '두번째 게시물', userId: userId }
      ]);
    }, 1000);
  });
}

function getComments(postId) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve([
        { id: 1, text: '좋아요!', postId: postId },
        { id: 2, text: '멋져요!', postId: postId }
      ]);
    }, 1000);
  });
}

// Promise 체이닝으로 순차 실행
getUser(1)
  .then(user => {
    console.log('1. 사용자:', user);
    return getPosts(user.id);
  })
  .then(posts => {
    console.log('2. 게시물:', posts);
    return getComments(posts[0].id);
  })
  .then(comments => {
    console.log('3. 댓글:', comments);
  })
  .catch(error => {
    console.error('에러:', error);
  });

// 훨씬 깔끔하죠? 😊
```



### 3.5 Promise 실패 처리

```js
function riskyOperation() {
  return new Promise((resolve, reject) => {
    const random = Math.random();
    
    setTimeout(() => {
      if (random > 0.5) {
        resolve('성공! 🎉');
      } else {
        reject('실패... 😢');
      }
    }, 1000);
  });
}

// 에러 처리 방법 1: .catch()
riskyOperation()
  .then(result => {
    console.log(result);
  })
  .catch(error => {
    console.error('에러 발생:', error);
  });

// 에러 처리 방법 2: .then()의 두 번째 인자
riskyOperation()
  .then(
    result => console.log('성공:', result),
    error => console.error('실패:', error)
  );

// 에러 처리 방법 3: .finally() (항상 실행)
riskyOperation()
  .then(result => console.log(result))
  .catch(error => console.error(error))
  .finally(() => {
    console.log('작업 완료! (성공이든 실패든)');
  });
```



### 3.6 Promise 유틸리티 메서드

```js
// 1. Promise.all() - 모두 성공해야 성공
const promise1 = delay(1000);
const promise2 = delay(2000);
const promise3 = delay(3000);

Promise.all([promise1, promise2, promise3])
  .then(results => {
    console.log('모두 완료!', results);
    // 3초 후: ['1000ms 대기 완료!', '2000ms 대기 완료!', '3000ms 대기 완료!']
  });

// 실용 예제: 여러 API 동시 호출
Promise.all([
  getUser(1),
  getUser(2),
  getUser(3)
])
  .then(users => {
    console.log('모든 사용자:', users);
  });

// 2. Promise.race() - 가장 먼저 완료되는 것 반환
Promise.race([
  delay(1000),
  delay(2000),
  delay(3000)
])
  .then(result => {
    console.log('가장 빠른 것:', result);
    // 1초 후: '1000ms 대기 완료!'
  });

// 3. Promise.allSettled() - 모든 결과 반환 (성공/실패 무관)
Promise.allSettled([
  Promise.resolve('성공 1'),
  Promise.reject('실패 1'),
  Promise.resolve('성공 2')
])
  .then(results => {
    console.log(results);
    // [
    //   { status: 'fulfilled', value: '성공 1' },
    //   { status: 'rejected', reason: '실패 1' },
    //   { status: 'fulfilled', value: '성공 2' }
    // ]
  });

// 4. Promise.any() - 하나라도 성공하면 성공
Promise.any([
  Promise.reject('실패 1'),
  Promise.resolve('성공!'),
  Promise.reject('실패 2')
])
  .then(result => {
    console.log(result); // '성공!'
  });
```



## 4. async/await - 최신 비동기 문법 ⭐⭐⭐⭐⭐

### 4.1 async/await란?
**Promise를 더 쉽게 사용하는 문법** (Promise의 syntactic sugar)
- 비동기 코드를 **동기 코드처럼** 작성 가능
- **가장 많이 사용되는 현대적인 방법**



### 4.2 기본 문법

```js
// async 함수 선언
async function myFunction() {
  return '안녕하세요';
}

// async 함수는 항상 Promise를 반환
myFunction().then(result => console.log(result)); // '안녕하세요'

// await: Promise가 완료될 때까지 대기
async function waitExample() {
  console.log('시작');
  
  const result = await delay(2000); // 2초 대기
  console.log(result); // '2000ms 대기 완료!'
  
  console.log('끝');
}

waitExample();
```



### 4.3 Promise vs async/await 비교

```js
// Promise 방식
function getUserDataPromise() {
  return getUser(1)
    .then(user => {
      console.log('사용자:', user);
      return getPosts(user.id);
    })
    .then(posts => {
      console.log('게시물:', posts);
      return getComments(posts[0].id);
    })
    .then(comments => {
      console.log('댓글:', comments);
    })
    .catch(error => {
      console.error('에러:', error);
    });
}

// async/await 방식 (훨씬 읽기 쉬움!)
async function getUserDataAsync() {
  try {
    const user = await getUser(1);
    console.log('사용자:', user);
    
    const posts = await getPosts(user.id);
    console.log('게시물:', posts);
    
    const comments = await getComments(posts[0].id);
    console.log('댓글:', comments);
    
  } catch (error) {
    console.error('에러:', error);
  }
}

// 동기 코드처럼 보이지만 비동기입니다! 🎉
```



### 4.4 에러 처리: try-catch

```js
async function fetchUserData(id) {
  try {
    // 정상 실행 코드
    const user = await getUser(id);
    const posts = await getPosts(user.id);
    
    return {
      user,
      posts
    };
    
  } catch (error) {
    // 에러 발생 시 실행
    console.error('데이터 가져오기 실패:', error);
    return null;
    
  } finally {
    // 성공/실패 상관없이 항상 실행
    console.log('작업 완료');
  }
}

// 사용
const data = await fetchUserData(1);
if (data) {
  console.log('데이터:', data);
} else {
  console.log('데이터 없음');
}
```



### 4.5 병렬 처리: Promise.all과 함께 사용

```js
// 나쁜 예: 순차 실행 (느림)
async function getDataSequential() {
  const user1 = await getUser(1); // 1초 대기
  const user2 = await getUser(2); // 1초 대기
  const user3 = await getUser(3); // 1초 대기
  // 총 3초 걸림!
  
  return [user1, user2, user3];
}

// 좋은 예: 병렬 실행 (빠름)
async function getDataParallel() {
  const [user1, user2, user3] = await Promise.all([
    getUser(1),
    getUser(2),
    getUser(3)
  ]);
  // 총 1초만 걸림! (동시 실행)
  
  return [user1, user2, user3];
}

// 실전 예제: 여러 API 동시 호출
async function getDashboardData() {
  try {
    const [users, posts, comments, stats] = await Promise.all([
      fetch('/api/users').then(r => r.json()),
      fetch('/api/posts').then(r => r.json()),
      fetch('/api/comments').then(r => r.json()),
      fetch('/api/stats').then(r => r.json())
    ]);
    
    return { users, posts, comments, stats };
    
  } catch (error) {
    console.error('대시보드 로딩 실패:', error);
  }
}
```



### 4.6 실전 패턴들

#### 1) 순차 처리 (이전 결과가 필요할 때)
```js
async function processSteps() {
  // 단계 1
  const step1 = await doStep1();
  console.log('단계 1 완료:', step1);
  
  // 단계 2 (step1 결과 필요)
  const step2 = await doStep2(step1);
  console.log('단계 2 완료:', step2);
  
  // 단계 3 (step2 결과 필요)
  const step3 = await doStep3(step2);
  console.log('단계 3 완료:', step3);
  
  return step3;
}
```

#### 2) 조건부 비동기 처리
```js
async function smartFetch(useCache) {
  if (useCache) {
    const cached = getCachedData();
    if (cached) return cached;
  }
  
  try {
    const data = await fetch('/api/data').then(r => r.json());
    saveToCache(data);
    return data;
  } catch (error) {
    console.error('데이터 가져오기 실패');
    return null;
  }
}
```

#### 3) 반복문에서 사용
```js
// 순차 처리
async function processUsersSequential(userIds) {
  const results = [];
  
  for (const id of userIds) {
    const user = await getUser(id); // 하나씩 처리
    results.push(user);
  }
  
  return results;
}

// 병렬 처리
async function processUsersParallel(userIds) {
  const promises = userIds.map(id => getUser(id));
  const results = await Promise.all(promises);
  return results;
}

// 사용 예
const userIds = [1, 2, 3, 4, 5];
const users = await processUsersParallel(userIds);
```

#### 4) 재시도 로직
```js
async function fetchWithRetry(url, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      const response = await fetch(url);
      return await response.json();
      
    } catch (error) {
      console.log(`시도 ${i + 1} 실패`);
      
      if (i === maxRetries - 1) {
        throw new Error('최대 재시도 횟수 초과');
      }
      
      // 1초 대기 후 재시도
      await delay(1000);
    }
  }
}
```



## 5. fetch API - 실전 HTTP 요청 ⭐⭐⭐

### 5.1 fetch란?
**서버와 통신하는 JavaScript 내장 함수**

```js
// 기본 문법
fetch(URL)
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error(error));

// async/await와 함께 (권장)
async function getData() {
  try {
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error('에러:', error);
  }
}
```



### 5.2 GET 요청 - 데이터 가져오기

```js
// 기본 GET 요청
async function getUsers() {
  try {
    const response = await fetch('https://jsonplaceholder.typicode.com/users');
    
    // 응답 상태 확인
    if (!response.ok) {
      throw new Error(`HTTP 에러! 상태: ${response.status}`);
    }
    
    const users = await response.json();
    console.log('사용자 목록:', users);
    return users;
    
  } catch (error) {
    console.error('사용자 가져오기 실패:', error);
    return [];
  }
}

// 특정 사용자 가져오기
async function getUser(id) {
  const response = await fetch(`https://jsonplaceholder.typicode.com/users/${id}`);
  const user = await response.json();
  return user;
}

// 쿼리 파라미터와 함께
async function searchPosts(keyword) {
  const url = `https://api.example.com/posts?search=${keyword}&limit=10`;
  const response = await fetch(url);
  const posts = await response.json();
  return posts;
}
```



### 5.3 POST 요청 - 데이터 보내기

```js
async function createUser(userData) {
  try {
    const response = await fetch('https://jsonplaceholder.typicode.com/users', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(userData)
    });
    
    const newUser = await response.json();
    console.log('생성된 사용자:', newUser);
    return newUser;
    
  } catch (error) {
    console.error('사용자 생성 실패:', error);
    throw error;
  }
}

// 사용 예
const userData = {
  name: '철수',
  email: 'chulsu@example.com',
  age: 25
};

createUser(userData);
```



### 5.4 PUT/PATCH 요청 - 데이터 수정

```js
// PUT: 전체 수정
async function updateUser(id, userData) {
  const response = await fetch(`https://api.example.com/users/${id}`, {
    method: 'PUT',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(userData)
  });
  
  return await response.json();
}

// PATCH: 부분 수정
async function patchUser(id, updates) {
  const response = await fetch(`https://api.example.com/users/${id}`, {
    method: 'PATCH',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(updates)
  });
  
  return await response.json();
}

// 사용 예
patchUser(1, { age: 26 }); // 나이만 수정
```



### 5.5 DELETE 요청 - 데이터 삭제

```js
async function deleteUser(id) {
  try {
    const response = await fetch(`https://api.example.com/users/${id}`, {
      method: 'DELETE'
    });
    
    if (response.ok) {
      console.log('삭제 성공');
      return true;
    } else {
      throw new Error('삭제 실패');
    }
    
  } catch (error) {
    console.error('삭제 에러:', error);
    return false;
  }
}
```



### 5.6 실전 예제: 완전한 CRUD

```js
// API 클래스로 관리
class UserAPI {
  constructor(baseURL) {
    this.baseURL = baseURL;
  }
  
  // 모든 사용자 가져오기
  async getAll() {
    const response = await fetch(`${this.baseURL}/users`);
    return await response.json();
  }
  
  // 특정 사용자 가져오기
  async getById(id) {
    const response = await fetch(`${this.baseURL}/users/${id}`);
    return await response.json();
  }
  
  // 사용자 생성
  async create(userData) {
    const response = await fetch(`${this.baseURL}/users`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(userData)
    });
    return await response.json();
  }
  
  // 사용자 수정
  async update(id, userData) {
    const response = await fetch(`${this.baseURL}/users/${id}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(userData)
    });
    return await response.json();
  }
  
  // 사용자 삭제
  async delete(id) {
    const response = await fetch(`${this.baseURL}/users/${id}`, {
      method: 'DELETE'
    });
    return response.ok;
  }
}

// 사용
const api = new UserAPI('https://jsonplaceholder.typicode.com');

async function example() {
  // 생성
  const newUser = await api.create({ name: '철수', email: 'chulsu@example.com' });
  
  // 조회
  const users = await api.getAll();
  const user = await api.getById(1);
  
  // 수정
  const updated = await api.update(1, { name: '영희' });
  
  // 삭제
  const deleted = await api.delete(1);
}
```



### 5.7 에러 처리 및 로딩 상태 관리

```js
async function fetchWithStatus(url) {
  let isLoading = true;
  let error = null;
  let data = null;
  
  try {
    console.log('로딩 중...');
    
    const response = await fetch(url);
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    data = await response.json();
    console.log('로딩 완료!');
    
  } catch (err) {
    error = err.message;
    console.error('에러 발생:', error);
    
  } finally {
    isLoading = false;
  }
  
  return { data, error, isLoading };
}

// 사용
const result = await fetchWithStatus('https://api.example.com/data');
if (result.error) {
  console.log('에러:', result.error);
} else {
  console.log('데이터:', result.data);
}
```



