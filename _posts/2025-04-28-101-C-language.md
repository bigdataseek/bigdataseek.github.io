---
title: 38차시 1:C language
layout: single
classes: wide
categories:
  - C
toc: true # 이 포스트에서 목차를 활성화
toc_sticky: true # 목차를 고정할지 여부 (선택 사항)
---

## 1차시: C 프로그래밍 기초 강의

### 1.1 학습 내용
- **C 언어의 역사와 특징**: 
    *   1972년 데니스 리치(Dennis Ritchie)가 벨 연구소에서 개발했으며, 유닉스 OS 구현을 위해 설계. 
    *   구조적 프로그래밍을 지원하며, 포인터와 메모리 관리 같은 저수준 기능과 높은 실행 효율성이 특징
    *   이식성이 뛰어나 다양한 하드웨어 플랫폼에서 사용 가능하며, 많은 현대 언어(C++, Java 등)의 기반. 
- **C 언어의 응용 분야**: 
    *   C 언어는 운영체제(예: Linux 커널), 임베디드 시스템(마이크로컨트롤러 프로그래밍), 게임 엔진(예: Unreal Engine의 일부), 데이터베이스 소프트웨어(MySQL), 네트워크 드라이버 등 다양한 분야 
- **개발 환경 설치 (컴파일러, 에디터)**: 
    *   초보자를 위해 GCC(오픈소스 컴파일러) 설치 방법을 Windows, macOS, Linux별로 단계별로 안내
    *   예를 들어, Windows에서는 MinGW를 사용해 GCC를 설치하고, 환경 변수 PATH를 설정하는 과정을 설명합니다. 또한 Visual Studio Code(VS Code)나 CLion 같은 편집기에서 C 언어 확장 프로그램을 설치하고, 디버깅 환경을 설정하는 방법도 다룹니다.     
- **첫 번째 프로그램 작성하기**: 
    *   C 언어 프로그램의 기본 구조(헤더 포함, main 함수, 반환값)를 설명하고, 첫 프로그램으로 "Hello, World!"를 출력하는 과정을 다룹니다. 
    *   코드 작성부터 컴파일(`gcc file.c -o file`), 실행(`./file`)까지의 전 과정을 실제 예제를 통해 보여주며, 각 코드 줄(예: `#include <stdio.h>`, `return 0`)의 역할과 의미를 상세히 설명합니다.

### 1.2 주요 소스 코드

```c
#include <stdio.h> // 표준 입출력 함수를 사용하기 위한 헤더 파일 포함

int main() { // 프로그램의 진입점, 모든 C 프로그램은 main 함수에서 시작
    printf("Hello, World!\n"); // 화면에 "Hello, World!"를 출력하고 줄바꿈(\n)
    return 0; // 프로그램을 성공적으로 종료했음을 운영체제에 알림 (0은 성공)
}
```

- **코드 설명**: 
    *   이 코드는 C 언어의 가장 기본적인 예제입니다. 
    *   `#include <stdio.h>`는 입출력 함수(printf 등)를 사용하기 위해 필요한 헤더 파일을 포함합니다. 
    *   `int main()`은 프로그램의 시작점이며, `printf`는 콘솔에 텍스트를 출력하는 함수입니다. 
    *   `\n`은 줄바꿈을 의미하며, 
    *   `return 0`은 프로그램이 정상 종료되었음을 나타냅니다. 
    

### 1.3 실습 내용
- **개발 환경 설치 및 설정**: 
    *   실습에서는 GCC를 설치하고, 터미널에서 `gcc --version` 명령어를 실행해 설치 여부를 확인. 
    *   Windows 사용자는 MinGW 설치 후 환경 변수 설정을, macOS/Linux 사용자는 Homebrew나 apt를 통해 GCC를 설치합니다. 
    *   VS Code에서는 C/C++ 확장 프로그램을 설치하고, 간단한 C 파일을 저장/컴파일할 수 있도록 설정 파일(tasks.json, launch.json)을 구성합니다. 
- **Hello World 프로그램 작성 및 실행**: 
    *   학습자는 텍스트 에디터(VS Code 등)에서 위의 소스 코드를 작성하고, 파일을 `hello.c`로 저장. 
    *   터미널에서 `gcc hello.c -o hello` 명령어로 컴파일하고, `./hello` (Windows에서는 `hello.exe`)로 실행해 "Hello, World!" 출력 결과를 확인합니다. 
- **간단한 코드 수정해보기**: 
    *   학습자는 `printf` 문을 수정해 다른 메시지(예: "My name is $\[이름\]$!")를 출력하거나, 여러 줄의 출력문을 추가해 봅니다. 
    *   예를 들어, `printf("Welcome to C!\n");`를 추가하거나, 출력 형식을 변경(예: `printf("Number: %d\n", 42);`)해 보는 실습을 진행합니다.
    

## 2차시: 데이터 타입, 변수, 연산자

### 2.1 학습 내용
- **기본 데이터 타입 (int, float, double, char)**: 
    *   `int`는 정수(예: 10, -5)를 저장하며, 4바이트 크기를 가집니다(플랫폼에 따라 다름).
    *   `float`(4바이트)와 `double`(8바이트)은 각각 단정밀도와 배정밀도 부동소수점 수(예: 3.14, -0.001)를 처리하며, 정밀도와 범위 차이를 비교합니다. 
    *   `char`는 단일 문자(예: 'A', '1') 또는 ASCII 값을 저장하며, 1바이트를 사용합니다. 
- **변수 선언 및 초기화**: 
    *   변수는 데이터를 저장하는 메모리 공간으로, 선언(예: `int age;`)과 초기화(예: `int age = 25;`) 방법을 설명합니다. 
    *   변수 이름 규칙(예: 문자/밑줄로 시작, 공백/특수문자 금지)과 좋은 명명 관례(의미 있는 이름 사용)를 강조하며, 초기화하지 않은 변수의 위험성(예: 쓰레기 값)과 이를 피하는 방법을 안내합니다. 
    *   또한, 지역 변수와 전역 변수의 차이와 스코프 개념을 간단히 소개합니다.
- **상수 정의 (const, #define)**: 
    *   상수는 값이 변경되지 않는 데이터를 정의하는 방법입니다. 
    *   `const` 키워드(예: `const int MAX_SCORE = 100;`)는 컴파일 시 상수를 선언하며, 메모리에 저장. 
    *   `#define` 전처리 지시문(예: `#define PI 3.14159`)은 컴파일 전에 값을 치환하며, 주로 고정된 값을 정의할 때 사용됩니다. 
    
- **기본 연산자 (산술, 관계, 논리)**: 
    *   산술 연산자(+, -, *, /, %)는 수치 계산에 사용되며, 예를 들어 `/`의 경우 정수 나눗셈과 실수 나눗셈의 결과 차이(예: `5/2=2`, `5.0/2=2.5`)를 다룹니다. 
    *   관계 연산자(>, <, ==, != 등)는 두 값의 비교 결과를 참(1), 거짓(0)으로 반환하며, 조건문에서 활용. 
    *   논리 연산자(&&, \|\|, !)는 복잡한 조건을 구성하며, 예를 들어 `age > 18 && grade == 'A'` 같은 표현을 설명합니다. 
- **형변환**: 
    *   형변환은 한 데이터 타입을 다른 타입으로 변환하는 과정입니다. 
    *   암시적 형변환(예: `int`가 `float`로 자동 변환)과 명시적 형변환(예: `(int)height`)의 차이를 설명하며, 데이터 손실 가능성(예: 소수점 이하 버림)과 이를 다룰 때 주의할 점을 다룹니다.

### 2.2 주요 소스 코드

```c
#include <stdio.h>
#define PI 3.14159 // 원주율 상수 정의

int main() {
    // 변수 선언 및 초기화
    int age = 25; // 나이를 저장하는 정수형 변수
    float height = 175.5f; // 키를 저장하는 단정밀도 부동소수점 변수
    double weight = 68.7; // 몸무게를 저장하는 배정밀도 부동소수점 변수
    char grade = 'A'; // 등급을 저장하는 문자형 변수
    const int MAX_SCORE = 100; // 최대 점수를 상수로 정의
    
    // 연산자 사용
    int sum = 10 + 20; // 산술 연산: 두 정수의 합
    float area = PI * 5 * 5; // 원의 넓이 계산 (PI * 반지름^2)
    
    // 출력
    printf("나이: %d세\n", age); // %d: 정수 출력
    printf("키: %.1f cm\n", height); // %.1f: 소수점 1자리 실수 출력
    printf("몸무게: %.1f kg\n", weight); // %.1f: 소수점 1자리 실수 출력
    printf("등급: %c\n", grade); // %c: 문자 출력
    printf("원의 넓이: %.2f\n", area); // %.2f: 소수점 2자리 실수 출력
    
    // (명시적)형변환
    int integer_height = (int)height; // float를 int로 명시적 형변환 (소수점 버림)
    printf("정수로 변환된 키: %d cm\n", integer_height); // 변환된 정수 출력
    
    // (암묵적)형변환
    int a = 5;
    float b = 2.5;
    float result = a + b; // int인 a가 float로 변환됨

    return 0; // 프로그램 성공 종료
}
```

- **코드 설명**: 
    *   `#define PI`는 상수 정의, `const int MAX_SCORE`는 변경 불가 변수 선언을 예시합니다. 
    *   변수(`age`, `height`, `weight`, `grade`)는 서로 다른 데이터 타입을 사용하며, 초기화와 함께 선언. 
    *   `sum`과 `area`는 산술 연산의 결과를 저장하며, `printf`는 형식 지정자(%d, %.1f, %c 등)를 사용해 다양한 타입의 데이터를 출력합니다. 
    *   `(int)height`는 명시적 형변환을 통해 소수점 이하를 버리고 정수로 변환하는 과정을 보여줍니다. 




## 3차시: 제어문 (조건문)

### 3.1 학습 내용
- **if 문**: 
    *   C 언어에서 가장 기본적인 조건문으로, 특정 조건이 참일 때만 코드 블록을 실행합니다.
    *   조건은 괄호 `()` 안에 작성, 보통 비교 연산자(예: `>`, `==`, `<=`)나 논리 연산자(예: `&&`, `||`) 사용. 
    *    `if` 문의 기본 구조와 단일 조건 처리 방법을 예제(예: 점수가 60점 이상이면 합격)를 통해 설명하며, 중괄호 `{}` 사용의 중요성과 생략 시 주의점
- **if-else 문**: 
    *   조건이 참일 때와 거짓일 때 각각 다른 코드 블록을 실행하도록 확장된 조건문입니다.
    *   `if` 블록이 참일 때 실행되고, 그렇지 않으면 `else` 블록이 실행됩니다. 
    *    `if-else` 문을 사용해 두 가지 경우를 처리하는 방법(예: 점수가 90점 이상이면 우수, 아니면 노력 필요)을 설명하고, 코드 가독성을 높이기 위한 들여쓰기와 명확한 조건 설정의 중요성
- **if-else if-else 문**: 
    *   여러 조건을 순차적으로 검사해야 할 때 사용됩니다. 
    *   첫 번째 `if` 조건이 거짓이면 다음 `else if` 조건을 검사하고, 모든 조건이 거짓이면 최종 `else` 블록이 실행됩니다. 
    *    점수에 따라 등급(A, B, C, D, F)을 매기는 예제를 통해 다중 조건 처리 방법을 설명하며, 조건의 순서가 결과에 미치는 영향(예: 높은 점수부터 검사)과 효율적인 조건 설계 방법을 다룹니다.
- **switch-case 문**: 
    *   특정 변수의 값에 따라 여러 경우 중 하나를 선택해 실행하는 조건문입니다. 
    *   `switch` 문은 변수 값을 검사하고, 일치하는 `case` 레이블로 이동하며, `break` 문으로 블록을 종료. 
    *    요일을 숫자로 입력받아 해당 요일 이름을 출력하는 예제를 통해 `switch-case` 문의 구조와 사용법을 설명하고, `default` 케이스의 역할, `break` 누락 시 발생하는 "fall-through" 현상, 그리고 `if-else if`와의 비교(효율성, 가독성)를 다룹니다.
- **조건 연산자 (삼항 연산자)**: 
    *   `조건 ? 참일때값 : 거짓일때값` 형태로, 간단한 조건문을 한 줄로 표현하는 연산자입니다. 
    *    삼항 연산자를 사용해 숫자가 짝수인지 홀수인지 판별하는 예제를 설명

### 3.2 주요 소스 코드

```c
#include <stdio.h>

int main() {
    int score = 85;
    
    // if 문
    if (score >= 60) {
        printf("합격입니다.\n"); // 점수가 60 이상이면 "합격" 출력
    }
    
    // if-else 문
    if (score >= 90) {
        printf("우수한 성적입니다.\n"); // 점수가 90 이상이면 "우수" 출력
    } else {
        printf("더 노력해보세요.\n"); // 90 미만이면 "노력" 출력
    }
    
    // if-else if-else 문
    if (score >= 90) {
        printf("등급: A\n"); // 점수 90 이상: A 등급
    } else if (score >= 80) {
        printf("등급: B\n"); // 점수 80~89: B 등급
    } else if (score >= 70) {
        printf("등급: C\n"); // 점수 70~79: C 등급
    } else if (score >= 60) {
        printf("등급: D\n"); // 점수 60~69: D 등급
    } else {
        printf("등급: F\n"); // 점수 60 미만: F 등급
    }
    
    // switch-case 문
    int day = 3;
    switch (day) {
        case 1:
            printf("월요일\n"); // day가 1이면 "월요일" 출력
            break;
        case 2:
            printf("화요일\n"); // day가 2이면 "화요일" 출력
            break;
        case 3:
            printf("수요일\n"); // day가 3이면 "수요일" 출력
            break;
        case 4:
            printf("목요일\n"); // day가 4이면 "목요일" 출력
            break;
        case 5:
            printf("금요일\n"); // day가 5이면 "금요일" 출력
            break;
        default:
            printf("주말\n"); // 1~5 외의 값이면 "주말" 출력
            break;
    }
    
    // 조건 연산자
    int num = 7;
    char* result = (num % 2 == 0) ? "짝수" : "홀수"; // num이 짝수면 "짝수", 홀수면 "홀수"
    printf("%d은(는) %s입니다.\n", num, result); // 결과 출력
    
    return 0;
}
```




## 4차시: 제어문 (반복문)

### 4.1 학습 내용
- **for 문**: 
    *   `for` 문은 초기화, 조건, 증감식이 포함된 반복 구조로, 반복 횟수가 명확할 때 주로 사용됩니다. 
    *   예를 들어, 특정 범위의 숫자를 순회하거나 배열 요소를 처리할 때 유용합니다. 
    *   `for` 문의 구성 요소(초기화, 조건, 증감)와 실행 흐름을 다루고, 루프 변수의 스코프(예: `int i` 선언 위치)와 반복문 최적화 방법을 설명합니다. 또한, 무한 루프(`for(;;)`)와 같은 특수한 사용 사례도 소개합니다.
- **while 문**: 
    *   `while` 문은 조건이 참인 동안 반복을 수행하며, 반복 횟수가 미리 정해지지 않은 상황에 적합합니다. 
    *    `while` 문의 조건 평가 과정과, 루프 내에서 조건 변수를 수동으로 업데이트(예: `j++`)해야 하는 점을 강조. 조건이 처음부터 거짓일 경우 루프가 실행되지 않는 특성과, 무한 루프 방지를 위한 조건 관리의 중요성
- **do-while 문**: 
    *   `do-while` 문은 최소 한 번은 코드 블록을 실행한 후 조건을 평가하는 반복문으로, 사용자 입력 처리나 초기 실행이 필수적인 경우에 유용합니다. 
    *    `while` 문과의 차이점(최소 한 번 실행 보장)을 강조하고, `do-while` 문이 적합한 실제 시나리오(예: 메뉴 선택 루프)를 예로 들어 설명합니다.
- **break와 continue**: 
    *   `break`는 반복문을 즉시 종료하고 루프를 빠져나가는 제어 구문으로, 특정 조건에서 루프를 중단할 때 사용됩니다. 
    *   `continue`는 현재 반복을 건너뛰고 다음 반복으로 진행합니다. 
    *    두 구문의 동작 원리와 사용 시 주의점(예: `continue`가 루프 내 후속 코드를 건너뛰는 점)을 설명하며, 코드 가독성과 효율성을 위한 적절한 사용 사례를 제시합니다.
- **중첩 반복문**: 
    *   중첩 반복문은 반복문 안에 또 다른 반복문을 포함하는 구조로, 다차원 데이터 처리(예: 2차원 배열)나 복잡한 패턴 생성(예: 구구단 출력)에 사용됩니다. 
    *   중첩 루프의 실행 흐름, 내부/외부 루프 변수의 역할, 그리고 성능 고려사항(예: 루프 최적화, 불필요한 반복 최소화)을 다룹니다. 또한, 구구단과 같은 실용적인 예제를 통해 중첩 루프의 실제 응용을 제시.

### 4.2 주요 소스 코드
```c
#include <stdio.h>

int main() {
    // for 문
    printf("for 문 예제:\n");
    for (int i = 1; i <= 5; i++) {
        printf("%d ", i); // 1부터 5까지 출력
    }
    printf("\n\n");
    
    // while 문
    printf("while 문 예제:\n");
    int j = 1;
    while (j <= 5) {
        printf("%d ", j); // 1부터 5까지 출력
        j++; // 조건 변수 수동 증가
    }
    printf("\n\n");
    
    // do-while 문
    printf("do-while 문 예제:\n");
    int k = 1;
    do {
        printf("%d ", k); // 1부터 5까지 출력
        k++;
    } while (k <= 5);
    printf("\n\n");
    
    // break 문
    printf("break 문 예제:\n");
    for (int i = 1; i <= 10; i++) {
        if (i == 6) {
            break; // i가 6일 때 루프 종료
        }
        printf("%d ", i); // 1부터 5까지 출력
    }
    printf("\n\n");
    
    // continue 문
    printf("continue 문 예제:\n");
    for (int i = 1; i <= 10; i++) {
        if (i % 2 == 0) {
            continue; // 짝수는 건너뛰고 다음 반복으로
        }
        printf("%d ", i); // 홀수만 출력 (1, 3, 5, 7, 9)
    }
    printf("\n\n");
    
    // 중첩 반복문 (구구단)
    printf("구구단 (2~5단):\n");
    for (int i = 2; i <= 5; i++) {
        printf("[%d단]\n", i);
        for (int j = 1; j <= 9; j++) {
            printf("%d x %d = %d\n", i, j, i * j); // 각 단의 곱셈 출력
        }
        printf("\n");
    }
    
    return 0;
}
```


## 5차시: 함수

### 5.1 학습 내용
- **함수의 정의와 호출**: 
    *   함수는 특정 작업을 수행하는 코드 블록으로, 프로그램의 가독성과 재사용성을 높입니다.
    *   정의(구현)와 호출(사용)으로 나뉘며, 정의는 함수의 이름, 매개변수, 반환 타입, 실행 코드를 포함. 
    *   `int add(int a, int b)`는 두 정수를 더하는 함수를 정의하고, `add(5, 3)`과 같이 호출
    *   함수 호출 시 프로그램 흐름(스택 메모리 사용 포함)을 설명하고, 함수의 모듈화가 코드 유지보수에 미치는 이점을 강조합니다.
- **함수 원형(prototype)**: 
    *   함수 원형은 함수의 선언으로, 함수 이름, 반환 타입, 매개변수 타입을 지정하여 컴파일러가 함수 호출을 미리 인식하도록 합니다(예: `int add(int a, int b);`). 
    *   함수 정의가 `main` 함수 뒤에 위치할 때 필요, 헤더 파일에서 함수 인터페이스를 정의하는 데도 사용. 
    
- **매개변수와 반환값**: 
    *   매개변수는 함수에 전달되는 입력값으로, 함수 내부에서 지역 변수처럼 동작합니다(예: `int a, int b` in `add`). 
    *   반환값은 함수가 호출자에게 돌려주는 결과로, `return` 문을 통해 전달됩니다(예: `return a + b;`). 
    *   매개변수의 역할, 반환 타입(`void`, `int` 등), 그리고 반환값이 없는 함수(`void`)의 사용 사례
- **값에 의한 호출(Call by Value)**: 
    *   값에 의한 호출은 함수에 매개변수를 전달할 때 값의 복사본을 전달하는 방식입니다. 
    *   따라서 함수 내부에서 매개변수를 수정해도 원본 변수는 영향을 받지 않습니다(예: `swap` 함수에서 `a`, `b` 값 변경이 호출자 변수에 반영되지 않음). 
    *    이 방식의 메모리 동작(스택 프레임), 장점(원본 데이터 보호), 단점(대량 데이터 복사 시 비효율성)을 설명하고, 이를 포인터를 사용한 참조 호출과 비교.
- **지역변수와 전역변수**: 
    *   지역변수는 함수나 블록 내에서 선언되어 해당 범위에서만 유효하며, 함수 호출이 끝나면 메모리에서 해제됩니다(예: `localVar` in `main`). 
    *   전역변수는 프로그램 전체에서 접근 가능하며, 파일 상단에서 선언됩니다(예: `globalVar`). 
    *   지역변수의 스코프와 생명 주기, 전역변수의 접근성과 위험성(예: 의도치 않은 수정 가능성), 그리고 두 변수 타입의 적절한 사용 시나리오를 다룬다.
- **재귀 함수**: 
    *   자신을 호출하는 함수로, 문제를 더 작은 하위 문제로 나누어 해결합니다(예: `factorial` 함수).  
    *   재귀의 기본 구조(기저 조건과 재귀 호출), 스택 오버플로우 위험, 그리고 재귀와 반복문의 비교 설명. 
    *   또한 팩토리얼, 피보나치 수열 같은 실제 예제를 통해 재귀의 설계 방식과 효율성을 분석합니다.

### 5.2 주요 소스 코드
```c
#include <stdio.h>

// 함수 원형(prototype) 선언
int add(int a, int b);
void swap(int a, int b);
void increment(int n);
int factorial(int n);
void printLine();

// 전역 변수
int globalVar = 100;

int main() {
    // 함수 호출
    int result = add(5, 3);
    printf("5 + 3 = %d\n", result);
    
    printLine();
    
    // 값에 의한 호출 예제
    int x = 10, y = 20;
    printf("함수 호출 전: x = %d, y = %d\n", x, y);
    swap(x, y);  // 값에 의한 호출이므로 원본 값은 변경되지 않음
    printf("함수 호출 후: x = %d, y = %d\n", x, y);
    
    printLine();
    
    // 전역변수와 지역변수
    int localVar = 200;
    printf("전역변수: %d, 지역변수: %d\n", globalVar, localVar);
    
    // 함수 내에서 지역변수 값 변경 시도
    printf("increment 함수 호출 전: localVar = %d\n", localVar);
    increment(localVar);
    printf("increment 함수 호출 후: localVar = %d\n", localVar);
    
    printLine();
    
    // 재귀 함수
    int n = 5;
    printf("%d! = %d\n", n, factorial(n));
    
    return 0;
}

// 두 수를 더하는 함수
int add(int a, int b) {
    return a + b;
}

// 두 변수의 값을 교환하는 함수 (값에 의한 호출)
void swap(int a, int b) {
    int temp = a;
    a = b;
    b = temp;
    printf("swap 함수 내부: a = %d, b = %d\n", a, b);
}

// 값을 증가시키는 함수
void increment(int n) {
    n++;
    printf("increment 함수 내부: n = %d\n", n);
}

// 재귀 함수로 팩토리얼 계산
int factorial(int n) {
    if (n <= 1)
        return 1;
    else
        return n * factorial(n - 1);
}

// 구분선 출력 함수
void printLine() {
    printf("\n-----------------------\n");
}
```

## 6차시: 배열

### 6.1 학습 내용
- **1차원 배열 선언 및 초기화**: 
    *   1차원 배열은 동일한 데이터 타입의 요소를 연속적으로 저장하는 자료구조입니다. 
    *   배열 선언은 `int arr[크기]` 형식으로 이루어지며, 크기는 배열이 저장할 요소의 개수를 나타냅니다. 
    *   초기화는 선언과 동시에 값을 지정하거나(예: `int arr[3] = {1, 2, 3};`), 일부만 초기화(예: `int arr[5] = {1, 2};`, 나머지는 0으로 자동 초기화)할 수 있습니다. 
- **배열 요소 접근**: 
    *   배열 요소는 인덱스를 통해 접근하며, 인덱스는 0부터 시작합니다(예: `arr[0]`은 첫 번째 요소). 
    *   인덱스를 사용해 특정 요소를 읽거나 수정하는 방법(예: `arr[2] = 10;`)을 다루고, 배열의 범위를 벗어나는 인덱스 접근(예: `arr[5]` in `arr[5]`)이 초래할 수 있는 런타임 오류(버퍼 오버플로우)와 이를 방지하기 위한 안전한 코딩 관행.
- **문자열과 배열**: 
    *   C 언어에서 문자열은 문자 배열로 표현되며, 마지막에 널 종료 문자(`\0`)가 포함됩니다. 
    *   예를 들어, `char str[6] = {'H', 'e', 'l', 'l', 'o', '\0'};`는 문자열 "Hello"를 나타남. 
    *   문자열 리터럴(예: `char str[] = "Hello";`)은 자동으로 `\0`을 추가하며, 배열 크기 생략 가능.  
    *   `<string.h>` 헤더의 함수(예: `strlen`, `strcpy`)를 사용해 문자열을 조작하는 방법과 문자 배열과 문자열의 차이점을 구체적으로 다룹니다.
- **다차원 배열**: 
    *   다차원 배열은 배열의 배열로, 주로 2차원 배열(예: `int matrix[2][3]`)이 사용됩니다. 
    *   이는 행렬이나 테이블 데이터를 표현하는 데 유용합니다. 
    *   선언과 초기화(예: `int matrix[2][3] = { {1, 2, 3}, {4, 5, 6}};`) 방법을 배우고, 메모리에서 2차원 배열이 연속적으로 저장되는 방식을 설명합니다.  
    *    다차원 배열의 인덱싱(예: `matrix[1][2]`)과 중첩 루프를 사용한 요소 접근 방법을 자세히 다룹니다.
- **배열과 함수**: 
    *   배열을 함수에 전달할 때는 포인터로 전달되며, 함수는 배열의 원본 데이터를 직접 조작할 수 있습니다. 
    *    예를 들어, `void printArray(int arr[], int size)`는 배열과 크기를 인수로 받아 요소를 출력.  
    *   배열을 함수에 전달하는 방법, 배열 크기를 별도로 전달해야 하는 이유, 그리고 2차원 배열을 함수에 전달할 때 열의 크기를 명시해야 하는 규칙(예: `int arr[][3]`)을 설명합니다. 
    

### 6.2 주요 소스 코드

```c

#include <stdio.h>
#include <string.h>

// 배열을 인수로 받는 함수
void printArray(int arr[], int size);
// 2차원 배열을 인수로 받는 함수
void print2DArray(int arr[][3], int rows);
// 배열의 모든 요소 합계를 계산하는 함수
int sumArray(int arr[], int size);

int main() {
    // 1차원 배열 선언 및 초기화
    int numbers[5] = {10, 20, 30, 40, 50}; // 5개의 정수로 초기화
    int emptyArray[5];  // 초기화되지 않은 배열(쓰레기 값 포함 가능)
    int partialArray[5] = {1, 2};  // 첫 두 요소만 초기화, 나머지는 0
    
    // 배열 요소 접근
    printf("numbers[0] = %d\n", numbers[0]); // 첫 번째 요소 출력
    printf("numbers[4] = %d\n", numbers[4]); // 마지막 요소 출력
    
    // 배열 요소 수정
    numbers[2] = 35; // 세 번째 요소를 35로 변경
    printf("numbers[2] = %d (수정 후)\n\n", numbers[2]);
    
    // 배열 전체 출력
    printf("배열 전체 출력:\n");
    printArray(numbers, 5); // 함수를 호출해 배열 요소 출력
    
    // 문자 배열과 문자열
    char greeting[6] = {'H', 'e', 'l', 'l', 'o', '\0'}; // 문자 배열로 문자열 구성
    char message[] = "Hello, C!";  // 문자열 리터럴로 초기화, 크기 자동 계산
    
    printf("\n문자 배열: %s\n", greeting); // 문자 배열 출력
    printf("문자열: %s\n", message); // 문자열 출력
    printf("문자열 길이: %lu\n\n", strlen(message)); // 문자열 길이 출력
    
    // 다차원 배열
    int matrix[2][3] = { // 2x3 행렬 초기화
        {1, 2, 3},
        {4, 5, 6}
    };
    
    printf("2차원 배열:\n");
    print2DArray(matrix, 2); // 2차원 배열 출력 함수 호출
    
    // 배열과 함수
    int sum = sumArray(numbers, 5); // 배열 요소 합계 계산
    printf("\n배열 요소의 합: %d\n", sum);
    
    return 0;
}

// 배열 출력 함수
void printArray(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]); // 배열 요소를 순회하며 출력
    }
    printf("\n");
}

// 2차원 배열 출력 함수
void print2DArray(int arr[][3], int rows) {
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < 3; j++) {
            printf("%d ", arr[i][j]); // 2차원 배열 요소를 순회하며 출력
        }
        printf("\n");
    }
}

// 배열의 모든 요소 합계를 계산하는 함수
int sumArray(int arr[], int size) {
    int sum = 0;
    for (int i = 0; i < size; i++) {
        sum += arr[i]; // 배열 요소를 순회하며 합계 계산
    }
    return sum; // 계산된 합계 반환
}
```

## 7차시: 포인터 기초

### 7.1 학습 내용
- **포인터의 개념**: 
    *   포인터는 메모리 주소를 저장하는 변수로, C 언어에서 메모리를 직접 조작할 수 있는 강력한 도구. 
    *   포인터를 통해 변수의 값을 간접적으로 접근하거나 수정할 수 있으며, 이는 동적 메모리 할당, 배열 처리, 함수 인자 전달 등에서 핵심적인 역할을 합니다. 
- **포인터 변수 선언 및 초기화**: 
    *   포인터 변수는 특정 데이터 타입(예: int, float)을 가리키도록 선언되며, `*`를 사용해 정의합니다(예: `int *ptr;`). 
    *   초기화하지 않은 포인터는 임의의 메모리 주소를 가리킬 수 있어 위험하므로, 명시적으로 주소나 NULL로 초기화해야 합니다. 
- **포인터와 주소 연산자(&)**: 
    *   주소 연산자(`&`)는 변수의 메모리 주소를 반환합니다(예: `&num`은 num의 주소).
    *   포인터는 이 주소를 저장해 변수에 간접적으로 접근할 수 있습니다. 
    *   메모리 주소의 형식(16진수)과 변수의 주소를 확인하는 방법, 그리고 포인터에 주소를 할당하는 과정(예: `pNum = &num;`)을 상세히 설명하며, 주소 연산자의 역할과 제한사항(상수나 표현식에는 사용 불가)을 강조.
- **역참조 연산자(*)**: 
    *   역참조 연산자(`*`)는 포인터가 가리키는 주소에 저장된 값을 읽거나 수정할 때 사용됩니다(예: `*pNum = 100;`). 
    *   이는 포인터의 핵심 기능으로, 변수의 값을 직접 변경하지 않고 메모리 주소를 통해 간접적으로 조작.  
    *   역참조의 동작 원리와, 잘못된 역참조(예: 초기화되지 않은 포인터 사용)가 프로그램 충돌 가능성.
- **포인터 연산**: 
    *   포인터는 산술 연산(덧셈, 뺄셈)과 비교 연산을 지원하며, 특히 배열과 함께 사용할 때 유용합니다. 
    *   예를 들어, `ptr + 1`은 포인터가 가리키는 데이터 타입의 크기만큼 주소를 이동시킵니다(int형 포인터라면 4바이트 이동).  
- **NULL 포인터**: 
    *   NULL 포인터는 어떤 유효한 메모리 주소도 가리키지 않는 포인터로, `NULL` 매크로로 초기화됩니다(예: `int *ptr = NULL;`). 
    *   이는 포인터가 안전하게 초기화되었음을 보장하며, 역참조 오류를 방지하는 데 사용됩니다.  
    *   NULL 포인터의 용도(예: 함수 반환값, 포인터 초기화), NULL 확인 방법, 그리고 NULL 포인터를 역참조할 경우 발생하는 런타임 오류를 실제 사례로 설명.
- **아스테리크(*) 위치**
    *   선언 시: 자료형 *변수이름;
    *   간접 참조 시: *포인터변수
    *   형 변환 시 (포인터 타입으로): (자료형 *)포인터변수
    *   형 변환 후 값 접근 시: *((자료형 *)포인터변수)
    
### 7.2 주요 소스 코드

```c
#include <stdio.h>

int main() {
    // 변수 선언
    int num = 42;      // 정수형 변수, 값은 42
    float pi = 3.14159; // 실수형 변수, 값은 3.14159
    
    // 포인터 변수 선언
    int *pNum;         // int형 데이터를 가리키는 포인터
    float *pPi;        // float형 데이터를 가리키는 포인터
    
    // 포인터에 주소 할당
    pNum = &num;       // num의 메모리 주소를 pNum에 저장
    pPi = &pi;         // pi의 메모리 주소를 pPi에 저장
    
    // 변수 값과 주소 출력
    printf("num 값: %d, 주소: %p\n", num, &num); // num의 값과 주소를 출력
    printf("pi 값: %f, 주소: %p\n\n", pi, &pi);  // pi의 값과 주소를 출력
    
    // 포인터를 사용한 값 접근 (역참조)
    printf("포인터를 사용한 값 접근:\n");
    printf("*pNum = %d\n", *pNum); // pNum이 가리키는 값(42) 출력
    printf("*pPi = %f\n\n", *pPi); // pPi가 가리키는 값(3.14159) 출력
    
    // 포인터를 통한 값 변경
    *pNum = 100;       // pNum이 가리키는 num의 값을 100으로 변경
    *pPi = 3.14;       // pPi가 가리키는 pi의 값을 3.14로 변경
    
    printf("포인터로 값 변경 후:\n");
    printf("num = %d\n", num); // 변경된 num의 값(100) 출력
    printf("pi = %f\n\n", pi); // 변경된 pi의 값(3.14) 출력
    
    // 포인터 연산
    int numbers[5] = {10, 20, 30, 40, 50}; // 5개 요소의 정수 배열
    int *ptr = numbers;  // 배열 이름은 첫 번째 요소의 주소, ptr에 할당
    
    printf("포인터 연산 예제 (배열 접근):\n");
    for (int i = 0; i < 5; i++) {
        printf("*(ptr + %d) = %d\n", i, *(ptr + i)); // 포인터 연산으로 배열 요소 출력
    }
    printf("\n");
    
    // NULL 포인터
    int *nullPtr = NULL; // NULL로 초기화된 포인터
    printf("NULL 포인터: %p\n", nullPtr); // NULL 포인터의 값(0) 출력
    
    // NULL 포인터 확인 (안전한 방법)
    if (nullPtr == NULL) {
        printf("nullPtr은 NULL입니다.\n"); // NULL 여부 확인
    } else {
        printf("nullPtr은 유효한 주소를 가리킵니다.\n");
    }
    
    // ⚠️ 주의: NULL 포인터 역참조는 오류 발생
    // *nullPtr = 10;  // 주석 처리된 코드, 실행 시 프로그램 충돌
    
    return 0; // 프로그램 정상 종료
}
```

- **코드 설명**: 
    *   이 코드는 포인터의 기본 개념을 종합적으로 보여줍니다. 
    *   변수와 포인터 선언, 주소 연산자(`&`)로 주소를 할당, 역참조 연산자(`*`)로 값을 읽고 수정하는 과정. 
    *   배열과 포인터 연산을 통해 메모리 주소 이동을 보여주고, NULL 포인터의 안전한 사용법과 역참조 오류의 위험성을 강조. 
    *   각 출력문은 포인터의 동작을 직관적으로 이해할 수 있도록 설계되었으며, 주석 처리된 오류 코드는 학습자가 흔히 저지르는 실수를 예방하기 위한 경고로 포함되었습니다.



## 8차시: 포인터 심화 및 활용

### 8.1 학습 내용
- **포인터와 함수 (Call by Reference)**: 
    *   포인터를 활용한 함수 호출 방식인 Call by Reference를 다룹니다. 
    *   Call by Value는 함수에 값만 복사되어 원본 데이터가 변경되지 않지만, Call by Reference는 변수의 주소를 전달해 함수 내에서 원본 데이터를 직접 수정할 수 있습니다.
    *   스왑(swap) 함수와 같은 실용적인 예제를 통해 포인터의 강력함과 메모리 접근 방식을 학습. 
    *   예를 들어, 두 변수의 값을 교환하는 과정에서 포인터를 사용하면 메모리 효율성과 코드 간결성 향상.
- **포인터 배열**: 
    *   포인터 배열은 포인터를 요소로 가지는 배열로, 각 요소가 다른 변수의 주소를 저장합니다. 
    *   이를 통해 여러 변수의 주소를 하나의 배열로 관리하고, 동적으로 접근하거나 수정할 수 있습니다.  
    *   포인터 배열의 선언, 초기화, 사용 방법을 다루며, 예를 들어 서로 다른 정수형 변수의 주소를 포인터 배열에 저장하고 반복문을 통해 값을 출력하는 방법을 설명.
- **다중 포인터 (이중 포인터)**: 
    *   이중 포인터는 포인터를 가리키는 포인터로, 메모리 주소를 한 단계 더 추상화합니다. 
    *   이중 포인터는 동적 2차원 배열 생성이나 함수 내에서 포인터 자체를 수정할 때 유용합니다.  
    *   단일 포인터와 이중 포인터의 차이, 이중 포인터의 선언(`int **pptr`), 역참조(`**pptr`) 방법을 설명하고, 실제로 변수, 단일 포인터, 이중 포인터 간의 관계를 시각적으로 보여준다.
- **함수 포인터 기초**: 
    *   함수 포인터는 함수의 주소를 저장하는 포인터로, 런타임에 호출할 함수를 동적으로 결정. 
    *   이를 통해 콜백 함수나 플러그인 시스템 같은 고급 프로그래밍 기법을 구현할 수 있습니다.  
    *   함수 포인터의 선언(`int (*func)(int)`), 초기화, 호출 방법을 다루며, 제곱(square)과 세제곱(cube) 같은 함수를 함수 포인터로 호출하는 예제를 통해 개념을 명확히 합니다.
- **void 포인터**:
    *   void 포인터는 특정 데이터 타입에 구애받지 않고 모든 타입의 주소를 저장할 수 있는 범용 포인터. 
    *   이는 유연한 메모리 관리와 다양한 데이터 타입 처리가 필요한 상황에서 유용합니다.
    *     void 포인터의 선언, 타입 캐스팅을 통한 역참조 방법, 그리고 정수, 실수, 문자 등 여러 타입의 데이터를 처리하는 예제를 다룹니다. 
    *   void 포인터의 한계(직접 역참조 불가)와 주의점도 함께 설명.
- **포인터와 메모리 관리 기초**: 
    *   동적 메모리 할당(malloc, free)을 통해 런타임에 메모리를 관리하는 방법을 배웁니다. 
    *   이를 통해 배열 크기를 사용자 입력에 따라 동적으로 설정하거나, 메모리 사용을 최적화할 수 있습니다.  
    *   `malloc`으로 메모리를 할당하고, `free`로 해제하는 과정, 메모리 누수 방지, 그리고 NULL 포인터 확인 같은 안전한 메모리 관리 기법을 다룹니다. 
    * 동적 배열 생성 예제를 통해 실용성을 강조합니다.

### 8.2 주요 소스 코드
```c
#include <stdio.h>
#include <stdlib.h>

// 값에 의한 호출 (Call by Value)
void swapByValue(int a, int b);
// 참조에 의한 호출 (Call by Reference) - 포인터 사용
void swapByReference(int *a, int *b);
// 배열을 포인터로 받는 함수
void printArray(int *arr, int size);
// 다양한 데이터 타입을 처리하는 함수 (void 포인터 사용)
void printValue(void *ptr, char type);
// 함수 포인터를 매개변수로 받는 함수
void processArray(int *arr, int size, int (*func)(int));
// 함수 포인터에 사용할 함수들
int square(int x);
int cube(int x);

int main() {
    // Call by Value vs Call by Reference
    int x = 10, y = 20;
    
    printf("원본 값: x = %d, y = %d\n", x, y);
    
    swapByValue(x, y);
    printf("Call by Value 후: x = %d, y = %d\n", x, y);
    
    swapByReference(&x, &y);
    printf("Call by Reference 후: x = %d, y = %d\n\n", x, y);
    
    // 포인터 배열
    int *ptrArray[3];
    int a = 10, b = 20, c = 30;
    
    ptrArray[0] = &a;
    ptrArray[1] = &b;
    ptrArray[2] = &c;
    
    printf("포인터 배열 예제:\n");
    for (int i = 0; i < 3; i++) {
        printf("*ptrArray[%d] = %d\n", i, *ptrArray[i]);
    }
    printf("\n");
    
    // 이중 포인터
    int num = 42;
    int *ptr = &num;    // 단일 포인터
    int **pptr = &ptr;  // 이중 포인터
    
    printf("이중 포인터 예제:\n");
    printf("num = %d\n", num);
    printf("*ptr = %d\n", *ptr);
    printf("**pptr = %d\n\n", **pptr);
    
    // void 포인터
    int intValue = 42;
    float floatValue = 3.14f;
    char charValue = 'A';
    
    printf("void 포인터 예제:\n");
    printValue(&intValue, 'i');
    printValue(&floatValue, 'f');
    printValue(&charValue, 'c');
    printf("\n");
    
    // 함수 포인터
    int nums[5] = {1, 2, 3, 4, 5};
    
    printf("함수 포인터 예제:\n");
    printf("원본 배열: ");
    printArray(nums, 5);
    
    printf("제곱 적용: ");
    processArray(nums, 5, square);
    
    printf("세제곱 적용: ");
    processArray(nums, 5, cube);
    printf("\n");
    
    // 동적 메모리 할당 기초
    int size;
    printf("동적 배열 크기 입력: ");
    scanf("%d", &size);
    
    // malloc으로 메모리 할당
    int *dynamicArray = (int*)malloc(size * sizeof(int));
    
    if (dynamicArray == NULL) {
        printf("메모리 할당 실패\n");
        return 1;
    }
    
    // 동적 배열 초기화
    for (int i = 0; i < size; i++) {
        dynamicArray[i] = i * 10;
    }
    
    // 동적 배열 출력
    printf("동적 배열 내용: ");
    for (int i = 0; i < size; i++) {
        printf("%d ", dynamicArray[i]);
    }
    printf("\n");
    
    // 메모리 해제
    free(dynamicArray);
    printf("동적 메모리 해제 완료\n");
    
    return 0;
}

// 값에 의한 호출 (변수 값을 복사)
void swapByValue(int a, int b) {
    int temp = a;
    a = b;
    b = temp;
    printf("swapByValue 함수 내부: a = %d, b = %d\n", a, b);
}

// 참조에 의한 호출 (변수 주소를 전달)
void swapByReference(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
    printf("swapByReference 함수 내부: *a = %d, *b = %d\n", *a, *b);
}

// 배열을 포인터로 받는 함수
void printArray(int *arr, int size) {
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

// 다양한 데이터 타입을 처리하는 함수
void printValue(void *ptr, char type) {
    switch (type) {
        case 'i':  // 정수
            printf("정수 값: %d\n", *((int*)ptr)); //포인터변수에 대한 형변환과 간접참조
            break;
        case 'f':  // 실수
            printf("실수 값: %.2f\n", *((float*)ptr));
            break;
        case 'c':  // 문자
            printf("문자 값: %c\n", *((char*)ptr));
            break;
        default:
            printf("지원되지 않는 타입\n");
    }
}

// 함수 포인터에 사용할 함수: 제곱
int square(int x) {
    return x * x;
}

// 함수 포인터에 사용할 함수: 세제곱
int cube(int x) {
    return x * x * x;
}

// 함수 포인터(하나의 인자를 갖는)를 매개변수로 받는 함수, 
void processArray(int *arr, int size, int (*func)(int)) {
    for (int i = 0; i < size; i++) {
        printf("%d ", func(arr[i]));
    }
    printf("\n");
}
```
