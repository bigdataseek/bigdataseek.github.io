---
title: 7차시 10:Swift4
layout: single
classes: wide
categories:
  - Swift
toc: true # 이 포스트에서 목차를 활성화
toc_sticky: true # 목차를 고정할지 여부 (선택 사항)
---

## 21.Nexted Type
Swift에서는 타입(클래스, 구조체, 열거형 등) 안에 다른 타입을 정의할 수 있습니다. 이를 **중첩 타입**이라고 합니다. 중첩 타입은 코드를 더 명확하고 직관적으로 구성하는 데 유용합니다. 특히 특정 타입 내부에서만 사용되는 보조 타입을 정의할 때 적합합니다.

### **21.1 중첩 타입의 기본 개념**
- **중첩 타입**은 클래스, 구조체, 또는 열거형 안에 정의된 타입입니다.
- 중첩 타입은 외부에서 직접 접근할 수 없으며, 해당 타입의 인스턴스나 메서드 내에서만 사용됩니다.
- 중첩 타입은 코드의 가독성을 높이고 관련된 타입을 논리적으로 그룹화하는 데 도움이 됩니다.

```swift
struct BlackjackCard {
    // 중첩된 열거형
    enum Suit: Character {
        case spades = "♠", hearts = "♥", diamonds = "♦", clubs = "♣"
    }

    // 중첩된 구조체
    struct Rank {
        var value: Int
        var description: String {
            switch value {
            case 1:
                return "Ace"
            case 11:
                return "Jack"
            case 12:
                return "Queen"
            case 13:
                return "King"
            default:
                return String(value)
            }
        }
    }

    // 속성
    var rank: Rank
    var suit: Suit
}
```

위 예제에서는 `BlackjackCard`라는 구조체 안에 `Suit` 열거형과 `Rank` 구조체가 중첩되어 정의되었습니다.

### **21.2 중첩 타입의 장점**
- **범위 제한**: 중첩 타입은 외부에서 직접 접근할 필요가 없는 경우에 유용합니다. 즉, 특정 타입 내부에서만 사용될 때 이를 캡슐화할 수 있습니다.
- **코드 조직화**: 관련된 타입들을 논리적으로 그룹화하여 코드의 구조를 명확하게 만듭니다.
- **명확성 향상**: 중첩 타입을 통해 타입 간의 관계를 더 명확히 표현할 수 있습니다.

### **21.3 중첩 타입의 접근**
중첩 타입은 바깥쪽 타입의 이름을 통해 접근할 수 있습니다. 예를 들어:

```swift
let heartsSymbol = BlackjackCard.Suit.hearts.rawValue
print(heartsSymbol) // 출력: ♥
```

위 코드에서 `Suit` 열거형은 `BlackjackCard` 구조체 내부에 중첩되어 있으므로, `BlackjackCard.Suit`로 접근해야 합니다.

### **21.4 중첩 타입의 활용 예시**
아래는 중첩 타입을 활용한 실전 예제입니다. 이 예제는 블랙잭 카드의 계산을 모델링합니다.

```swift
struct BlackjackCard {
    // 중첩된 열거형
    enum Suit: Character {
        case spades = "♠", hearts = "♥", diamonds = "♦", clubs = "♣"
    }

    // 중첩된 구조체
    struct Rank {
        var value: Int
        var description: String {
            switch value {
            case 1:
                return "Ace"
            case 11:
                return "Jack"
            case 12:
                return "Queen"
            case 13:
                return "King"
            default:
                return String(value)
            }
        }
    }

    // 속성
    var rank: Rank
    var suit: Suit

    // 메서드
    func description() -> String {
        return "\(rank.description) of \(suit.rawValue)"
    }
}

// 사용 예시
let aceOfSpades = BlackjackCard(rank: BlackjackCard.Rank(value: 1), suit: .spades)
print(aceOfSpades.description()) // 출력: Ace of ♠
```

### **21.5 중첩 타입의 제한 사항**
- 중첩 타입은 바깥쪽 타입의 인스턴스 없이도 사용할 수 있습니다. 하지만 중첩 타입이 비중첩 상태라면 외부에서 직접 접근할 수 없습니다.
- 너무 많은 중첩은 코드의 복잡성을 증가시킬 수 있으므로, 필요한 경우에만 사용하는 것이 좋습니다.

### **21.6 중첩 타입의 실제 활용**
중첩 타입은 다음과 같은 상황에서 유용합니다:
- **특정 타입 내부에서만 사용되는 보조 타입**을 정의할 때.
- **타입 간의 관계를 명확히 표현**하고 싶을 때.
- **코드의 가독성과 유지보수성을 높이고 싶을 때**.

예를 들어, 네트워크 요청과 응답을 처리하는 클래스에서 요청 타입과 응답 타입을 중첩하여 정의할 수 있습니다.

## 22.Extensions
### **22.1 Extensions란?**
- **Extensions**는 기존 타입(클래스, 구조체, 열거형, 프로토콜 등)에 새로운 기능을 추가할 수 있는 기능입니다.
- 이미 존재하는 타입에 대해 수정 없이도 기능을 확장할 수 있습니다.
- 주요 용도:
  - 새로운 메서드 추가
  - 새로운 초기화 메서드(computed properties 포함)
  - 프로토콜 채택 및 구현
  - 중첩 타입 추가

> **주의**: Extensions를 통해 저장 프로퍼티(stored properties)를 추가할 수는 없습니다.

### **22.2 Extensions의 기본 문법**

```swift
extension SomeType {
    // 새로운 기능 추가
}
```

예시:
```swift
extension Int {
    func squared() -> Int {
        return self * self
    }
}

let number = 5
print(number.squared()) // 출력: 25
```

### **22.3 Extensions로 추가할 수 있는 기능**

1\.**Computed Properties**
- 저장 프로퍼티는 추가할 수 없지만, **계산된 프로퍼티(computed properties)**는 추가 가능합니다.

```swift
extension Double {
    var km: Double { return self * 1_000.0 }
    var m: Double { return self }
    var cm: Double { return self / 100.0 }
}

let distance = 25.4
print(distance.km) // 출력: 25400.0
print(distance.cm) // 출력: 0.254
```

2\.**Instance Methods와 Type Methods**
- 인스턴스 메서드와 타입 메서드를 추가할 수 있습니다.

```swift
extension String {
    func shout() -> String {
        return self.uppercased() + "!"
    }
    
    static func greet() -> String {
        return "Hello, World!"
    }
}

let greeting = "hello".shout()
print(greeting) // 출력: "HELLO!"

print(String.greet()) // 출력: "Hello, World!"
```

3\.**Initializers**
- 새로운 초기화 메서드를 추가할 수 있습니다.
- 특히 외부 라이브러리나 시스템 타입에 커스텀 초기화 메서드를 추가할 때 유용합니다.

```swift
struct Size {
    var width = 0.0, height = 0.0
}

extension Size {
    init(value: Double) {
        self.width = value
        self.height = value
    }
}

let customSize = Size(value: 10.0)
print(customSize.width, customSize.height) // 출력: 10.0 10.0
```

4\.**Subscripts**
- 서브스크립트(subscript)를 추가하여 타입에 대한 접근 방식을 확장할 수 있습니다.

```swift
extension String {
    subscript(index: Int) -> Character? {
        guard index >= 0 && index < self.count else { return nil }
        return self[self.index(self.startIndex, offsetBy: index)]
    }
}

let text = "Swift"
print(text[2]) // 출력: Optional("i")
```

5\.**Nested Types**
- 중첩 타입(nested types)을 추가할 수 있습니다.

```swift
extension Int {
    enum Kind {
        case negative, zero, positive
    }
    
    var kind: Kind {
        switch self {
        case 0:
            return .zero
        case let x where x > 0:
            return .positive
        default:
            return .negative
        }
    }
}

let number = -5
print(number.kind) // 출력: negative
```

6\.**Protocol Conformance**
- Extensions를 사용하여 기존 타입이 특정 프로토콜을 준수하도록 만들 수 있습니다.

```swift
protocol TextRepresentable {
    var textualDescription: String { get }
}

extension Int: TextRepresentable {
    var textualDescription: String {
        return "The number \(self)"
    }
}

let value = 42
print(value.textualDescription) // 출력: "The number 42"
```

### **22.4 Extensions의 제한 사항**
- **저장 프로퍼티 추가 불가**: Extensions에서는 저장 프로퍼티를 추가할 수 없습니다.
- **기존 메서드 재정의 불가**: Extensions로 기존 메서드를 재정의할 수 없습니다.
- **새로운 designated initializers 추가 불가**: Convenience initializer만 추가할 수 있습니다.

### **22.5 Extensions 활용 예시**

1\.**UIKit 확장**
UIKit의 `UIView` 클래스에 편리한 메서드를 추가할 수 있습니다.

```swift
import UIKit

extension UIView {
    func addBorder(color: UIColor, width: CGFloat) {
        self.layer.borderColor = color.cgColor
        self.layer.borderWidth = width
    }
}

let view = UIView()
view.addBorder(color: .red, width: 2.0)
```

2\.**Custom Operators**
Extensions를 통해 커스텀 연산자를 정의할 수도 있습니다.

```swift
extension Int {
    static func ** (base: Int, power: Int) -> Int {
        return Int(pow(Double(base), Double(power)))
    }
}

let result = 2 ** 3
print(result) // 출력: 8
```

### **22.6 요약**
- Extensions는 기존 타입에 새로운 기능을 추가하거나 프로토콜 준수를 구현하는 데 유용합니다.
- 주요 기능:
  - Computed Properties
  - Methods (Instance & Type)
  - Initializers
  - Subscripts
  - Nested Types
  - Protocol Conformance
- 제한 사항:
  - 저장 프로퍼티 추가 불가
  - 기존 메서드 재정의 불가

## 23.Protocols

### **23.1 프로토콜(Protocols)이란?**
프로토콜은 특정 작업이나 기능을 수행하기 위해 필요한 메서드, 프로퍼티 또는 기타 요구사항들의 청사진(blueprint)을 정의합니다. 클래스, 구조체 또는 열거형은 프로토콜을 채택(adopt)하고 준수(conform)하여 이러한 요구사항들을 실제로 구현할 수 있습니다.

프로토콜은 코드의 재사용성과 유연성을 높이며, 객체 간의 상호작용을 명확히 정의하는 데 도움을 줍니다.

### **23.2 프로토콜의 정의와 사용**
1\. **프로토콜 정의**
프로토콜은 `protocol` 키워드를 사용하여 정의됩니다. 예시는 다음과 같습니다:

```swift
protocol SomeProtocol {
    var someProperty: Int { get set } // 읽기/쓰기 가능한 프로퍼티
    func someMethod() -> String       // 메서드 요구사항
}
```

- **프로퍼티 요구사항**: 프로토콜은 특정 이름과 타입의 프로퍼티를 요구할 수 있습니다. `{ get }` 또는 `{ get set }`을 통해 읽기 전용 또는 읽기/쓰기 가능 여부를 지정합니다.
- **메서드 요구사항**: 프로토콜은 특정 이름과 파라미터, 반환 타입의 메서드를 요구할 수 있습니다.

2\. **프로토콜 채택 및 준수**
클래스, 구조체, 열거형은 프로토콜을 채택하고 요구사항을 구현하여 프로토콜을 준수할 수 있습니다.

```swift
struct SomeStructure: SomeProtocol {
    var someProperty: Int = 0 // 프로퍼티 구현
    func someMethod() -> String {
        return "Hello, Protocol!"
    }
}
```

- 프로토콜의 모든 요구사항을 구현해야 합니다. 그렇지 않으면 컴파일 오류가 발생합니다.

3\. **프로토콜 상속**
프로토콜은 다른 프로토콜을 상속받아 확장할 수 있습니다. 상속받은 프로토콜은 부모 프로토콜의 요구사항도 포함합니다.

```swift
protocol AnotherProtocol: SomeProtocol {
    func anotherMethod()
}
```

### **23.3 프로토콜의 주요 특징**
1\. **프로토콜을 이용한 다형성**
프로토콜을 타입으로 사용하여 다양한 타입의 인스턴스를 동일한 방식으로 처리할 수 있습니다.

```swift
func process(value: SomeProtocol) {
    print(value.someMethod())
}

let instance = SomeStructure()
process(value: instance)
```

2\. **프로토콜 조합**
여러 프로토콜을 동시에 준수해야 하는 경우 `&` 연산자를 사용하여 조합할 수 있습니다.

```swift
protocol Named {
    var name: String { get }
}

protocol Aged {
    var age: Int { get }
}

struct Person: Named, Aged {
    var name: String
    var age: Int
}

func wishHappyBirthday(to celebrator: Named & Aged) {
    print("Happy birthday, \(celebrator.name)! You're \(celebrator.age)")
}

let birthdayPerson = Person(name: "John", age: 30)
wishHappyBirthday(to: birthdayPerson)
```

3\. **프로토콜 확장**
`extension` 키워드를 사용하여 프로토콜에 기본 구현을 제공할 수 있습니다. 이를 통해 프로토콜을 준수하는 모든 타입이 기본적으로 해당 기능을 사용할 수 있습니다.

```swift
extension SomeProtocol {
    func someMethod() -> String {
        return "Default Implementation"
    }
}
```

4\. **프로토콜과 제네릭**
프로토콜은 제네릭과 함께 사용되어 강력한 추상화를 제공합니다. 예를 들어, 특정 프로토콜을 준수하는 타입만 제네릭 함수나 제네릭 타입에서 사용하도록 제한할 수 있습니다.

```swift
func genericFunction<T: SomeProtocol>(value: T) {
    print(value.someMethod())
}
```

### **23.4 프로토콜의 활용 사례**
1. **델리게이션(Delegation)**:
   - iOS 개발에서 델리게이션 패턴은 프로토콜을 기반으로 동작합니다. 예를 들어, `UITableViewDelegate`는 테이블 뷰의 동작을 위임받는 역할을 합니다.

2. **타입 지정**:
   - 컬렉션 내에서 특정 프로토콜을 준수하는 타입만 저장하거나 처리할 수 있습니다.

3. **코드 재사용성**:
   - 여러 타입에서 공통된 기능을 정의하고 구현할 수 있어 코드의 재사용성을 높입니다.

### **23.5 요약**
Swift의 프로토콜은 다음과 같은 핵심 개념을 제공합니다:
- **청사진 역할**: 메서드, 프로퍼티 등의 요구사항을 정의합니다.
- **다형성 지원**: 프로토콜을 타입으로 사용하여 다양한 타입을 동일한 방식으로 처리할 수 있습니다.
- **확장 가능성**: 프로토콜 확장을 통해 기본 구현을 제공할 수 있습니다.
- **유연성**: 프로토콜 조합, 상속 등을 통해 복잡한 요구사항을 표현할 수 있습니다.


## 24.Generics
**제네릭(Generic)**은 Swift에서 코드의 재사용성을 높이고 유연성을 제공하는 중요한 기능입니다. 제네릭을 사용하면 특정 타입에 종속되지 않고 다양한 타입에서 동작할 수 있는 함수, 메서드, 클래스, 구조체 등을 작성할 수 있습니다.

예를 들어, 배열(Array)이나 딕셔너리(Dictionary)와 같은 Swift 표준 라이브러리는 제네릭을 통해 모든 데이터 타입을 처리할 수 있도록 설계되었습니다.

### **24.1 제네릭의 필요성**
Swift에서는 타입 안전성이 중요합니다. 따라서 타입을 명확히 지정하지 않으면 컴파일 오류가 발생할 수 있습니다. 하지만 타입마다 동일한 로직을 반복적으로 작성하는 것은 비효율적입니다.

예시:
```swift
func swapTwoInts(_ a: inout Int, _ b: inout Int) {
    let temp = a
    a = b
    b = temp
}

func swapTwoStrings(_ a: inout String, _ b: inout String) {
    let temp = a
    a = b
    b = temp
}
```
위 예시처럼 `Int`와 `String`을 교환하는 함수를 각각 작성해야 한다면, 타입마다 함수를 새로 만들어야 합니다. 이를 해결하기 위해 제네릭을 사용할 수 있습니다.

### **24.2 제네릭 함수**
제네릭 함수는 특정 타입에 종속되지 않고 여러 타입에서 동작할 수 있는 함수입니다. 아래는 제네릭을 사용한 예시입니다.

```swift
func swapTwoValues<T>(_ a: inout T, _ b: inout T) {
    let temp = a
    a = b
    b = temp
}
```

- `<T>`는 제네릭 타입 매개변수를 나타냅니다. 여기서 `T`는 "Type"의 약자로, 실제 사용 시 어떤 타입이든 될 수 있습니다.
- `swapTwoValues` 함수는 `Int`, `String`, `Double` 등 다양한 타입에서 사용할 수 있습니다.

사용 예시:
```swift
var intA = 3, intB = 5
swapTwoValues(&intA, &intB)
print(intA, intB) // 출력: 5, 3

var stringA = "Hello", stringB = "World"
swapTwoValues(&stringA, &stringB)
print(stringA, stringB) // 출력: World, Hello
```

### **24.3 제네릭 타입**
제네릭은 함수뿐만 아니라 타입(클래스, 구조체, 열거형)에서도 사용할 수 있습니다.

1\.예시: 제네릭 스택(Stack)
```swift
struct Stack<Element> {
    var items = [Element]()
    
    mutating func push(_ item: Element) {
        items.append(item)
    }
    
    mutating func pop() -> Element {
        return items.removeLast()
    }
}
```

- `Stack`은 제네릭 타입으로, `Element`라는 제네릭 매개변수를 사용합니다.
- `Element`는 실제로 사용될 때 결정되며, 어떤 타입이든 될 수 있습니다.

```swift
var intStack = Stack<Int>()
intStack.push(1)
intStack.push(2)
print(intStack.pop()) // 출력: 2

var stringStack = Stack<String>()
stringStack.push("Hello")
stringStack.push("World")
print(stringStack.pop()) // 출력: World
```

### **24.4 제네릭의 확장(Extensions with Generics)**
제네릭 타입은 확장(Extension)을 통해 추가 기능을 제공할 수 있습니다.

```swift
extension Stack {
    var topItem: Element? {
        return items.last
    }
}
```

- `topItem`은 스택의 가장 위에 있는 항목을 반환합니다.
- 제네릭 타입인 `Element`를 그대로 사용할 수 있습니다.

```swift
if let top = intStack.topItem {
    print("Top item is \(top)")
} else {
    print("Stack is empty")
}
```

### **24.5 제네릭의 제약(Constraints)**
때로는 제네릭 타입에 특정 조건을 부여해야 할 때가 있습니다. 이를 위해 **타입 제약(Type Constraints)**을 사용할 수 있습니다.

1\.문법:
```swift
func someFunction<T: SomeClass, U: SomeProtocol>(someT: T, someU: U) {
    // ...
}
```

2\. 예시: Equatable 프로토콜을 준수하는 타입만 허용
```swift
func findIndex<T: Equatable>(of valueToFind: T, in array: [T]) -> Int? {
    for (index, value) in array.enumerated() {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
```

- `T: Equatable`은 `T`가 `Equatable` 프로토콜을 준수해야 함을 의미합니다.
- `Equatable`은 두 값을 비교할 수 있는 타입(예: `==` 연산자 사용 가능)을 나타냅니다.

```swift
let numbers = [1, 2, 3, 4, 5]
if let index = findIndex(of: 3, in: numbers) {
    print("Found at index \(index)") // 출력: Found at index 2
}
```

### **24.6 제네릭의 장점**
1. **코드 재사용성**: 한 번 작성한 코드를 다양한 타입에서 사용할 수 있습니다.
2. **타입 안전성**: 컴파일 시점에 타입 검사를 수행하여 오류를 방지합니다.
3. **유연성**: 다양한 타입을 지원하면서도 코드의 가독성을 유지합니다.

### **24.7 주요 용어 정리**
- **제네릭 타입 매개변수(Generic Type Parameter)**: `<T>`와 같이 사용되는 플레이스홀더로, 실제 타입은 사용 시 결정됩니다.
- **타입 제약(Type Constraint)**: 제네릭 타입이 특정 프로토콜 또는 클래스를 준수하도록 제한하는 조건.
- **불투명 타입(Opaque Types)**: 제네릭과 관련된 개념으로, 반환 타입을 구체적으로 노출하지 않는 경우(`some` 키워드 사용).

## 25.Opaque and Boxed Protocol Types

Swift의 **Opaque Types**는 함수나 메서드가 반환하는 타입이 구체적으로 명시되지 않지만, 특정 프로토콜을 준수하는 타입임을 보장하는 방식입니다. 이는 `some` 키워드를 통해 표현됩니다.

### **25.1 핵심 특징**
1. **구체적인 타입 숨기기**: 함수나 메서드가 반환하는 실제 타입을 숨길 수 있습니다.
2. **타입 안정성 유지**: 반환된 값은 특정 프로토콜을 준수하므로, 타입 안정성을 유지합니다.
3. **유연성 제공**: 구현 세부사항을 노출하지 않고도, 호출자는 반환된 값의 동작을 예측할 수 있습니다.

### 25.2 **Opaque Types의 기본 문법**

```swift
func someFunction() -> some Protocol {
    // 반환값은 Protocol을 준수하는 특정 타입
}
```

- `some` 키워드는 반환 타입이 특정 프로토콜을 준수하는 **하나의 구체적 타입**임을 나타냅니다.
- 호출자는 반환된 값의 실제 타입을 알 필요가 없으며, 단지 해당 프로토콜의 요구사항을 사용할 수 있습니다.

### 25.3 **Opaque Types vs. 프로토콜 타입**

| **특징**              | **Opaque Types (`some`)**                          | **프로토콜 타입**                     |
|-----------------------|----------------------------------------------------|---------------------------------------|
| **타입 일관성**       | 항상 동일한 구체적 타입을 반환함                   | 다양한 타입을 반환할 수 있음          |
| **타입 추론 가능성**  | 컴파일러가 반환 타입을 추론할 수 있음              | 호출자가 반환 타입을 직접 관리해야 함 |
| **사용 용도**         | SwiftUI 등에서 뷰 계층 구조를 간결하게 표현         | 다형성을 활용한 유연한 설계           |


### 25.4 **Opaque Types의 주요 사용 사례**

1\. **SwiftUI에서 View 반환**
SwiftUI에서는 `View` 프로토콜을 준수하는 타입을 반환하는 경우가 많습니다. 이때 `some View`를 사용하여 구체적인 타입을 숨길 수 있습니다.

```swift
import SwiftUI

struct ContentView: View {
    var body: some View {
        Text("Hello, World!")
    }
}
```

- `body`는 `View` 프로토콜을 준수하는 **하나의 구체적 타입**을 반환합니다.
- 호출자는 `Text`가 반환된다는 사실을 몰라도 `View`의 메서드를 사용할 수 있습니다.

2\. **다양한 타입을 반환하는 함수**
Opaque Types는 함수 내부에서 다양한 타입을 반환하면서도, 외부에서는 동일한 프로토콜을 준수하는 타입으로 처리할 수 있게 합니다.

```swift
protocol Shape {
    func draw() -> String
}

struct Circle: Shape {
    func draw() -> String {
        return "Drawing a circle"
    }
}

struct Rectangle: Shape {
    func draw() -> String {
        return "Drawing a rectangle"
    }
}

func createShape(isCircle: Bool) -> some Shape {
    if isCircle {
        return Circle()
    } else {
        return Rectangle()
    }
}

let shape = createShape(isCircle: true)
print(shape.draw()) // "Drawing a circle"
```

- `createShape` 함수는 `Shape` 프로토콜을 준수하는 타입을 반환합니다.
- 호출자는 반환된 값이 `Circle`인지 `Rectangle`인지 알 필요가 없습니다.

### 25.5 **주의사항**
1. **단일 타입만 반환 가능**: `some` 키워드는 함수가 항상 동일한 구체적 타입을 반환해야 합니다. 서로 다른 타입을 조건에 따라 반환하는 것은 불가능합니다.
   ```swift
   func invalidFunction(condition: Bool) -> some Shape {
       if condition {
           return Circle() // Error: 두 개의 다른 타입을 반환할 수 없음
       } else {
           return Rectangle()
       }
   }
   ```
2. **프로토콜 준수 필수**: 반환된 값은 반드시 지정된 프로토콜을 준수해야 합니다.

### 25.6 **요약**
- **Opaque Types**는 `some` 키워드를 통해 구체적인 타입을 숨기고, 특정 프로토콜을 준수하는 타입을 반환합니다.
- SwiftUI와 같은 프레임워크에서 뷰 계층 구조를 간결하게 표현하는 데 유용합니다.
- 반환 타입은 항상 동일한 구체적 타입이어야 하며, 호출자는 프로토콜의 요구사항만 사용할 수 있습니다.

## 26.Automatic Reference Counting
### **26.1 Automatic Reference Counting (ARC)란?**
- ARC는 Swift에서 클래스 인스턴스의 메모리를 자동으로 관리하는 시스템입니다.
- 개발자가 수동으로 메모리를 할당하거나 해제할 필요가 없습니다.
- 클래스 인스턴스가 더 이상 사용되지 않을 때, ARC는 해당 인스턴스를 자동으로 메모리에서 해제합니다.


### **26.2 ARC 동작 원리**
ARC는 각 클래스 인스턴스의 참조 횟수를 추적하여 메모리를 관리합니다:
1. **참조 횟수 증가**:
   - 새로운 상수, 변수 또는 프로퍼티가 특정 인스턴스를 참조하면 참조 횟수가 1 증가합니다.
2. **참조 횟수 감소**:
   - 참조하던 변수나 상수가 더 이상 해당 인스턴스를 가리키지 않으면 참조 횟수가 1 감소합니다.
3. **메모리 해제**:
   - 참조 횟수가 0이 되면 ARC는 해당 인스턴스를 메모리에서 해제하고, `deinit` 메서드(디이니셜라이저)를 호출합니다.


### **26.3 강한 참조와 순환 참조 문제**
1\.**강한 참조 (Strong Reference)**
- 기본적으로 모든 참조는 "강한 참조"입니다.
- 강한 참조는 참조된 인스턴스가 메모리에서 해제되지 않도록 유지합니다.

2\.**순환 참조 (Retain Cycle)**
- 두 개 이상의 인스턴스가 서로를 강하게 참조하면, 참조 횟수가 0이 될 수 없어 메모리 누수가 발생합니다.
- 이를 해결하기 위해 **약한 참조(weak reference)** 또는 **비소유 참조(unowned reference)**를 사용합니다.

3\.**약한 참조 (Weak Reference)**
- `weak` 키워드를 사용하여 선언합니다.
- 약한 참조는 참조 횟수에 영향을 주지 않습니다.
- 참조된 객체가 해제되면 `nil`이 됩니다. 따라서 반드시 옵셔널 타입으로 선언해야 합니다.

4\.**비소유 참조 (Unowned Reference)**
- `unowned` 키워드를 사용하여 선언합니다.
- 비소유 참조도 참조 횟수에 영향을 주지 않습니다.
- 참조된 객체가 해제되어도 값이 `nil`로 변경되지 않으므로, 잘못된 참조로 인해 런타임 오류가 발생할 수 있습니다.
- 참조된 객체가 항상 유효하다고 보장되는 경우에만 사용합니다.

### **26.4 예시 코드**
아래는 ARC와 관련된 간단한 예시입니다:

1\.**기본 ARC 동작**
```swift
class Person {
    let name: String
    init(name: String) {
        self.name = name
        print("\(name) is being initialized")
    }
    deinit {
        print("\(name) is being deinitialized")
    }
}

var reference1: Person?
var reference2: Person?
var reference3: Person?

reference1 = Person(name: "John") // "John is being initialized"
reference2 = reference1          // 참조 횟수 증가
reference3 = reference1          // 참조 횟수 증가

reference1 = nil                 // 참조 횟수 감소
reference2 = nil                 // 참조 횟수 감소
reference3 = nil                 // 참조 횟수 0 -> "John is being deinitialized"
```

2\.**순환 참조 예시 및 해결**
```swift
class Person {
    let name: String
    var apartment: Apartment?
    init(name: String) { self.name = name }
    deinit { print("\(name) is being deinitialized") }
}

class Apartment {
    let unit: String
    weak var tenant: Person? // 약한 참조로 순환 참조 방지
    init(unit: String) { self.unit = unit }
    deinit { print("Apartment \(unit) is being deinitialized") }
}

var john: Person? = Person(name: "John")
var unit4A: Apartment? = Apartment(unit: "4A")

john?.apartment = unit4A
unit4A?.tenant = john

john = nil  // "John is being deinitialized"
unit4A = nil // "Apartment 4A is being deinitialized"
```

### **26.5 주의사항**
- **클래스 전용**: ARC는 클래스 타입에만 적용됩니다. 구조체(struct)와 열거형(enum)은 값 타입이므로 ARC와 무관합니다.
- **메모리 누수 방지**: 순환 참조를 피하기 위해 적절히 `weak` 또는 `unowned`를 사용해야 합니다.
- **디버깅 도구 활용**: Xcode의 메모리 디버깅 도구(Instruments)를 통해 메모리 누수를 확인할 수 있습니다.

## 27.Memory Safety
Swift는 프로그래머가 실수로 메모리를 잘못 접근하거나 사용하지 않도록 설계되었습니다. 이를 통해 애플리케이션의 안정성과 성능을 보장합니다. Swift의 메모리 안전성은 다음과 같은 주요 원칙을 기반으로 합니다:

1. **동시성(Concurrency) 문제 방지**
2. **메모리 충돌(Memory Conflicts) 해결**
3. **값의 소유권 및 복사 관리**

### **27.1 동시성 문제 방지**
Swift는 여러 스레드에서 동시에 데이터를 접근할 때 발생할 수 있는 충돌을 방지하기 위해 **Exclusive Access to Memory** 규칙을 적용합니다. 이 규칙은 특정 메모리 위치에 대해 한 번에 하나의 작업만 수행되도록 보장합니다.

1\.예시:
```swift
var number = 10

func increment() {
    number += 1
}

// 동시에 `number`에 접근하는 경우 충돌 가능성이 있음
increment()
print(number)
```

위 코드에서 `number` 변수는 단일 스레드에서만 접근되므로 문제가 없습니다. 그러나 여러 스레드에서 동시에 접근한다면 Swift 컴파일러는 경고를 발생시키거나 런타임 오류를 유발할 수 있습니다.

### **27.2 메모리 충돌 해결**
Swift는 **Overlapping Access to Memory** 문제를 방지하기 위해 명확한 규칙을 제공합니다. 특히, 함수 인자로 전달된 값이나 참조가 서로 겹칠 때 발생할 수 있는 충돌을 처리합니다.

1\.Overlapping Access의 두 가지 유형:
- **Read-Only Access**: 읽기 작업은 일반적으로 안전합니다.
- **Read-Write 또는 Write-Write Access**: 쓰기 작업은 충돌 가능성이 있습니다.

2\.예시:
```swift
var stepSize = 1

func balance(_ x: inout Int, _ y: inout Int) {
    x += y
    y += x
}

// 동일한 변수를 두 개의 인자로 전달하면 충돌 발생
balance(&stepSize, &stepSize) // Error: overlapping access
```

위 코드에서 `stepSize` 변수가 두 개의 `inout` 파라미터로 전달되면서 메모리 충돌이 발생합니다. Swift는 이를 감지하고 컴파일 타임에 에러를 발생시킵니다.

### **27.3 값의 소유권 및 복사 관리**
Swift는 값 타입(Value Types)과 참조 타입(Reference Types)을 구분하며, 각각의 메모리 관리 방식을 제공합니다.

1\.값 타입 (Value Types)
- Struct, Enum, Tuple 등이 포함됩니다.
- 값 타입은 기본적으로 **복사**됩니다. 즉, 새로운 인스턴스를 생성하여 원본 데이터를 보호합니다.

2\.참조 타입 (Reference Types)
- Class가 포함됩니다.
- 참조 타입은 메모리 주소를 공유하므로, 여러 객체가 동일한 데이터를 참조할 수 있습니다.

3\.Copy-on-Write 최적화
Swift는 값 타입의 성능을 최적화하기 위해 **Copy-on-Write** 기법을 사용합니다. 이는 실제로 값이 수정되기 전까지는 복사가 이루어지지 않는 방식입니다.

### **27.4 메모리 안전성을 보장하는 Swift의 도구**
Swift는 메모리 안전성을 보장하기 위해 다양한 내장 도구와 규칙을 제공합니다.

1\.**Automatic Reference Counting (ARC)**
- Swift는 참조 타입(Class)의 메모리 관리를 자동으로 처리합니다.
- 객체의 참조 카운트가 0이 되면 메모리에서 해제됩니다.

2\.**Optional Binding**
- nil 값을 안전하게 처리하기 위해 Optional 타입을 사용합니다.
- 강제 언래핑(`!`) 없이도 안전하게 값을 접근할 수 있습니다.

3\.**Access Control**
- 변수나 함수의 접근 권한을 제한하여 의도치 않은 메모리 접근을 방지합니다.

### **27.5 실습 예제**
아래는 메모리 안전성을 고려한 간단한 예제입니다.

```swift
struct Point {
    var x: Int
    var y: Int
}

func updatePoint(_ point: inout Point) {
    point.x += 10
    point.y += 10
}

var origin = Point(x: 0, y: 0)

// 메모리 충돌 없이 안전하게 업데이트
updatePoint(&origin)
print("Updated Point: (\(origin.x), \(origin.y))")
```

위 코드는 `inout` 파라미터를 사용하여 메모리 충돌 없이 안전하게 값을 업데이트합니다.

### 27.6 **결론**
Swift의 메모리 안전성은 프로그래머가 실수로 메모리를 잘못 사용하지 않도록 설계되었습니다. 이를 통해 애플리케이션의 안정성과 성능을 극대화할 수 있습니다. 메모리 안전성을 이해하고 적절히 활용하면 더 나은 Swift 코드를 작성할 수 있습니다.

## 28.Access Control
Swift의 접근 제어는 코드 내의 특정 선언(클래스, 구조체, 함수, 변수 등)이 어디에서 접근 가능한지를 제한하는 메커니즘입니다. 이를 통해 코드의 캡슐화를 강화하고, 의도하지 않은 외부 접근을 방지하며, 모듈 간의 명확한 경계를 설정할 수 있습니다.

### 28.1 **접근 레벨(Access Levels)**
Swift에서는 5가지의 접근 레벨을 제공합니다. 각 레벨은 선언된 엔티티가 어디에서 접근 가능한지를 결정합니다.

1. **`open`**  
   - 가장 넓은 범위의 접근 레벨.
   - 다른 모듈에서도 접근 가능하며, 상속 및 재정의도 허용됩니다.
   - 주로 프레임워크나 라이브러리를 개발할 때 사용됩니다.

2. **`public`**  
   - `open`과 유사하게 다른 모듈에서도 접근 가능.
   - 하지만 `public`으로 선언된 클래스나 메서드는 상속이나 재정의가 불가능합니다.

3. **`internal`**  
   - 기본 접근 레벨(default).
   - 동일한 모듈 내에서만 접근 가능.
   - 별도의 접근 제어 지정자가 없는 경우 자동으로 `internal`로 설정됩니다.

4. **`fileprivate`**  
   - 선언된 파일 내에서만 접근 가능.
   - 해당 파일 내부에서만 사용해야 하는 구현 세부 사항을 숨기고 싶을 때 유용합니다.

5. **`private`**  
   - 가장 제한적인 접근 레벨.
   - 선언된 스코프(예: 클래스, 구조체, 함수) 내에서만 접근 가능.
   - 외부에서 전혀 접근할 필요가 없는 경우에 사용됩니다.

### 28.2 **접근 레벨의 규칙**
Swift의 접근 제어는 "선언된 엔티티보다 더 넓은 범위에서 접근할 수 없다"는 원칙을 따릅니다. 즉, 어떤 타입의 접근 레벨은 그 타입을 구성하는 요소들의 접근 레벨보다 같거나 더 좁아야 합니다.

1\.예시:
```swift
public class SomeClass {
    private func someMethod() { } // private 메서드는 public 클래스 내에서만 접근 가능
}
```

### 28.3 **접근 제어의 적용**
1\. **타입과 멤버**
- 타입 자체의 접근 레벨은 그 타입의 멤버(프로퍼티, 메서드 등)의 접근 레벨보다 같거나 더 넓어야 합니다.
- 예: `internal` 클래스 내부에는 `public` 메서드를 선언할 수 없습니다.

2\. **상속**
- 서브클래스는 슈퍼클래스와 같은 접근 레벨 또는 더 제한적인 접근 레벨을 가져야 합니다.
- `open` 클래스만 다른 모듈에서 상속될 수 있습니다.

3\. **프로토콜**
- 프로토콜의 요구사항은 프로토콜 자체의 접근 레벨보다 같거나 더 제한적이어야 합니다.

4\. **익스텐션**
- 익스텐션은 확장하려는 타입의 접근 레벨을 따릅니다.
- 특정 파일 내에서만 사용되는 익스텐션은 `fileprivate` 또는 `private`으로 제한할 수 있습니다.

### 28.4 **모듈과 소스 파일**
- **모듈(Module)**: 하나의 패키지 단위로, 애플리케이션 또는 프레임워크로 배포됩니다.
- **소스 파일(Source File)**: 모듈 내의 개별 `.swift` 파일.
- 접근 제어는 모듈과 소스 파일의 경계를 기준으로 동작합니다.

### 28.5 **실제 사용 예시**
```swift
// internal (기본값)
class MyClass {
    private var secretValue = 42

    func getSecretValue() -> Int {
        return secretValue
    }
}

// public 클래스
public class PublicClass {
    fileprivate var restrictedValue = 100

    func getRestrictedValue() -> Int {
        return restrictedValue
    }
}

// open 클래스
open class OpenClass {
    open func openMethod() { }
    public func publicMethod() { }
}
```

### 28.6 **요약**
- **접근 제어**는 코드의 캡슐화와 모듈 간의 경계를 설정하는 중요한 도구입니다.
- **접근 레벨**: `open`, `public`, `internal`, `fileprivate`, `private`.
- **기본 접근 레벨**: `internal`.
- **규칙**: 선언된 엔티티보다 더 넓은 범위에서 접근할 수 없습니다.

## 29.Advanced Operators
### **29.1 비트 연산자 (Bitwise Operators)**
비트 연산자는 데이터의 각 비트를 직접 조작하는 데 사용됩니다. 주로 저수준 프로그래밍이나 성능 최적화가 필요한 상황에서 활용됩니다.

1\.**주요 비트 연산자**
- **비트 NOT (~)**: 비트 값을 반전시킵니다.
  ```swift
  let initialBits: UInt8 = 0b00001111
  let invertedBits = ~initialBits // 0b11110000
  ```

- **비트 AND (&)**: 두 비트가 모두 `1`일 때만 결과가 `1`이 됩니다.
  ```swift
  let firstBits: UInt8 = 0b00001111
  let secondBits: UInt8 = 0b00111100
  let combinedBits = firstBits & secondBits // 0b00001100
  ```

- **비트 OR (|)**: 두 비트 중 하나라도 `1`이면 결과가 `1`이 됩니다.
  ```swift
  let combinedBits = firstBits | secondBits // 0b00111111
  ```

- **비트 XOR (^)**: 두 비트가 서로 다를 때만 결과가 `1`이 됩니다.
  ```swift
  let combinedBits = firstBits ^ secondBits // 0b00110011
  ```

- **비트 시프트 연산자 (<<, >>)**: 비트를 왼쪽 또는 오른쪽으로 이동시킵니다.
  ```swift
  let shiftedBits = firstBits << 2 // 0b00111100
  ```

### **29.2 오버플로 연산자 (Overflow Operators)**
Swift는 기본적으로 안전한 연산을 제공하며, 오버플로가 발생하면 런타임 에러를 발생시킵니다. 하지만 의도적으로 오버플로를 허용하고 싶다면, 특별한 오버플로 연산자를 사용할 수 있습니다.

1\. **오버플로 연산자 종류**
- **덧셈 오버플로 (&+)**: 덧셈 시 오버플로를 허용합니다.
- **뺄셈 오버플로 (&-)**: 뺄셈 시 오버플로를 허용합니다.
- **곱셈 오버플로 (&*)**: 곱셈 시 오버플로를 허용합니다.

```swift
var unsignedOverflow = UInt8.max
unsignedOverflow = unsignedOverflow &+ 1 // 0으로 돌아감 (오버플로)
```

### **29.3 우선순위와 결합성 (Precedence and Associativity)**
연산자의 우선순위와 결합성은 표현식을 평가할 때 중요한 역할을 합니다. Swift에서는 연산자의 우선순위와 결합성을 명확히 정의하여 코드의 가독성과 안정성을 높입니다.

- **우선순위(Precedence)**: 어떤 연산자가 먼저 계산될지를 결정합니다. 예를 들어, 곱셈(`*`)은 덧셈(`+`)보다 우선순위가 높습니다.
- **결합성(Associativity)**: 동일한 우선순위를 가진 연산자가 있을 때 계산 순서를 결정합니다. 예를 들어, 덧셈(`+`)은 왼쪽 결합성을 가집니다.

```swift
let result = 5 + 4 * 3 // 곱셈이 먼저 계산됨 (결과: 17)
```

### **29.4 사용자 정의 연산자 (Custom Operators)**
Swift에서는 새로운 연산자를 정의하거나 기존 연산자의 동작을 재정의할 수 있습니다. 이를 통해 특정 도메인에 맞는 연산자를 만들 수 있습니다.

1\.**사용자 정의 연산자 정의 방법**
1. 연산자 이름을 정의합니다.
2. `prefix`, `infix`, `postfix` 중 하나를 선택하여 연산자의 위치를 지정합니다.
3. 연산자의 동작을 구현합니다.

```swift
// 사용자 정의 연산자 선언
prefix operator +++

// 사용자 정의 연산자 구현
prefix func +++(value: inout Int) -> Int {
    value += 2
    return value
}

var number = 5
+++number // number는 7이 됨
```

### **29.5 연산자 함수 (Operator Functions)**
기존 연산자를 확장하거나 사용자 정의 타입에 적용할 수 있습니다. 이를 통해 클래스, 구조체, 열거형 등에서도 연산자를 사용할 수 있습니다.

```swift
struct Vector2D {
    var x: Int
    var y: Int
}

// 벡터 덧셈 연산자 정의
func + (left: Vector2D, right: Vector2D) -> Vector2D {
    return Vector2D(x: left.x + right.x, y: left.y + right.y)
}

let vector1 = Vector2D(x: 1, y: 2)
let vector2 = Vector2D(x: 3, y: 4)
let resultVector = vector1 + vector2 // Vector2D(x: 4, y: 6)
```

### **29.6 할당 연산자와 결합 (Assignment Operator)**
Swift의 할당 연산자(`=`)는 다른 연산자와 결합하여 사용할 수 있습니다. 예를 들어, `+=`, `-=`, `*=` 등의 복합 할당 연산자를 사용할 수 있습니다.

```swift
var score = 10
score += 5 // score는 15가 됨
```

