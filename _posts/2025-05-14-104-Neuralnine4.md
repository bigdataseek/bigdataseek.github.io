---
title: 8차시 4:Neuralnine(자료 구조 2)
layout: single
classes: wide
categories:
  - Data Structure
toc: true # 이 포스트에서 목차를 활성화
toc_sticky: true # 목차를 고정할지 여부 (선택 사항)
---

## 6. 힙 (Heap)

### 6.1 개념 설명
힙은 **우선순위 큐**를 구현하는 데 사용되는 완전 이진 트리입니다. 항상 균형을 유지하며, 배열로 효율적으로 구현할 수 있습니다.

- **Min Heap**: 부모 노드가 자식보다 작음 (최솟값이 루트)
- **Max Heap**: 부모 노드가 자식보다 큼 (최댓값이 루트)

**배열 인덱스 관계**:
- 부모: `(i-1) // 2`
- 왼쪽 자식: `2*i + 1`
- 오른쪽 자식: `2*i + 2`

### 6.2 샘플 코드

```python
# 힙 (Heap) 구현

class MinHeap:
    """최소 힙 구현"""
    def __init__(self):
        self.heap = []
    
    def parent(self, i):
        """부모 노드 인덱스"""
        return (i - 1) // 2
    
    def left_child(self, i):
        """왼쪽 자식 인덱스"""
        return 2 * i + 1
    
    def right_child(self, i):
        """오른쪽 자식 인덱스"""
        return 2 * i + 2
    
    def swap(self, i, j):
        """두 요소 교환"""
        self.heap[i], self.heap[j] = self.heap[j], self.heap[i]
    
    def insert(self, value):
        """값 삽입 - O(log N)"""
        self.heap.append(value)
        self._sift_up(len(self.heap) - 1)
    
    def _sift_up(self, i):
        """삽입 후 힙 속성 유지 (위로 이동)"""
        parent = self.parent(i)
        
        # 부모보다 작으면 교환
        if i > 0 and self.heap[i] < self.heap[parent]:
            self.swap(i, parent)
            self._sift_up(parent)
    
    def extract_min(self):
        """최솟값 추출 - O(log N)"""
        if not self.heap:
            return None
        
        if len(self.heap) == 1:
            return self.heap.pop()
        
        # 루트와 마지막 요소 교환
        min_value = self.heap[0]
        self.heap[0] = self.heap.pop()
        self._sift_down(0)
        
        return min_value
    
    def _sift_down(self, i):
        """추출 후 힙 속성 유지 (아래로 이동)"""
        min_index = i
        left = self.left_child(i)
        right = self.right_child(i)
        
        # 왼쪽 자식과 비교
        if left < len(self.heap) and self.heap[left] < self.heap[min_index]:
            min_index = left
        
        # 오른쪽 자식과 비교
        if right < len(self.heap) and self.heap[right] < self.heap[min_index]:
            min_index = right
        
        # 교환이 필요하면 재귀 호출
        if min_index != i:
            self.swap(i, min_index)
            self._sift_down(min_index)
    
    def peek(self):
        """최솟값 확인 - O(1)"""
        return self.heap[0] if self.heap else None
    
    def size(self):
        """힙 크기"""
        return len(self.heap)
    
    def is_empty(self):
        """비어있는지 확인"""
        return len(self.heap) == 0
    
    def display(self):
        """힙 내용 출력"""
        print(f"힙 배열: {self.heap}")

# 사용 예제
print("=== 힙 예제 1: 기본 동작 ===")
heap = MinHeap()

numbers = [15, 10, 20, 8, 12, 25, 6]
print(f"삽입할 숫자: {numbers}")

for num in numbers:
    heap.insert(num)
    print(f"{num} 삽입 후:", end=" ")
    heap.display()

print(f"\n최솟값 확인: {heap.peek()}")

print("\n최솟값 추출:")
while not heap.is_empty():
    print(f"  추출: {heap.extract_min()}, 남은 힙: {heap.heap}")


# 최대 힙 구현
class MaxHeap:
    """최대 힙 구현"""
    def __init__(self):
        self.heap = []
    
    def parent(self, i):
        return (i - 1) // 2
    
    def left_child(self, i):
        return 2 * i + 1
    
    def right_child(self, i):
        return 2 * i + 2
    
    def swap(self, i, j):
        self.heap[i], self.heap[j] = self.heap[j], self.heap[i]
    
    def insert(self, value):
        self.heap.append(value)
        self._sift_up(len(self.heap) - 1)
    
    def _sift_up(self, i):
        parent = self.parent(i)
        # 최대 힙: 부모보다 크면 교환
        if i > 0 and self.heap[i] > self.heap[parent]:
            self.swap(i, parent)
            self._sift_up(parent)
    
    def extract_max(self):
        if not self.heap:
            return None
        
        if len(self.heap) == 1:
            return self.heap.pop()
        
        max_value = self.heap[0]
        self.heap[0] = self.heap.pop()
        self._sift_down(0)
        
        return max_value
    
    def _sift_down(self, i):
        max_index = i
        left = self.left_child(i)
        right = self.right_child(i)
        
        # 최대 힙: 가장 큰 값 찾기
        if left < len(self.heap) and self.heap[left] > self.heap[max_index]:
            max_index = left
        
        if right < len(self.heap) and self.heap[right] > self.heap[max_index]:
            max_index = right
        
        if max_index != i:
            self.swap(i, max_index)
            self._sift_down(max_index)
    
    def peek(self):
        return self.heap[0] if self.heap else None

print("\n\n=== 힙 예제 2: 최대 힙 ===")
max_heap = MaxHeap()

for num in [15, 10, 20, 8, 12, 25, 6]:
    max_heap.insert(num)

print(f"최대 힙: {max_heap.heap}")
print(f"최댓값 추출: {max_heap.extract_max()}")
print(f"남은 힙: {max_heap.heap}")


# 실전 활용: 우선순위 큐
class PriorityQueue:
    """힙을 이용한 우선순위 큐 (작은 숫자가 높은 우선순위)"""
    def __init__(self):
        self.heap = MinHeap()
    
    def enqueue(self, priority, task):
        """작업 추가"""
        self.heap.insert((priority, task))
        print(f"추가: [{priority}] {task}")
    
    def dequeue(self):
        """가장 높은 우선순위 작업 처리"""
        if self.heap.is_empty():
            return None
        priority, task = self.heap.extract_min()
        return priority, task
    
    def peek(self):
        """다음 작업 확인"""
        if self.heap.is_empty():
            return None
        return self.heap.peek()

print("\n\n=== 힙 예제 3: 우선순위 큐 (작업 스케줄링) ===")
pq = PriorityQueue()

pq.enqueue(3, "이메일 확인")
pq.enqueue(1, "긴급 회의")
pq.enqueue(2, "보고서 작성")
pq.enqueue(1, "버그 수정")

print("\n작업 처리 순서:")
while not pq.heap.is_empty():
    priority, task = pq.dequeue()
    print(f"  처리: [{priority}] {task}")


# 실전 활용: K번째 최소값 찾기
def find_kth_smallest(numbers, k):
    """K번째로 작은 수 찾기"""
    heap = MinHeap()
    
    for num in numbers:
        heap.insert(num)
    
    # k-1번 추출
    for _ in range(k - 1):
        heap.extract_min()
    
    return heap.extract_min()

print("\n\n=== 힙 예제 4: K번째 최소값 ===")
nums = [7, 10, 4, 3, 20, 15]
print(f"배열: {nums}")
print(f"3번째로 작은 수: {find_kth_smallest(nums, 3)}")


# 실전 활용: 실시간 중간값
class MedianFinder:
    """두 개의 힙을 이용한 중간값 찾기"""
    def __init__(self):
        self.max_heap = MaxHeap()  # 작은 절반 (최댓값이 중간값)
        self.min_heap = MinHeap()  # 큰 절반 (최솟값이 중간값)
    
    def add_number(self, num):
        """숫자 추가"""
        # 일단 max_heap에 추가
        if self.max_heap.heap == [] or num <= self.max_heap.peek():
            self.max_heap.insert(num)
        else:
            self.min_heap.insert(num)
        
        # 균형 맞추기
        if len(self.max_heap.heap) > len(self.min_heap.heap) + 1:
            self.min_heap.insert(self.max_heap.extract_max())
        elif len(self.min_heap.heap) > len(self.max_heap.heap):
            self.max_heap.insert(self.min_heap.extract_min())
    
    def find_median(self):
        """중간값 반환"""
        if len(self.max_heap.heap) > len(self.min_heap.heap):
            return self.max_heap.peek()
        else:
            return (self.max_heap.peek() + self.min_heap.peek()) / 2

print("\n\n=== 힙 예제 5: 스트리밍 중간값 ===")
mf = MedianFinder()

stream = [5, 15, 1, 3, 8, 7, 9, 10]
print("숫자 스트림에서 실시간 중간값:")

for num in stream:
    mf.add_number(num)
    print(f"  {num} 추가 → 중간값: {mf.find_median()}")


# Python의 heapq 모듈 사용
import heapq

print("\n\n=== 파이썬 heapq 모듈 ===")
heap_list = []

# 삽입
for num in [3, 1, 4, 1, 5, 9, 2, 6]:
    heapq.heappush(heap_list, num)

print(f"힙: {heap_list}")
print(f"최솟값 추출: {heapq.heappop(heap_list)}")
print(f"남은 힙: {heap_list}")

# 기존 리스트를 힙으로 변환
numbers = [9, 5, 7, 1, 3]
heapq.heapify(numbers)
print(f"\nheapify 후: {numbers}")
```

## 7. 트라이 (Trie)

### 7.1 개념 설명
트라이는 **문자열 검색에 특화된** 트리 구조입니다. 각 노드가 문자 하나를 나타내며, 경로가 단어를 형성합니다. 자동완성, 맞춤법 검사 등에 사용됩니다.

**장점**: 문자열 검색이 문자열 길이에만 비례 O(M)
**단점**: 메모리 사용량이 많을 수 있음

### 7.2 샘플 코드
```python
# 트라이 (Trie / Prefix Tree) 구현

class TrieNode:
    """트라이의 노드"""
    def __init__(self):
        self.children = {}  # 자식 노드들 (문자: 노드)
        self.is_end_of_word = False  # 단어의 끝인지 표시

class Trie:
    """트라이 자료구조"""
    def __init__(self):
        self.root = TrieNode()
    
    def insert(self, word):
        """단어 삽입 - O(M), M은 단어 길이"""
        node = self.root
        
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        
        node.is_end_of_word = True
    
    def search(self, word):
        """단어 검색 - O(M)"""
        node = self.root
        
        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]
        
        return node.is_end_of_word
    
    def starts_with(self, prefix):
        """접두사로 시작하는지 확인 - O(M)"""
        node = self.root
        
        for char in prefix:
            if char not in node.children:
                return False
            node = node.children[char]
        
        return True
    
    def find_words_with_prefix(self, prefix):
        """접두사로 시작하는 모든 단어 찾기"""
        node = self.root
        
        # 접두사까지 이동
        for char in prefix:
            if char not in node.children:
                return []
            node = node.children[char]
        
        # 나머지 단어들 수집
        words = []
        self._collect_words(node, prefix, words)
        return words
    
    def _collect_words(self, node, current_word, words):
        """재귀적으로 모든 단어 수집"""
        if node.is_end_of_word:
            words.append(current_word)
        
        for char, child_node in node.children.items():
            self._collect_words(child_node, current_word + char, words)
    
    def delete(self, word):
        """단어 삭제"""
        def _delete_recursive(node, word, index):
            if index == len(word):
                if not node.is_end_of_word:
                    return False
                node.is_end_of_word = False
                return len(node.children) == 0
            
            char = word[index]
            if char not in node.children:
                return False
            
            should_delete = _delete_recursive(node.children[char], word, index + 1)
            
            if should_delete:
                del node.children[char]
                return len(node.children) == 0 and not node.is_end_of_word
            
            return False
        
        _delete_recursive(self.root, word, 0)
    
    def display(self, node=None, prefix="", indent=""):
        """트라이 구조 시각화"""
        if node is None:
            node = self.root
            print("트라이 구조:")
        
        if node.is_end_of_word:
            print(f"{indent}'{prefix}' [단어 끝]")
        
        for char, child in sorted(node.children.items()):
            print(f"{indent}├─ {char}")
            self.display(child, prefix + char, indent + "│  ")

# 사용 예제
print("=== 트라이 예제 1: 기본 동작 ===")
trie = Trie()

words = ["cat", "car", "card", "care", "careful", "dog", "dodge", "door"]
print(f"삽입할 단어: {words}\n")

for word in words:
    trie.insert(word)

print("\n단어 검색:")
test_words = ["cat", "car", "can", "care", "careful", "cart"]
for word in test_words:
    result = trie.search(word)
    print(f"  '{word}': {'있음' if result else '없음'}")

print("\n접두사 검색:")
test_prefixes = ["ca", "do", "da"]
for prefix in test_prefixes:
    result = trie.starts_with(prefix)
    print(f"  '{prefix}'로 시작: {'예' if result else '아니오'}")


# 실전 활용: 자동완성
class AutoComplete:
    """트라이를 이용한 자동완성"""
    def __init__(self):
        self.trie = Trie()
    
    def add_word(self, word):
        """단어 추가"""
        self.trie.insert(word.lower())
    
    def get_suggestions(self, prefix):
        """접두사로 시작하는 단어 제안"""
        prefix = prefix.lower()
        suggestions = self.trie.find_words_with_prefix(prefix)
        return suggestions

print("\n\n=== 트라이 예제 2: 자동완성 ===")
ac = AutoComplete()

# 프로그래밍 언어 이름들 추가
languages = [
    "python", "javascript", "java", "julia", 
    "ruby", "rust", "go", "swift", "kotlin", "scala",
    "c", "cpp", "csharp", "php", "perl"
]

for lang in languages:
    ac.add_word(lang)

print("등록된 언어:", ", ".join(sorted(languages)))

# 자동완성 테스트
test_inputs = ["py", "ja", "c", "ru"]
for prefix in test_inputs:
    suggestions = ac.get_suggestions(prefix)
    print(f"\n'{prefix}' 입력 시 추천:")
    for word in suggestions:
        print(f"  - {word}")


# 실전 활용: 연락처 검색
class ContactSearch:
    """트라이를 이용한 연락처 검색"""
    def __init__(self):
        self.trie = Trie()
        self.contacts = {}  # 이름: 전화번호
    
    def add_contact(self, name, phone):
        """연락처 추가"""
        name_lower = name.lower()
        self.trie.insert(name_lower)
        self.contacts[name_lower] = (name, phone)
        print(f"추가: {name} - {phone}")
    
    def search_by_prefix(self, prefix):
        """접두사로 연락처 검색"""
        prefix_lower = prefix.lower()
        matching_names = self.trie.find_words_with_prefix(prefix_lower)
        
        results = []
        for name_lower in matching_names:
            name, phone = self.contacts[name_lower]
            results.append((name, phone))
        
        return results

print("\n\n=== 트라이 예제 3: 연락처 검색 ===")
contacts = ContactSearch()

contacts.add_contact("김철수", "010-1234-5678")
contacts.add_contact("김영희", "010-2345-6789")
contacts.add_contact("김민수", "010-3456-7890")
contacts.add_contact("이철수", "010-4567-8901")
contacts.add_contact("박철수", "010-5678-9012")

print("\n'김'으로 시작하는 연락처:")
results = contacts.search_by_prefix("김")
for name, phone in results:
    print(f"  {name}: {phone}")

print("\n'철수'로 끝나는 연락처 검색 (접두사 검색은 시작 부분만 가능):")
print("  트라이는 접두사 검색에 특화되어 있습니다")


# 실전 활용: 맞춤법 검사기
class SpellChecker:
    """트라이를 이용한 간단한 맞춤법 검사"""
    def __init__(self):
        self.trie = Trie()
    
    def add_to_dictionary(self, words):
        """사전에 단어들 추가"""
        for word in words:
            self.trie.insert(word.lower())
    
    def is_correct(self, word):
        """단어가 사전에 있는지 확인"""
        return self.trie.search(word.lower())
    
    def check_text(self, text):
        """텍스트의 맞춤법 검사"""
        words = text.lower().replace(',', '').replace('.', '').split()
        errors = []
        
        for word in words:
            if not self.is_correct(word):
                errors.append(word)
        
        return errors
    
    def suggest_corrections(self, word):
        """오타에 대한 수정 제안 (간단한 버전)"""
        # 첫 글자만 맞으면 제안
        if len(word) > 0:
            return self.trie.find_words_with_prefix(word[0].lower())
        return []

print("\n\n=== 트라이 예제 4: 맞춤법 검사 ===")
checker = SpellChecker()

dictionary = [
    "the", "quick", "brown", "fox", "jumps", "over", 
    "lazy", "dog", "hello", "world", "python", "is", "great"
]
checker.add_to_dictionary(dictionary)

print(f"사전: {dictionary}\n")

test_text = "The quik brown fox jumps over the lazi dog"
print(f"검사할 문장: {test_text}")

errors = checker.check_text(test_text)
if errors:
    print(f"\n오타 발견: {errors}")
    for error in errors:
        suggestions = checker.suggest_corrections(error)
        if suggestions:
            print(f"  '{error}' 수정 제안: {suggestions[:3]}")
else:
    print("오타가 없습니다!")


# 실전 활용: URL 라우팅
class URLRouter:
    """트라이를 이용한 URL 라우팅"""
    def __init__(self):
        self.trie = Trie()
        self.handlers = {}
    
    def add_route(self, path, handler):
        """라우트 추가"""
        self.trie.insert(path)
        self.handlers[path] = handler
        print(f"라우트 추가: {path} -> {handler}")
    
    def match(self, path):
        """경로와 일치하는 핸들러 찾기"""
        if self.trie.search(path):
            return self.handlers.get(path)
        return None
    
    def list_routes_with_prefix(self, prefix):
        """특정 접두사로 시작하는 모든 라우트"""
        return self.trie.find_words_with_prefix(prefix)

print("\n\n=== 트라이 예제 5: URL 라우팅 ===")
router = URLRouter()

router.add_route("/home", "HomeHandler")
router.add_route("/home/about", "AboutHandler")
router.add_route("/home/contact", "ContactHandler")
router.add_route("/api/users", "UsersAPIHandler")
router.add_route("/api/posts", "PostsAPIHandler")

print("\n'/home' 관련 라우트:")
home_routes = router.list_routes_with_prefix("/home")
for route in home_routes:
    handler = router.match(route)
    print(f"  {route} -> {handler}")

print("\n'/api' 관련 라우트:")
api_routes = router.list_routes_with_prefix("/api")
for route in api_routes:
    handler = router.match(route)
    print(f"  {route} -> {handler}")


# 성능 비교
print("\n\n=== 트라이 vs 리스트 성능 비교 ===")
import time

# 많은 단어 준비
large_word_list = [f"word{i}" for i in range(1000)]

# 트라이에 삽입
trie_test = Trie()
start = time.time()
for word in large_word_list:
    trie_test.insert(word)
trie_insert_time = time.time() - start

# 트라이에서 검색
start = time.time()
for i in range(100):
    trie_test.search(f"word{i}")
trie_search_time = time.time() - start

# 리스트에서 검색 (비교용)
start = time.time()
for i in range(100):
    f"word{i}" in large_word_list
list_search_time = time.time() - start

print(f"1000개 단어 삽입:")
print(f"  트라이: {trie_insert_time:.6f}초")

print(f"\n100개 단어 검색:")
print(f"  트라이: {trie_search_time:.6f}초")
print(f"  리스트: {list_search_time:.6f}초")
print(f"  속도 차이: {list_search_time/trie_search_time:.2f}배")

print("\n트라이는 문자열 검색과 자동완성에 매우 효율적입니다!")
```

## 8. 그래프 (Graph)

### 8.1 개념 설명
그래프는 **노드(정점)**와 **간선(엣지)**으로 이루어진 자료 구조입니다. 소셜 네트워크, 지도, 웹 페이지 링크 등 실생활의 많은 관계를 표현할 수 있습니다.

**종류**:
- **방향 그래프**: 간선에 방향이 있음 (A → B)
- **무방향 그래프**: 간선에 방향이 없음 (A ↔ B)
- **가중치 그래프**: 간선에 비용/거리가 있음

**표현 방법**:
- **인접 리스트**: 각 노드의 이웃을 리스트로 저장 (메모리 효율적)
- **인접 행렬**: 2차원 배열로 연결 관계 저장

### 8.2 샘플 코드

```python
# 그래프 (Graph) 구현

from collections import deque, defaultdict

class Graph:
    """무방향 그래프 (인접 리스트 방식)"""
    def __init__(self):
        self.graph = defaultdict(set)  # 노드: {이웃 노드들}
    
    def add_edge(self, node1, node2):
        """간선 추가 (양방향)"""
        self.graph[node1].add(node2)
        self.graph[node2].add(node1)
    
    def add_node(self, node):
        """노드 추가"""
        if node not in self.graph:
            self.graph[node] = set()
    
    def get_neighbors(self, node):
        """이웃 노드들 반환"""
        return self.graph.get(node, set())
    
    def has_edge(self, node1, node2):
        """간선 존재 여부"""
        return node2 in self.graph.get(node1, set())
    
    def display(self):
        """그래프 구조 출력"""
        print("\n그래프 구조:")
        for node in sorted(self.graph.keys()):
            neighbors = sorted(self.graph[node])
            print(f"  {node} -> {neighbors}")
    
    # 너비 우선 탐색 (BFS)
    def bfs(self, start_node):
        """BFS - 큐를 사용한 레벨별 탐색"""
        if start_node not in self.graph:
            return []
        
        visited = set()
        queue = deque([start_node])
        visited.add(start_node)
        result = []
        
        while queue:
            node = queue.popleft()  # FIFO
            result.append(node)
            
            # 이웃 노드들을 큐에 추가
            for neighbor in sorted(self.graph[node]):
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append(neighbor)
        
        return result
    
    # 깊이 우선 탐색 (DFS) - 재귀
    def dfs_recursive(self, start_node, visited=None):
        """DFS - 재귀 버전"""
        if visited is None:
            visited = set()
        
        if start_node not in self.graph:
            return []
        
        visited.add(start_node)
        result = [start_node]
        
        for neighbor in sorted(self.graph[start_node]):
            if neighbor not in visited:
                result.extend(self.dfs_recursive(neighbor, visited))
        
        return result
    
    # 깊이 우선 탐색 (DFS) - 반복
    def dfs_iterative(self, start_node):
        """DFS - 스택을 사용한 반복 버전"""
        if start_node not in self.graph:
            return []
        
        visited = set()
        stack = [start_node]  # LIFO
        result = []
        
        while stack:
            node = stack.pop()  # 스택에서 꺼냄
            
            if node not in visited:
                visited.add(node)
                result.append(node)
                
                # 이웃 노드들을 스택에 추가 (역순으로)
                for neighbor in sorted(self.graph[node], reverse=True):
                    if neighbor not in visited:
                        stack.append(neighbor)
        
        return result
    
    # 경로 찾기
    def find_path(self, start, end):
        """BFS를 이용한 최단 경로 찾기"""
        if start not in self.graph or end not in self.graph:
            return None
        
        visited = {start}
        queue = deque([(start, [start])])  # (현재 노드, 경로)
        
        while queue:
            node, path = queue.popleft()
            
            if node == end:
                return path
            
            for neighbor in self.graph[node]:
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append((neighbor, path + [neighbor]))
        
        return None  # 경로 없음

# 사용 예제
print("=== 그래프 예제 1: 기본 구조 ===")
g = Graph()

# 소셜 네트워크 예제
edges = [
    ("Alice", "Bob"),
    ("Alice", "Charlie"),
    ("Bob", "David"),
    ("Charlie", "David"),
    ("Charlie", "Eve"),
    ("David", "Eve")
]

for node1, node2 in edges:
    g.add_edge(node1, node2)

g.display()

print("\nAlice의 친구들:", sorted(g.get_neighbors("Alice")))
print("Alice와 Bob은 친구인가요?", g.has_edge("Alice", "Bob"))
print("Alice와 Eve는 친구인가요?", g.has_edge("Alice", "Eve"))


# BFS vs DFS 비교
print("\n\n=== 그래프 예제 2: BFS vs DFS ===")
g2 = Graph()

# 간단한 그래프 생성
#     A
#    / \
#   B   C
#  / \   \
# D   E   F

connections = [
    ("A", "B"), ("A", "C"),
    ("B", "D"), ("B", "E"),
    ("C", "F")
]

for n1, n2 in connections:
    g2.add_edge(n1, n2)

g2.display()

print("\nBFS (너비 우선 탐색) - A부터:")
print("  방문 순서:", g2.bfs("A"))
print("  설명: 레벨별로 탐색 (가까운 것부터)")

print("\nDFS (깊이 우선 탐색) - A부터:")
print("  방문 순서 (재귀):", g2.dfs_recursive("A"))
print("  방문 순서 (반복):", g2.dfs_iterative("A"))
print("  설명: 깊이 우선으로 탐색 (끝까지 간 후 돌아옴)")


# 실전 활용: 최단 경로
print("\n\n=== 그래프 예제 3: 최단 경로 찾기 ===")
path = g.find_path("Alice", "Eve")
if path:
    print(f"Alice에서 Eve까지 최단 경로:")
    print(f"  {' -> '.join(path)}")
    print(f"  거리: {len(path) - 1}단계")


# 방향 그래프
class DirectedGraph:
    """방향 그래프"""
    def __init__(self):
        self.graph = defaultdict(set)
    
    def add_edge(self, from_node, to_node):
        """방향 간선 추가 (from -> to)"""
        self.graph[from_node].add(to_node)
    
    def display(self):
        """그래프 출력"""
        print("\n방향 그래프:")
        for node in sorted(self.graph.keys()):
            neighbors = sorted(self.graph[node])
            print(f"  {node} → {neighbors}")
    
    def has_cycle(self):
        """사이클 존재 여부 (DFS 이용)"""
        visited = set()
        rec_stack = set()  # 재귀 스택
        
        def dfs(node):
            visited.add(node)
            rec_stack.add(node)
            
            for neighbor in self.graph.get(node, set()):
                if neighbor not in visited:
                    if dfs(neighbor):
                        return True
                elif neighbor in rec_stack:
                    return True
            
            rec_stack.remove(node)
            return False
        
        for node in self.graph:
            if node not in visited:
                if dfs(node):
                    return True
        
        return False

print("\n\n=== 그래프 예제 4: 방향 그래프 ===")
dg = DirectedGraph()

# 작업 의존성 그래프
dg.add_edge("설계", "개발")
dg.add_edge("개발", "테스트")
dg.add_edge("테스트", "배포")
dg.add_edge("설계", "문서화")

dg.display()

print(f"\n사이클 존재? {dg.has_cycle()}")

# 사이클 있는 그래프
dg2 = DirectedGraph()
dg2.add_edge("A", "B")
dg2.add_edge("B", "C")
dg2.add_edge("C", "A")  # 사이클!

print("\n사이클이 있는 그래프:")
dg2.display()
print(f"사이클 존재? {dg2.has_cycle()}")


# 가중치 그래프
class WeightedGraph:
    """가중치 그래프 (무방향)"""
    def __init__(self):
        self.graph = defaultdict(dict)  # 노드: {이웃: 가중치}
    
    def add_edge(self, node1, node2, weight):
        """가중치 간선 추가"""
        self.graph[node1][node2] = weight
        self.graph[node2][node1] = weight
    
    def display(self):
        """그래프 출력"""
        print("\n가중치 그래프:")
        for node in sorted(self.graph.keys()):
            edges = [(n, w) for n, w in self.graph[node].items()]
            print(f"  {node}: {edges}")
    
    def dijkstra(self, start):
        """다익스트라 알고리즘 - 최단 거리"""
        distances = {node: float('inf') for node in self.graph}
        distances[start] = 0
        visited = set()
        
        while len(visited) < len(self.graph):
            # 미방문 노드 중 최소 거리 노드 선택
            current = None
            min_dist = float('inf')
            
            for node in self.graph:
                if node not in visited and distances[node] < min_dist:
                    current = node
                    min_dist = distances[node]
            
            if current is None:
                break
            
            visited.add(current)
            
            # 이웃 노드들의 거리 업데이트
            for neighbor, weight in self.graph[current].items():
                distance = distances[current] + weight
                if distance < distances[neighbor]:
                    distances[neighbor] = distance
        
        return distances

print("\n\n=== 그래프 예제 5: 가중치 그래프와 최단 경로 ===")
wg = WeightedGraph()

# 도시 간 거리 그래프
wg.add_edge("서울", "대전", 150)
wg.add_edge("서울", "강릉", 165)
wg.add_edge("대전", "대구", 120)
wg.add_edge("대전", "광주", 170)
wg.add_edge("대구", "부산", 90)
wg.add_edge("광주", "부산", 180)

wg.display()

print("\n서울에서 각 도시까지의 최단 거리:")
distances = wg.dijkstra("서울")
for city, dist in sorted(distances.items()):
    if dist == float('inf'):
        print(f"  {city}: 도달 불가")
    else:
        print(f"  {city}: {dist}km")


# 실전 활용: 친구 추천
class SocialNetwork:
    """그래프를 이용한 소셜 네트워크"""
    def __init__(self):
        self.graph = Graph()
    
    def add_friendship(self, person1, person2):
        """친구 관계 추가"""
        self.graph.add_edge(person1, person2)
    
    def suggest_friends(self, person):
        """친구 추천 (친구의 친구)"""
        if person not in self.graph.graph:
            return []
        
        direct_friends = self.graph.get_neighbors(person)
        suggestions = set()
        
        # 친구의 친구들 찾기
        for friend in direct_friends:
            friends_of_friend = self.graph.get_neighbors(friend)
            suggestions.update(friends_of_friend)
        
        # 본인과 이미 친구인 사람 제외
        suggestions.discard(person)
        suggestions -= direct_friends
        
        return sorted(suggestions)
    
    def common_friends(self, person1, person2):
        """공통 친구 찾기"""
        friends1 = self.graph.get_neighbors(person1)
        friends2 = self.graph.get_neighbors(person2)
        return sorted(friends1 & friends2)

print("\n\n=== 그래프 예제 6: 친구 추천 시스템 ===")
sn = SocialNetwork()

friendships = [
    ("Alice", "Bob"), ("Alice", "Charlie"),
    ("Bob", "David"), ("Bob", "Eve"),
    ("Charlie", "Frank"), ("David", "Grace"),
    ("Eve", "Grace")
]

for p1, p2 in friendships:
    sn.add_friendship(p1, p2)

print("\nAlice의 친구 추천:")
suggestions = sn.suggest_friends("Alice")
print(f"  {suggestions}")
print("  (친구의 친구이지만 아직 친구가 아닌 사람)")

print("\nBob와 Charlie의 공통 친구:")
common = sn.common_friends("Bob", "Charlie")
print(f"  {common}")

print("\n그래프는 관계를 표현하는 강력한 자료 구조입니다!")
```

## 9. 최종 정리

1. **연결 리스트** - 단일/이중 연결 리스트 구현과 활용
2. **스택** - LIFO 원칙, 괄호 검사, 브라우저 히스토리 등
3. **큐** - FIFO 원칙, 프린터 대기열, 고객 서비스 등
4. **해시맵** - 딕셔너리 구현, 충돌 처리, 실전 활용
5. **이진 검색 트리** - BST 구조, 순회 방법, 균형의 중요성
6. **힙** - Min/Max Heap, 우선순위 큐, 실시간 중간값
7. **트라이** - 문자열 검색, 자동완성, 맞춤법 검사
8. **그래프** - BFS/DFS, 최단 경로, 소셜 네트워크
