---
title: 15차시 2:n8n (Advanced Course)
layout: single
classes: wide
categories:
  - n8n
toc: true # 이 포스트에서 목차를 활성화
toc_sticky: true # 목차를 고정할지 여부 (선택 사항)
---

![advanced_n8n](/assets/images/advanced_n8n.png)

## **1. Node Execution Order**
### **1.1 Node Execution Order**
- **노드 실행 순서**:  
  - 기본적으로 노드는 **왼쪽에서 오른쪽**, **위에서 아래** 순으로 실행됩니다.  
  - 연결된 화살표를 따라 데이터가 흐르며, 각 노드는 이전 노드의 출력을 입력으로 받습니다.  

### **1.2 Splitting Data (데이터 분기)**
- 데이터를 조건에 따라 여러 경로로 나누는 방법입니다.  
  - 주요 유형:  
    - **If**: 특정 조건을 만족하는 경우와 아닌 경우로 데이터를 분기합니다.  
      - 예: 점수가 80 이상이면 "합격", 그렇지 않으면 "불합격".  
    - **Switch**: 여러 조건에 따라 다양한 경로로 데이터를 분기합니다.  
      - 예: 국가별로 데이터를 다른 워크플로우로 전송.  

### **1.3 Merging Data (데이터 병합)**
- 여러 경로로 나뉘어진 데이터를 하나로 합치는 방법입니다.  
  - 주요 유형:  
    - **Append**: 여러 데이터 세트를 단순히 추가(붙여넣기)합니다.  
      - 예: 두 개의 리스트를 하나의 긴 리스트로 결합.  
    - **Combine**: 데이터를 특정 규칙에 따라 통합합니다.  
      - 예: 두 개의 JSON 객체를 하나로 합침.  
    - **Choose**: 여러 경로 중 하나의 결과를 선택하여 사용합니다.  
      - 예: 여러 조건 중 가장 적합한 결과를 선택.  

### **1.4 Loop Over Items (아이템 반복 처리)**
- **Loop**는 여러 개의 데이터 항목(items)을 하나씩 처리하는 방식입니다.  
  - n8n은 기본적으로 각 아이템마다 노드를 실행합니다.  
    - 예: 10개의 이름이 있는 리스트가 있다면, 각 이름에 대해 동일한 작업을 수행.  
  - **용도**:  
    - 데이터베이스의 모든 행을 처리하거나, 파일 목록을 하나씩 다운로드.  

## **2. Advanced Technical Nodes**

### **2.1 Expressions**
- **Expressions**는 n8n에서 데이터를 동적으로 참조하거나 처리하는 데 사용됩니다.  
  - **Built-in Functions**: 특정 작업을 수행하기 위한 내장 함수입니다.  

- 주요 Built-in Functions:
  - **`isEmpty()`**: 값이 비어있는지 확인합니다.  
    - 예: `{%raw%}{{ isEmpty($json.name) }}{%endraw%}` → 이름 필드가 비어있으면 `true`.  
  - **`extractDomain()`**: 이메일이나 URL에서 도메인을 추출합니다.  
    - 예: `{%raw%}{{ extractDomain("alice@example.com") }}{%endraw%}` → `"example.com"`.  
  - **`hasField()`**: 특정 필드가 존재하는지 확인합니다.  
    - 예: `{%raw%}{{ hasField($json, "email") }}{%endraw%}` → `email` 필드가 있으면 `true`.  
  - **`removeDuplicates()`**: 리스트에서 중복된 항목을 제거합니다.  
    - 예: `{%raw%}{{ removeDuplicates([1, 2, 2, 3]) }}{%endraw%}` → `[1, 2, 3]`.  
  - **`difference()`**: 두 리스트의 차이를 계산합니다.  
    - 예: `{%raw%}{{ difference([1, 2, 3], [2, 3, 4]) }}{%endraw%}` → `[1]`.

### **2.2 Luxon**
- **Luxon**은 날짜와 시간을 다루기 위한 라이브러리로, n8n에서 기본적으로 제공됩니다.  

- 주요 Luxon 표현식:
  - **`{%raw%}{{ $now }}{%endraw%}`**: 현재 날짜와 시간을 반환합니다.  
    - 예: `{%raw%}{{ $now }}{%endraw%}` → `2023-10-01T12:34:56Z`.  
  - **`{%raw%}{{ $now.toString() }}{%endraw%}`**: 현재 날짜와 시간을 문자열로 반환.  
  - **`{%raw%}{{ $now.plus({ days: 1 }) }}{%endraw%}`**  
    - 하루 후 날짜 계산
  - **`{%raw%}{{ $now.toFormat("yyyy-MM-dd") }}{%endraw%}`**  
    - "2023-10-06" 형식으로 
  - **`{%raw%}{{ $today }}{%endraw%}`**: 오늘 날짜를 반환합니다 (시간 정보 없음).  
    - 예: `{%raw%}{{ $today }}{%endraw%}` → `2023-10-01`.

### **2.3 Code Node**
- **Code Node**는 JavaScript 코드를 작성하여 커스텀 로직을 추가할 수 있는 노드입니다.  

- **주요 기능**:
  - **Built-in Variables**:  
    - **`$input.all()`**: 모든 입력 데이터를 배열로 가져옵니다.  
      - 예: `$input.all()` → `[ { "name": "Alice" }, { "name": "Bob" } ]`.  
    - **`$json`**: 현재 데이터 항목(item)을 참조합니다.  
      - 예: `$json.name` → `"Alice"`.  

- **2 Modes**:  
  - **Run Once for All Items**: 모든 데이터를 하나의 묶음으로 처리.노드 한번 실행
  - **Run Once for Each Item**: 각 데이터 항목마다 개별적으로 실행됩니다. 노드가 항목수 만큼 반복

### **2.4 HTTP Request Node**
- **HTTP Request Node**는 외부 API와 통신하거나 웹 페이지에서 데이터를 가져오는 데 사용됩니다.  

- 주요 기능:
  - **HTTP Request**:  
    - GET, POST, PUT, DELETE 등의 메서드를 사용하여 요청을 보냅니다.  
    - GET: `https://jsonplaceholder.typicode.com/posts/1`로 GET 요청. 
    - POST: https://jsonplaceholder.typicode.com/posts 
      - body는 json으로
      ```json
      {
        "title": "foo",
        "body": "bar",
        "userId": 1
      }
      ```
    - 테스트 사이트이므로 실제로 값이 추가되진 않고, 요청에 대해 단순히 시뮬레이션만 보여준다.
      - 가짜 응답
      ```
      {
        "id": 101,
        "title": "foo",
        "body": "bar",
        "userId": 1
      }
      ```
  - **Advanced Options**:  
    - 헤더(Header), 본문(Body), 쿼리 파라미터(Query Parameters) 등을 설정할 수 있습니다.  

  - **Using Credentials**:  
    - API 키나 인증 정보를 안전하게 저장하고 사용할 수 있습니다.  

  - **cURL Import**:  
    - cURL 명령어를 복사하여 쉽게 HTTP 요청을 구성할 수 있습니다.  
    - 예: `curl -X GET https://jsonplaceholder.typicode.com/posts`를 붙여넣기.


## **3. Pin Data + Edit Output**  

### **3.1 Pinning Data**  
- What is pinning data?**  
  - **Pin Data**는 특정 노드에서 생성된 데이터를 "고정"하여 저장하는 기능입니다.  
  - 이 기능을 사용하면 워크플로우를 테스트하거나 디버깅할 때, 매번 전체 프로세스를 실행하지 않고도 고정된 데이터를 기반으로 작업할 수 있습니다.  
  - 예: API 호출 결과나 특정 연산 결과를 고정해두고, 이후 단계의 노드들을 독립적으로 테스트.  

### **3.2 Edit Output**  
- **Editing output + Pinned data**  
  - **Edit Output**은 노드의 출력 데이터를 직접 수정할 수 있는 기능입니다.  
  - Pinning된 데이터를 기반으로 수정하거나, 새로운 데이터를 추가/삭제하여 원하는 형식으로 조정
  - 이를 통해 실시간으로 데이터를 커스터마이징하며 테스트할 수 있습니다.  

- **이전 실행에서 생성된 데이터를 복사**  
  - 이전 실행에서 생성된 데이터를 복사하여 현재 워크플로우에서 재사용할 수 있습니다.  
  - 이는 과거 데이터를 기반으로 테스트하거나, 실제 환경과 유사한 데이터를 활용할 때 유용합니다.  

- **mock data 생성**  
  - n8n에서는 테스트를 위해 **가짜 데이터(Mock Data)**를 생성할 수 있습니다.  
  - Mock Data는 실제 데이터가 없거나 외부 API 호출이 불가능할 때 유용합니다.  
    - 생성형 AI를 통해 가상의 데이터를 만들수 있다.


## **4. Subworkflows**  
### **4.1 Subworkflows란?**  
- **Subworkflows**는 하나의 큰 워크플로우를 작은 단위로 나눈 하위 워크플로우입니다.  
- 각각의 Subworkflow는 독립적으로 실행되며, 필요할 때 메인 워크플로우에서 호출하여 사용.  
- 이를 통해 복잡한 작업을 관리하기 쉽게 쪼갤 수 있습니다.  

### **4.2 Subworkflows를 사용하는 이유**  

- **Reduce Workload (작업 부담 감소)**  
  - 워크플로우가 커질수록 코드와 로직이 복잡해지는데, Subworkflows를 사용하면 각 부분을 독립적으로 설계하고 테스트할 수 있어 관리 부담이 줄어듭니다.  

- **Improve Scalability (확장성 개선)**  
  - Subworkflows는 재사용이 가능하므로, 유사한 작업이 반복될 때마다 동일한 Subworkflow를 호출
  - 새로운 요구사항이 생길 때도 기존 Subworkflow를 수정하거나 확장하여 쉽게 대응할 수 있습니다.  

### **4.3 Subworkflows 구성 및 활용법**  
- **구성 방법**:  
  1. 메인 워크플로우에서 특정 작업을 독립적인 Subworkflow로 분리합니다.  
  2. Subworkflow는 자체적으로 입력값을 받아 처리하고, 결과값을 반환합니다.  
  3. 메인 워크플로우에서는 "Execute Workflow" 노드를 사용하여 Subworkflow를 호출합니다.  

- **활용 예시**:  
  - API 호출, 데이터 변환, 파일 처리 등 반복적으로 사용되는 작업을 Subworkflow로 만들어 두고 필요할 때마다 호출.  
  - 여러 워크플로우에서 동일한 작업을 수행시, 하나의 Subworkflow를 공유하여 일관성을 유지.  


## **5. Error Workflow**  
### **5.1 Error Trigger Node**  
- **Error Trigger Node**는 n8n 워크플로우에서 오류가 발생했을 때 자동으로 실행되는 특별한 트리거
- 이를 통해 워크플로우 내에서 발생한 문제를 감지하고, 적절한 조치를 취할 수 있습니다.  

### **5.2 주요 기능**  
- **오류 감지**:  
  - 워크플로우 실행 중 노드에서 오류가 발생하면 이 트리거가 활성화됩니다.  
  - 예: API 호출 실패, 데이터 형식 불일치, 외부 서비스 연결 문제 등.  

- **오류 정보 제공**:  
  - 오류와 관련된 상세 정보(예: 오류 메시지, 발생 위치, 입력 데이터)를 출력합니다.  
  - 이를 활용해 문제를 분석하거나 후속 작업을 수행할 수 있습니다.  

- **자동화된 대응**:  
  - 오류 발생 시 알림 발송, 로그 기록, 재시도 등의 후속 작업을 자동으로 수행하도록 설정 가능.  

### **5.3 사용 예시**  
- **이메일 알림**: 오류가 발생하면 관리자에게 이메일로 알림을 보냅니다.  
- **로그 저장**: 오류 정보를 데이터베이스나 파일에 저장하여 추후 분석에 활용합니다.  
- **재처리**: 특정 조건에서 오류가 발생한 작업을 자동으로 재시도합니다.  

## **6. Build a full example**  


## **7. Handling files**  
### **7.1 Binary Output**  
- **Binary Output란?**  
  - **Binary Output**은 파일 데이터를 처리할 때 사용되는 형식입니다.  
  - 텍스트 데이터와 달리, 이미지, PDF, 엑셀 파일 등 **비텍스트 데이터**를 포함한 파일을 다룰 때 활용

- **핵심 개념**  
  - **Binary Data**: 파일의 내용이 바이너리 형식으로 저장되어 워크플로우에서 전달됩니다.  
  - **주요 특징**:  
    - 파일의 원본 데이터를 유지하며 처리 가능.  
    - 다양한 노드에서 바이너리 데이터를 생성, 변환, 저장할 수 있습니다.  

- **주요 Nodes**  
  1. **HTTP Request Node**  
    - 외부 URL에서 파일을 다운로드하거나 API를 통해 바이너리 데이터를 가져옴.
    - 예: 이미지 파일, PDF 문서 등을 다운로드하여 워크플로우에서 사용.  

  2. **Read File Node**  
    - 로컬 시스템 또는 클라우드 스토리지에서 파일을 읽어옵니다.  
    - 예: CSV, JSON, 이미지 파일 등을 워크플로우에 로드.  

  3. **Write File Node**  
    - 워크플로우에서 처리된 바이너리 데이터를 파일로 저장합니다.  
    - 예: 변환된 이미지나 PDF를 특정 경로에 저장.  

  4. **Google Drive Node**  
    - Google Drive에 파일을 업로드하거나 다운로드할 수 있습니다.  
    - 예: 자동화된 보고서 파일을 Google Drive에 저장.  

  5. **Email Node (Gmail, Outlook 등)**  
    - 이메일에 첨부된 파일을 다운로드하거나, 새로운 이메일에 파일을 첨부하여 발송

### **7.2 실제 예제**

![file 처리 예제](/assets/images/file_handling.png)

- **1. On clicking 'execute'**  
  - **역할**: 워크플로우를 수동으로 실행하기 위한 트리거입니다.  
  - **설명**: 사용자가 "execute" 버튼을 클릭하면 이 노드가 트리거되어 워크플로우가 시작

- **2. Download Example Data**  
  - **노드 유형**: HTTP Request Node  
  - **역할**: 외부 URL에서 예시 데이터를 다운로드합니다.  
  - **설명**: GET 요청을 통해 지정된 URL(예: `https://static.thomasma...`)에서 파일을 가져옴
  - **출력**: 다운로드한 파일 데이터를 다음 노드로 전달합니다.  

- **3. Decompress Example Data**  
  - **노드 유형**: Compress/Decompress Node  
  - **역할**: 압축된 파일을 압축 해제합니다.  
  - **설명**: 다운로드한 파일이 압축 파일인 경우(예: ZIP, TAR 등), 이를 압축 해제하여 원본 파일로 변환
  - **출력**: 압축 해제된 파일 데이터를 다음 노드로 전달합니다.  

- **4. Split Up Binary Data**  
  - **노드 유형**: Code Node  
  - **역할**: 바이너리 데이터를 개별 항목으로 분할합니다.  
  - **설명**: 압축 해제된 파일 데이터를 처리하여 각 항목에 대해 단일 바이너리 객체(`data` 키 아래)로 구분
  - **출력**: 분할된 데이터를 다음 단계로 전달합니다.  


## **8. Enterprise Feature(기업용 플랜)**  
### **8.1 User Management**  
- **핵심 개념**: 조직 내 사용자 권한을 관리하여 워크플로우와 데이터에 대한 접근을 제어
- **주요 역할**  
  - **Owner**:  
    - 전체 시스템에 대한 최고 권한 보유.  
    - 사용자 추가/삭제, 권한 설정, 환경 구성 등 관리 작업 수행.  
  - **Member**:  
    - 특정 워크플로우 또는 데이터에 대한 접근 권한을 가진 사용자.  
    - 팀 내에서 협업하며 워크플로우를 개발하거나 실행할 수 있음.  
  - **User**:  
    - 제한된 권한으로 워크플로우를 실행하거나 결과를 확인하는 역할.  
    - 주로 운영 담당자나 비기술적 사용자가 해당됨.  

### **8.2 Saving Execution Data**  
- **핵심 개념**: 워크플로우 실행 기록을 저장하여 추후 분석하거나 디버깅에 활용합니다.  
- **활용 예시**:  
  - 실행 실패 시 오류 원인 파악.  
  - 과거 실행 데이터를 기반으로 성능 개선.  


### **8.3 Environments**  
- **핵심 개념**: 다양한 환경(개발, 테스트, 프로덕션)을 설정하고 관리합니다.  
  - 기본 목적 : 개발/테스트/프로덕션 환경 설정 관리.
  - Git과의 연관성 : Git 브랜치 전략, CI/CD 파이프라인, 환경별 변수 관리 등에서 활용
- **활용 예시**:  
  - 각 환경에 맞는 설정(예: API 키, 데이터베이스 연결 정보)을 적용.  
  - 워크플로우를 안전하게 테스트 후 프로덕션으로 배포.  

### **8.4 Variables**  
- **핵심 개념**: 워크플로우에서 재사용 가능한 변수를 정의하고 관리합니다.  
- **활용 예시**:  
  - API 키, URL, 공통 설정값 등을 변수로 저장.  
  - 변경이 필요할 때 한 번만 수정하여 모든 워크플로우에 반영.  


### **8.5 External Secrets Store**  
- **핵심 개념**: 중요한 민감 정보(예: 암호, 인증서)를 외부 보안 저장소에서 관리합니다.  
- **활용 예시**:  
  - AWS Secrets Manager, HashiCorp Vault 등과 연동.  
  - 민감 정보 노출 위험을 줄이고 보안 강화.  


### **8.6 Log Streaming**  
- **핵심 개념**: 워크플로우 실행 로그를 실시간으로 외부 시스템으로 전송합니다.  
- **활용 예시**:  
  - 로그를 모니터링 도구(예: Datadog, Splunk)로 전달하여 실시간 분석.  
  - 문제 발생 시 빠른 대응 가능.  


