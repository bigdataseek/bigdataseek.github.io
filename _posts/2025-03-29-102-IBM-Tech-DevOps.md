---
title: 21차시 2:IBM TECH(DevOps)
layout: single
classes: wide
categories:
  - DevOps
toc: true # 이 포스트에서 목차를 활성화
toc_sticky: true # 목차를 고정할지 여부 (선택 사항)
---

## 11. 지속적 테스팅 (Continuous Testing)
- 출처: [What is Continuous Testing?](https://www.youtube.com/watch?v=RYQbmjLgubM&list=PLOspHqNVtKAAm1dmyiR9WMmw1UBoOwZVj&index=11)


### **11.1 지속적 테스팅의 중요성**  

*   개발 과정에서 변경 사항이 발생할 때마다 신속한 피드백을 제공하여 문제를 조기에 발견하고 대응
*   코드 품질을 지속적으로 유지하고, 배포 전후 발생할 수 있는 오류를 최소화  
*   DevOps의 핵심 원칙인 지속적 통합(Continuous Integration) 및 지속적 배포(Continuous Deployment)를 지원하여 빠르고 안정적인 소프트웨어 출시 가능  

### **11.2 흔한 실수 (잘못된 접근 방식)**  

*   **UI 레벨 자동화 테스트에 과도하게 집중**  
    *   기능 테스트 자동화를 위해 스크립트 기반 테스트 또는 기록/재생 방식의 테스트 활용  
    *   UI 레벨에서 광범위한 테스트 수행으로 인해 테스트 속도 저하  
    *   반면 API 테스트 및 유닛 테스트는 상대적으로 부족하여 내부 로직 검증이 미흡함  
*   **결과**  
    *   UI가 변경될 때마다 테스트 실패가 빈번하게 발생하여 유지보수 부담 증가  
    *   테스트 실행 시간이 길어지면서 개발 주기의 속도를 저하시킴  
    *   비즈니스 요구사항 변화에 대한 대응력이 떨어져 DevOps의 목표에 역행  

### **11.3 올바른 접근 방식**  

*   **테스팅 피라미드의 올바른 구성**  
    *   **유닛 테스트 (Bulk, 기초 레이어)**  
        *   코드의 개별 모듈을 검증하는 테스트로, 90~100%의 코드 커버리지를 목표로 설정  
        *   빠르게 실행되며 코드 변경이 미치는 영향을 신속하게 파악할 수 있음  
    *   **API 테스트 (Key, 중간 레이어)**  
        *   애플리케이션의 핵심 비즈니스 로직을 검증하며, 서비스 간의 데이터 흐름을 확인  
        *   마이크로서비스 기반 시스템에서 API 호환성을 유지하고 안정성을 확보하는 데 필수적  
    *   **UI 테스트 (Less, 최상위 레이어)**  
        *   최종 사용자의 실제 사용 시나리오를 검증하는 end-to-end 테스트에 집중  
        *   UI 변화에 민감하므로 최소한으로 유지하고, 주요 사용자 흐름에 초점을 맞춤  
*   **사람의 역할 강화**  
    *   **탐색적 테스트 (Exploratory Testing)**  
        *   자동화되지 않은 테스트 방식으로, 숙련된 테스터가 소프트웨어를 직접 사용하며 예상치 못한 결함을 발견  
    *   **베타 테스트 (Beta Testing)**  
        *   실제 사용자 환경에서 소프트웨어를 테스트하여 UX 개선 및 실사용자의 피드백을 반영  

### **11.4 핵심 제안**  

*   테스트 자동화 전략을 수립할 때, 유닛 테스트 및 API 테스트를 최우선으로 고려  
*   UI 테스트는 핵심 사용자 흐름을 검증하는 end-to-end 테스트에만 제한적으로 적용  
*   UI에서 수행하던 테스트를 API 레벨에서 검증할 수 있는지 먼저 검토하여 테스트 효율성 향상  

## 12. Value Stream Management (VSM)
- 출처: [What is Value Stream Management?](https://www.youtube.com/watch?v=Yto8nUeki-s&list=PLOspHqNVtKAAm1dmyiR9WMmw1UBoOwZVj&index=12)


### 12.1 VSM이란?
* 소프트웨어 개발에서 아이디어 발상부터 고객 전달까지 전체 과정을 **통합적으로 관리**하여 최적화하는 방법론입니다. 이는 개발 생명주기의 모든 단계를 연결하여 가치 창출의 흐름을 끊김 없이 관리하는 접근법
* 개발, 테스트, 분석 등 각 그룹을 개별적으로 관리하는 것이 아니라, **전체 흐름을 최적화**하는 데 초점을 맞춥니다. 이를 통해 조직 간 사일로를 없애고 협업을 강화하여 전체 프로세스의 효율성을 높입니다.

### 12.2 VSM의 필요성
* 소프트웨어 개발 프로세스에서 병목 지점을 파악하고 개선함으로써 지연 요소를 제거하고 리소스 활용을 최적화할 수 있습니다.
* 전체적인 개발 속도를 향상시키고 고객 가치 전달을 극대화하여 시장 대응력을 높이고 경쟁 우위를 확보할 수 있습니다. 또한 낭비 요소를 제거하여 비용 효율성도 높일 수 있습니다.

### 12.3 VSM 적용 예시
* **단계:** 아이디어 > 우선순위 결정 > 개발 > 빌드 > 테스트 > 코드 리뷰 (추가)
* **문제점:** 테스트 단계에서 작업이 많이 쌓이고, 코드 리뷰 단계에서 지연이 발생하여 전체 가치 전달 흐름이 지연됩니다.
* **개선:**
  * 모든 개발자가 코드 리뷰에 참여하도록 변경하여 코드 리뷰 시간을 대폭 단축 (1주일 → 1일)했습니다. 이는 리뷰 병렬화를 통해 처리량을 증가시키는 접근법입니다.
  * 테스트 환경 설정, 수동 테스트, 변경 검토 프로세스 등 테스트 단계의 문제점을 상세히 파악하고 자동화 및 프로세스 개선을 통해 해결했습니다.
  * 개발자 추가 투입 여부를 결정할 때 테스트 팀의 역량도 함께 고려하여 균형 잡힌 리소스 배분을 통해 전체 흐름을 최적화했습니다.

### 12.4 주요 지표 (Key Metrics)
* **전체 처리량 (Throughput):** 출시되는 변경 사항의 양으로, 단순한 수치보다는 전달되는 가치와 함께 파악하여 의미 있는 측정이 되도록 합니다. 이는 팀의 생산성을 나타내는 핵심 지표입니다.
* **사이클 타임 (Cycle Time):** 개발 시작부터 고객 전달까지 소요되는 시간(예: 7주)으로, 개발 프로세스의 효율성을 직접적으로 보여주는 지표입니다.
* **평균 리드 타임 (Lead Time):** 아이디어 발상부터 고객 전달까지 소요되는 전체 시간(예: 15주)으로, 조직의 아이디어 실현 능력을 나타내는 중요한 지표입니다.

### 12.5 VSM 적용 방법
* 전체 흐름을 파악하고 측정하여 이해함으로써 현재 상태를 객관적으로 분석하고 개선 포인트를 식별
* 병목 지점을 해소하기 위해 인력을 재배치하고, 필요시 프로세스를 재설계하여 가치 흐름의 균형을 맞춤
* 데이터 기반으로 지속적인 개선을 추진하여 점진적으로 성과를 향상시키고 학습하는 조직 문화를 구축

### 12.6 요약
VSM은 소프트웨어 개발 프로세스를 전체적으로 조망하고 개선하여 개발 속도를 높이고 고객에게 더 나은 가치를 제공하는 데 기여합니다. 이는 단순한 프로세스 개선을 넘어 조직 문화와 협업 방식의 변화를 포함하는 전사적 접근법이라고 할 수 있습니다.


## 13. 애플리케이션 현대화와 3가지 주요 변혁
- 출처: [응용 프로그램 현대화 : 한 번에 세 가지 변형](https://www.youtube.com/watch?v=RJ3UQSxwGFY&list=PLOspHqNVtKAAm1dmyiR9WMmw1UBoOwZVj&index=13)


### 13.1 과거 vs 현재 vs 미래: IT 환경의 진화 양상

| 구분         | 과거 (Monolith)             | 현재 (SOA 기반)               | 미래 (Microservices)              |
|--------------|----------------------------|-------------------------------|---------------------------------|
| **아키텍처** | Monolithic<br>*단일 코드베이스에 모든 기능 통합* | 분산 아키텍처 (SOA)<br>*느슨하게 연결된 서비스들의 집합* | Microservices<br>*완전히 독립적인 작은 서비스들의 생태계* |
| **인프라**   | Physical Server<br>*고정된 용량, 관리 복잡성* | Virtual Machine<br>*향상된 유연성, 여전히 제한적 확장성* | Cloud (Public/Private)<br>*무한 확장성, 종량제 과금, 자동화* |
| **업무 방식** | Waterfall (장기 계획)<br>*느린 릴리스 주기, 위험 회피 중심* | Agile<br>*반복적 개발, 빠른 피드백* | DevOps, SRE<br>*지속적 통합/배포, 자동화된 운영* |

### 13.2 각 변혁의 심층 분석 및 상호 연관성
1. **Microservices 아키텍처**
    * **심층 특성:**
        * 작고 독립적인 서비스 단위로 구성되어 복잡성 관리
        * 비즈니스 도메인 중심 설계(DDD) 원칙 적용
        * REST/GraphQL 기반 API 통신으로 느슨한 결합 실현
        * 독립적인 배포와 스케일링으로 민첩성 확보
        * 폴리글랏 개발 지원 (서비스별 최적 기술 스택 선택 가능)

    * **Cloud 인프라와의 연결점:**
        * 컨테이너 기반 배포를 통한 일관된 환경 구현
        * 동적 확장을 위한 오케스트레이션(Kubernetes) 필요
        * 서비스 메시 기술로 복잡한 서비스 간 통신 관리
        * 클라우드 네이티브 서비스 활용 용이성
2. **Cloud 인프라**
    * **심층 특성:**
        * Public, Private, Hybrid 등 다양한 배포 모델 지원
        * 컴퓨팅, 스토리지, 네트워크 리소스의 프로그래밍 가능한 추상화
        * API 기반 자동화로 인프라 프로비저닝 간소화
        * 사용량 기반 과금으로 비용 최적화 가능

    * **Microservices와의 시너지:**
        * 서비스별 독립적 확장으로 리소스 효율성 극대화
        * 빠른 프로비저닝으로 새로운 서비스 출시 시간 단축
        * 클라우드 네이티브 서비스 통합으로 개발 생산성 향상
        * 멀티 리전/존 배포로 고가용성 확보 용이

3. **DevOps & SRE**
    * **심층 특성:**
        * 개발과 운영의 벽을 허물어 협업 강화
        * 자동화된 CI/CD 파이프라인으로 배포 리스크 감소
        * 코드로 관리되는 인프라(IaC)로 환경 일관성 유지
        * 데이터 기반 모니터링과 관찰성으로 신속한 문제 해결

    * **Microservices 및 Cloud와의 통합:**
        * 복잡한 분산 시스템의 효과적 관리 메커니즘 제공
        * 자동화된 배포 파이프라인으로 작은 변경의 빠른 릴리스 지원
        * 서비스 수준 목표(SLO) 중심의 운영으로 안정성과 혁신 균형 유지
        * 분산 추적, 로깅, 모니터링으로 복잡한 클라우드 환경 가시성 확보

### 13.3 애플리케이션 현대화(App Mod)의 통합적 접근

* **전환 프로세스의 복잡성:**
  * 기존 시스템의 점진적 마이그레이션 전략 필요
  * 비즈니스 가치에 따른 우선순위 설정 중요
  * 기술적 부채와 현대화 목표 사이의 균형 유지
  * 조직 문화와 기술 역량의 동시 발전 필수

* **통합적 변혁의 가치 제안:**
  * **비즈니스 민첩성:** 시장 변화에 신속하게 대응할 수 있는 역량
  * **운영 효율성:** 자동화와 최적화를 통한 비용 절감
  * **혁신 가속화:** 실험과 학습의 주기 단축
  * **회복력 향상:** 장애 격리와 자동 복구 메커니즘
  * **인재 유치/유지:** 현대적 기술 스택과 작업 방식으로 개발자 만족도 증가

### 13.4 결론: 디지털 트랜스포메이션의 핵심 동력

- 애플리케이션 현대화는 단순한 기술 업그레이드를 넘어서는 **비즈니스 변혁의 핵심 요소**입니다. 
- 세 가지 변혁 요소(아키텍처, 인프라, 업무 방식)의 통합적 추진은 조직이 디지털 시대에서 경쟁력을 유지하고 고객 가치를 지속적으로 창출하기 위한 필수적인 여정입니다. 
- 각 요소는 독립적으로는 제한된 가치만 제공하지만, 함께 적용될 때 **지속 가능한 디지털 혁신의 기반**을 형성


## 14. Tekton 소개
- 출처: [What is Tekton?](https://www.youtube.com/watch?v=TWxKD9dLpmk&list=PLOspHqNVtKAAm1dmyiR9WMmw1UBoOwZVj&index=14)

### **14. Tekton의 탄생 배경**
* Knative 프로젝트의 일환으로 CI/CD 파이프라인 자동화를 위해 개발되었습니다
* 처음에는 Knative 내부 프로젝트였으나, 그 가치를 인정받아 Continuous Delivery Foundation으로 기증
* 이를 통해 다양한 Kubernetes 환경에서 표준화된 CI/CD 솔루션으로 활용될 수 있게 되었습니다

### 14.2 Tekton의 핵심 구성 요소
1. **Task:**
* CI/CD 파이프라인에서 수행되는 가장 기본적인 작업 단위입니다
* 코드 빌드, 단위 테스트 실행, 컨테이너 이미지 생성, 애플리케이션 배포, 시스템 상태 확인 등 다양한 자동화 작업을 정의합니다
* 재사용 가능한 형태로 설계되어 여러 파이프라인에서 동일한 Task를 활용할 수 있습니다
* 개발 팀과 운영 팀 간의 역할 분리를 가능하게 하여 DevOps 문화를 촉진합니다

2. **Pipeline:**
* 여러 Task를 논리적 순서에 따라 조합하여 하나의 완전한 워크플로우를 구성합니다
* 각 애플리케이션의 특성과 소프트웨어 요구사항에 맞게 유연하게 커스터마이징할 수 있습니다
* 의존성 관리를 통해 Task 간의 실행 순서와 조건을 정의할 수 있습니다

3. **Pipeline Run:**
* 정의된 Pipeline의 실제 실행 인스턴스를 생성합니다
* 동일한 Pipeline 정의와 Task 구성을 유지하면서 다양한 입력 매개변수로 여러 번 실행할 수 있습니다
* 각 실행마다 독립적인 실행 기록과 로그를 생성하여 추적 및 디버깅이 용이합니다

4. **Pipeline Resource:**
* Pipeline 실행에 필요한 외부 데이터와 자원을 추상화합니다
* 빌드 번호, Git 저장소 URL, Docker 이미지 태그 등 파이프라인 실행에 필요한 컨텍스트 정보를 제공
* 동일한 Pipeline 정의를 다양한 환경과 상황에 맞게 유연하게 커스터마이징할 수 있도록 합니다

### 14.3 Tekton 구현 및 활용 방법

1. **Task 관리 및 등록:**
* 범용적으로 사용 가능한 표준 Task들을 Kubernetes 클러스터 내 Tekton Execution Engine에 등록
* 등록된 Task는 조직 내 여러 애플리케이션이나 개발팀에서 공통으로 활용할 수 있습니다
* DevOps 조직의 운영팀에서 표준 Task의 품질과 보안을 중앙에서 관리하고 제어할 수 있습니다

2. **Kubernetes 생태계와의 통합:**
* Tekton은 네이티브 Kubernetes 리소스 모델을 기반으로 구축되었습니다
* Pod, Service, CRD(Custom Resource Definition), YAML 정의 등 Kubernetes의 핵심 개념 활용
* Kubernetes의 확장성과 유연성을 CI/CD 파이프라인에 그대로 적용할 수 있습니다

3. **개발자 워크플로우:**
* 개발자는 애플리케이션 코드 저장소 내에 pipeline.yaml 형태로 Tekton Pipeline을 정의합니다
* 하나의 Pipeline은 애플리케이션 빌드, 테스트, 배포 등 여러 단계의 Task를 포함할 수 있습니다
* 각 Task는 더 작은 단위의 여러 Step으로 세분화하여 정의할 수 있습니다

4. **CI/CD 파이프라인 자동화:**
* 개발자가 Git 저장소에 코드 변경사항을 Push하면 Webhook을 통해 자동으로 파이프라인이 트리거
* Tekton 시스템은 애플리케이션의 Pipeline 정의와 등록된 Task 정의를 결합하여 실행합니다
* 파이프라인은 코드를 컨테이너 이미지로 패키징하고, 이를 Kubernetes 이미지 레지스트리에 저장
* 개발, 테스트, 스테이징 등 다양한 Namespace에 애플리케이션을 자동으로 배포할 수 있습니다
* 정의된 워크플로우에 따라 다른 환경으로의 승격 배포도 자동화할 수 있습니다

### 14.4 결론 및 이점

- Tekton은 Kubernetes 네이티브 CI/CD 도구로서, 클라우드 네이티브 애플리케이션의 개발 및 배포 프로세스를 표준화하고 자동화합니다. 
- 재사용 가능한 구성 요소, Kubernetes와의 원활한 통합, 선언적 정의 방식을 통해 현대적인 소프트웨어 배포 파이프라인을 구축하는 데 필요한 유연성과 확장성을 제공합니다. 
- 이를 통해 개발 팀은 인프라 관리보다 애플리케이션 개발에 더 집중할 수 있으며, 
- 운영 팀은 표준화된 배포 프로세스를 통해 일관성과 안정성을 확보할 수 있습니다.


## 15. Terraform 소개
- 출처: [Terraform Explained](https://www.youtube.com/watch?v=HmxkYNv1ksg&list=PLOspHqNVtKAAm1dmyiR9WMmw1UBoOwZVj&index=15)

### 15.1 Terraform이란?

* HashiCorp에서 개발한 오픈 소스 인프라 자동화 도구로, 클라우드 및 온프레미스 환경의 인프라 구축을 코드로 관리할 수 있게 해줍니다.
* 사용자는 HCL(HashiCorp Configuration Language)이라는 선언적 언어를 사용하여 원하는 인프라 상태를 정의하면, Terraform이 실제 인프라를 해당 상태로 구축 및 유지합니다.
* 이는 마치 택시에서 목적지만 말하면 운전사가 최적의 경로로 데려다주는 것과 같습니다. 사용자는 최종 상태(무엇을)만 정의하고, 구현 방법(어떻게)은 Terraform이 처리합니다.

### 15.2 Terraform 워크플로우 (3단계)

1. 코딩 (Terraform 파일 작성):
* 필요한 인프라 리소스(가상 머신, 컨테이너, 네트워크 등)를 `.tf` 파일에 정의합니다.
* 각 리소스에 필요한 세부 설정(이름, 크기, 위치, 네트워크 구성 등)을 코드로 명시합니다.
* 이 과정에서 변수, 모듈, 조건문 등을 활용해 유연한 인프라 코드를 작성할 수 있습니다.

2. 계획 (terraform plan):
* Terraform CLI가 현재 인프라 상태와 코드로 정의된 목표 상태를 비교분석합니다.
* 어떤 리소스가 생성, 수정, 삭제될지 상세한 실행 계획을 제시합니다.
* 초기 구축(Day-0)에서는 모든 리소스가 신규 생성되며, 이후 변경 사항에 대해서는 차이점만 표시
* 이 단계에서 잠재적 오류나 의도치 않은 변경 사항을 미리 확인할 수 있습니다.

3. 적용 (terraform apply):
* 확인된 계획을 실제 인프라에 적용하는 단계입니다.
* Terraform이 각 클라우드 제공업체(AWS, Azure, GCP 등)의 API를 호출하여 리소스를 실제로 생성/변경합니다.
* 작업 완료 후 접속 정보, 엔드포인트 URL, IP 주소 등의 출력 변수(output variables)를 제공하여 사용자가 쉽게 새 인프라에 접근할 수 있게 합니다.
* 상태 파일(terraform.tfstate)에 최신 인프라 상태를 기록하여 다음 변경 시 참조합니다.

### 15.3 Terraform의 장점

1. 강력한 오픈 커뮤니티 및 확장성:
* 다양한 오픈소스 모듈과 프로바이더를 통해 거의 모든 클라우드 서비스와 인프라를 관리
* Terraform Registry에서 검증된 모듈을 쉽게 찾아 재사용할 수 있어 개발 시간을 단축
* 2,000개 이상의 프로바이더가 존재하여 AWS, Azure부터 Kubernetes, GitHub, Salesforce까지 다양한 서비스를 단일 도구로 관리할 수 있습니다.

2. Terraform 모듈:
* 재사용 가능한 인프라 코드 단위로, 복잡한 구성을 논리적으로 그룹화합니다.
* 표준화된 입출력 인터페이스를 통해 일관된 인프라 패턴을 구현할 수 있습니다.
* 다양한 인프라 수준(IaaS, PaaS, SaaS)을 모두 관리할 수 있어 전체 기술 스택을 코드로 관리
* 기업 내부 모듈 라이브러리를 구축하여 팀 간 지식 공유와 인프라 표준화를 촉진할 수 있습니다.

3. DevOps 우선:
* 인프라의 초기 배포뿐만 아니라 지속적인 변경 관리와 유지보수를 위한 기능을 제공합니다.
* 버전 관리 시스템(Git 등)과 통합하여 인프라 변경에 대한 이력 관리, 코드 리뷰, 승인 과정을 구현
* "구성 드리프트(Configuration Drift)" 감지 및 교정 기능으로 인프라가 항상 코드에 정의된 상태와 일치하도록 유지합니다.
* 동일한 코드를 사용해 개발, 테스트, 프로덕션 환경을 일관되게 복제함으로써 "개발=프로덕션" 원칙을 실현하고 환경 간 불일치 문제를 해결합니다.
* CI/CD 파이프라인과 통합하여 인프라 변경을 자동화하고 안전하게 배포할 수 있습니다.

### 15.4 결론

- Terraform은 단순한 인프라 자동화 도구를 넘어 현대적인 클라우드 환경에서 인프라를 코드로 관리하는 핵심 도구로 자리잡았습니다. 
- 선언적 접근 방식, 강력한 생태계, DevOps 친화적 특성을 통해 조직은 더 안정적이고 반복 가능한 인프라 관리 프로세스를 구축할 수 있으며, 이는 비즈니스 민첩성과 운영 효율성 향상으로 이어집니다. 
- 특히 멀티클라우드 환경에서 일관된 관리 방식을 제공하여 클라우드 전략의 유연성을 높이는 데 큰 기여를 합니다.

## 16. Terraform vs. Ansible 비교
- 출처: [Ansible vs. Terraform: What's the difference?](https://www.youtube.com/watch?v=rx4Uh3jv1cA&list=PLOspHqNVtKAAm1dmyiR9WMmw1UBoOwZVj&index=16)

### 16.1 주요 차이점: 목적과 접근 방식의 근본적 차이

| 특징 | Terraform | Ansible |
|---|---|---|
| **주요 목적** | 인프라 프로비저닝 (Infrastructure Provisioning) - 클라우드 리소스를 생성하고 관리하는 데 초점 | 구성 관리 (Configuration Management), 애플리케이션 배포 - 서버 내부 설정과 소프트웨어 설치에 특화 |
| **접근 방식** | 선언적 (Declarative) - 원하는 최종 상태만 정의하면 시스템이 알아서 구현 방법 결정 | 혼합형 (Hybrid) - 선언적 리소스 정의와 함께 절차적 실행 흐름 제공, 작업 순서가 중요함 |
| **의존성 처리** | 암묵적/명시적 의존성 지원 - 리소스 간 관계를 그래프로 구성하여 자동 처리 | 절차적 실행 (순서 중요) - 작업이 정의된 순서대로 실행되며 개발자가 의존성 관리 책임 |
| **라이프사이클 관리** | 상태 기반 (State-based) - tfstate 파일로 현재 인프라 상태를 추적하고 자동 관리 | 수동 관리 - 리소스 생성은 쉽지만 삭제 시 명시적 삭제 단계 작성 필요 |
| **멱등성 (Idempotency)** | 자동 지원 - 설계 자체가 멱등성을 보장하도록 구현됨 | 모듈에 따라 지원 여부 결정 - 개발자가 직접 멱등성을 고려한 설계 필요 |

### 16.2 Terraform: 인프라 프로비저닝의 최강자

*   **장점:**
    *   **선언적 방식:** 
        - 최종 상태만 정의하면 Terraform이 현재 상태와 비교하여 필요한 변경사항을 자동으로 계산하고 적용합니다.
    *   **암묵적/명시적 의존성 처리:** 
        - 리소스 간 의존성을 자동 감지하거나 개발자가 명시적으로 선언할 수 있어 복잡한 인프라도 올바른 순서로 생성됩니다.
    *   **상태 기반 관리:** 
        - tfstate 파일을 통해 현재 인프라 상태를 정확히 추적하고, 코드 변경에 따른 리소스 업데이트를 자동으로 처리합니다.
    *   **멱등성:** 
        - 동일한 코드를 여러 번 실행해도 항상 동일한 결과를 보장하며, 불필요한 변경은 하지 않음.
*   **주요 기능:**
    *   **클라우드 리소스 프로비저닝:** 
        - AWS, Azure, GCP 등 다양한 클라우드 제공자의 DB, Kubernetes, VM 등 광범위한 리소스 생성 및 관리가 가능합니다.
    *   **Terraform Plan:** 
        - 실제 API 호출 전 수행될 변경 사항을 미리 확인할 수 있어 안전한 인프라 관리가 가능합니다.
    *   **Terraform Apply:** 
        - 검증된 계획을 바탕으로 클라우드 제공자 API를 호출하여 인프라를 구축하거나 변경합니다.

### 16.3 Ansible: 구성 관리와 배포의 대표주자

*   **장점:**
    *   **구성 관리 및 애플리케이션 배포 특화:** 
        - OS 설정, 패키지 설치, 서비스 구성 등 서버 내부 환경 관리에 탁월한 성능을 보입니다.
    *   **에이전트리스 (Agentless):** 
        - 대상 서버에 별도의 에이전트 설치가 필요 없어 관리 부담이 적고, SSH만으로 원격 작업이 가능합니다.
    *   **방대한 모듈 및 컬렉션:** 
        - 활발한 오픈 소스 커뮤니티의 지원으로 수천 개의 사전 정의된 모듈을 활용할 수 있어 빠른 시작과 개발이 가능합니다.
*   **주요 기능:**
    *   **다양한 환경 관리:** 
        - VM 시작/중지, 애플리케이션 설치, 런타임 환경 구성, 네트워크 설정 등 서버 관리의 전 영역을 자동화합니다.
    *   **Ansible Playbook:** 
        - YAML 형식의 선언적 구성 파일로 복잡한 자동화 작업을 쉽게 정의하고 실행할 수 있습니다.

### 16.4 공통점: 현대 인프라 자동화의 필수 요소

*   **템플릿 지원:** 
    - 변수와 조건문을 활용한 템플릿 기능으로 Dev/Test/Prod 등 여러 환경에 대한 일관된 설정 관리가 가능합니다.
*   **강력한 오픈 소스 생태계:** 
    - Terraform Registry와 Ansible Galaxy를 통해 검증된 모듈과 플레이북을 공유하고 재사용
*   **에이전트리스 아키텍처:** 
    - 두 도구 모두 대상 시스템에 별도 에이전트 설치가 필요 없어 쉬운 설치 및 사용이 가능합니다.

### 16.5 함께 사용하는 방법: 최적의 DevOps 워크플로우 구축

*   **Terraform -> Ansible 파이프라인:** 
    * Terraform으로 클라우드 인프라(VM, 네트워크, 스토리지 등)를 프로비저닝합니다.
    * 프로비저닝이 완료된 후 Ansible로 OS 구성, 미들웨어 설치, 애플리케이션 배포를 수행합니다.
    * 이 방식은 '인프라 변경 → 구성 관리'의 논리적 흐름을 따라 작업이 진행됩니다.

*   **Ansible -> Terraform 통합:**
    * Ansible Playbook의 첫 단계에서 Terraform 모듈을 호출하여 인프라 프로비저닝을 수행합니다.
    * 단일 워크플로우 내에서 인프라 생성부터 구성까지 모든 과정을 관리할 수 있습니다.
    * 복잡한 멀티 클라우드 환경에서 특히 유용한 접근법입니다.

### 16.6 결론: 상황에 맞는 선택과 조합의 중요성

- Terraform은 클라우드 리소스와 인프라 프로비저닝에 타의 추종을 불허하는 강점을 보이며, 
- Ansible은 서버 구성 관리와 애플리케이션 배포 영역에서 뛰어난 성능을 발휘합니다. 
- 두 도구의 장점을 결합하면 인프라 생성부터 애플리케이션 배포까지 완전 자동화된 CI/CD 파이프라인을 구현할 수 있어, 현대적인 DevOps 환경에서는 이 두 도구를 상호 보완적으로 활용하는 것이 최적의 선택

## 17. GitOps를 활용한 멀티 클라우드 관리
- 출처: [GitOps on Multicloud Explained](https://www.youtube.com/watch?v=tQtni2st3xo&list=PLOspHqNVtKAAm1dmyiR9WMmw1UBoOwZVj&index=17)

### 17.1 문제점
* **복잡한 관리 환경**: 기존 방식에서는 온프레미스 환경과 여러 클라우드 서비스마다 각기 다른 GUI와 CLI를 사용해야 했습니다. 이로 인해 인프라 관리가 매우 복잡해지고 일관성 있는 운영이 어려워졌습니다.
* **하이브리드 환경의 도전**: 온프레미스와 클라우드를 함께 운영하는 하이브리드 환경에서는 각 환경의 특성과 관리 방식이 달라 통합적인 관리가 더욱 어려워졌습니다.
* **증가하는 복잡성**: 사용하는 클라우드 서비스가 늘어날수록 관리해야 할 인터페이스와 도구가 증가하고, 이에 따라 관리 복잡성이 기하급수적으로 증가합니다.

### 17.2 해결책
* **GitOps 접근 방식**: 모든 인프라, 서비스, 애플리케이션 배포를 Git 저장소를 통해 관리하는 방식을 도입합니다. 이를 통해 코드형 인프라(Infrastructure as Code)를 실현하고 일관된 관리 체계를 구축

### 17.3 GitOps의 장점
* **개발-운영 협업 강화**: 
    - 개발팀은 이미 Git에 익숙하며, 운영팀은 환경 관리에 전문성을 가지고 있습니다. GitOps를 통해 두 팀이 동일한 도구와 프로세스로 협업할 수 있어 효율성이 크게 향상됩니다.
* **통합 관리 체계**: 
    - 인프라 구성, 서비스 설정, 애플리케이션 코드를 모두 Git 저장소에서 버전 관리함으로써 변경 이력 추적과 롤백이 용이해집니다.
* **자동화된 일관성 유지**: 
    - Git 저장소의 변경 사항이 자동으로 실제 배포 환경에 반영되어 '의도한 상태'와 '실제 상태'의 일관성을 지속적으로 유지할 수 있습니다.
* **강화된 보안 체계**: 
    - Git의 접근 권한 관리와 승인 프로세스를 통해 시스템 보안을 크게 강화할 수 있습니다. 데모에서는 타사 관리 콘솔에 대한 직접 접근을 제한함으로써 보안 위험을 감소시키는 효과를 실제로 입증했습니다.

### 17.4 OpenShift 활용
* **통합 플랫폼 제공**: Red Hat OpenShift는 온프레미스부터 다양한 클라우드 환경까지 일관된 관리 경험을 제공합니다.
* **GitOps와의 시너지**: OpenShift는 GitOps 방식과 결합하여 더욱 안전하고 효율적인 멀티 클라우드 관리 솔루션을 제공합니다.
* **자동화된 배포 파이프라인**: OpenShift의 CI/CD 기능과 GitOps를 연계하여 코드 변경부터 배포까지 완전 자동화된 워크플로우를 구성할 수 있습니다.

### 17.5 결론
- GitOps는 점점 복잡해지는 멀티 클라우드 환경을 단순하고 일관성 있게 관리할 수 있는 강력한 패러다임
- 특히 OpenShift와 같은 컨테이너 플랫폼과 결합할 경우, 보안성과 효율성을 동시에 확보하면서 멀티 클라우드 전략을 성공적으로 구현할 수 있습니다.


## 18. SRE Golden Signals
- 출처: [SRE Golden Signals Explained](https://www.youtube.com/watch?v=-U9E1PhrM3o&list=PLOspHqNVtKAAm1dmyiR9WMmw1UBoOwZVj&index=18)

### **18.1 SRE Golden Signals의 필요성**

*   자동차 엔진 경고등처럼, 문제가 심각해지기 전에 미리 알려주는 지표입니다. 즉, 시스템 내에서 발생할 수 있는 잠재적 문제점을 사전에 식별하고 경고하여 선제적 대응이 가능하게 합니다.
*   문제를 조기에 감지하여 더 큰 문제(견인, 더 비싼 수리)를 예방할 수 있습니다. 클라우드 환경에서는 이는 다운타임 방지, 고객 경험 저하 방지, 그리고 대규모 장애 복구 비용 절감으로 이어집니다.

### **18.2 SRE Golden Signals 정의 (마이크로서비스 애플리케이션 대상)**

*   **Latency (지연 시간):** 요청과 응답 사이의 시간입니다. 사용자 경험에 직접적인 영향을 미치는 핵심 지표로, 웹 애플리케이션은 일반적으로 200-400ms, API 호출은 20ms 정도가 적정 수준입니다. 지연 시간이 증가하면 사용자 불만족으로 이어질 수 있습니다.
*   **Errors (오류):** 오류 발생 횟수 및 종류를 측정합니다. 갑작스러운 오류 급증은 심각한 문제의 징후로 볼 수 있으며, 일반적으로 서버 측 오류(500 계열)는 클라이언트 측 오류(400 계열)보다 더 심각하게 고려해야 합니다.
*   **Traffic (트래픽):** 예상 대비 실제 요청량을 측정합니다. 정상적인 패턴에서 벗어난 트래픽 변화는 DDoS 공격이나 새로운 기능 출시에 따른 사용자 행동 변화를 나타낼 수 있습니다.
*   **Saturation (포화도):** 예상 용량 대비 실제 부하를 측정합니다. 자동차의 RPM 게이지처럼 시스템이 얼마나 과부하 상태에 근접하고 있는지 보여주며, CPU, 메모리, 디스크 I/O, 네트워크 대역폭 등의 리소스 사용률을 포함합니다.

### **18.3 마이크로서비스 아키텍처 예시**

*   여러 웹 앱 (Public Cloud)에서 시작하여 백엔드 서비스로 연결되고, 이는 다시 인증 마이크로서비스와 트랜잭션 서비스로 분기됩니다. 최종적으로 이들은 데이터 마이크로서비스(DB wrapper)와 통신합니다.
*   각 서비스는 마이크로서비스로 래핑되어 구현 세부 사항에 신경 쓸 필요 없이 API만 사용할 수 있습니다. 이러한 구조는 서비스 간 느슨한 결합을 가능하게 하며, 개별 서비스의 독립적인 개발, 배포, 확장이 가능

### **18.4 개발팀(Dev) vs 운영팀(Ops) 관점에서의 장단점**

| 특징      | 개발팀(Dev)                                                     | 운영팀(Ops)                                                               |
| :-------- | :-------------------------------------------------------------- | :------------------------------------------------------------------------ |
| 기술 선택 | 다양한 기술 선택 가능 (마이크로서비스는 구현을 캡슐화하고 API만 제공). 개발자들은 각 서비스에 가장 적합한 프로그래밍 언어나 프레임워크를 자유롭게 선택할 수 있어 생산성이 향상됩니다. | 더 많은 기술 전문 지식 필요 (문제 진단, 로그 확인, 근본 원인 파악). 다양한 기술 스택을 모니터링하고 문제를 해결해야 하므로 운영팀의 기술적 부담이 증가합니다. |
| 배포 주기 | 잦은 배포 선호 (개발 일정에 맞춰 배포 가능). 작은 단위의 코드 변경을 빠르게 릴리스할 수 있어 시장 대응력이 향상됩니다. | 더 많은 변경 사항 인지 필요. 잦은 배포는 운영팀이 시스템의 전체 상태를 파악하고 변경 사항을 추적하는 데 어려움을 줄 수 있습니다. |
| 변경      | 잦은 변경이 반드시 나쁜 것은 아님 (작은 변경은 문제 진단에 오히려 도움). 작은 변경사항은 문제 발생 시 원인을 더 쉽게 파악할 수 있게 해줍니다. | 변경 관리와 안정성 사이의 균형을 유지해야 합니다. 운영팀은 시스템 안정성을 최우선으로 고려하므로 변경에 더 보수적일 수 있습니다. |

### **18.5 SRE Golden Signals를 활용한 문제 진단 예시**

*   사용자가 응답 시간 오류를 보고합니다 (Latency 문제). 이를 통해 서비스 간 의존성을 확인하여 문제의 근원을 추적합니다.
*   조사 결과, 트랜잭션 서비스에서 Latency 및 Error 문제가 발생하고 있음을 확인합니다. 이는 트랜잭션 처리 과정에서 병목 현상이나 오류가 발생하고 있음을 의미합니다.
*   더 깊이 들어가 확인해보니 데이터 서비스에서 Saturation 문제가 발생했음을 발견합니다. 데이터베이스 리소스가 과도하게 사용되고 있어 상위 서비스의 성능에 영향을 미치고 있는 것입니다.
*   Golden Signals 모니터링을 통해 문제의 근본 원인을 빠르게 파악하고 데이터베이스 최적화 또는 스케일링과 같은 적절한 해결책을 적용할 수 있습니다.

### **18.6 APM (Application Performance Management) Dashboard**

*   SRE Golden Signals를 통합하여 시각적으로 보여주는 대시보드는 시스템 상태를 한눈에 파악
*   운영팀은 중앙 집중식 문제 모니터링 및 해결에 이 대시보드를 활용하고, 개발팀은 자체 서비스 대시보드를 통해 개발 중인 서비스의 성능을 모니터링할 수 있습니다.
*   이러한 가시성은 평균 문제 해결 시간(MTTR)을 대폭 단축시키고, 근본 원인 파악 속도를 향상시킵니다. 문제가 발생했을 때 원인을 더 빠르게 찾아내고 해결할 수 있습니다.
*   결론적으로 사용자가 엔진 경고등을 덜 보게 됩니다. 즉, 사전 예방적 모니터링을 통해 사용자가 경험하는 문제의 발생 빈도와 심각도가 줄어들게 됩니다.