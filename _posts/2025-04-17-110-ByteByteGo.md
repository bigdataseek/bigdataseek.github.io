---
title: 32차시 10:ByteByteGo
layout: single
classes: wide
categories:
  - ByteByteGo
toc: true # 이 포스트에서 목차를 활성화
toc_sticky: true # 목차를 고정할지 여부 (선택 사항)
---

## 121. API 학습 로드맵
- 출처: [APIs Explained in 6 Minutes!](https://www.youtube.com/watch?v=hltLrjabkiY)

### **121.1 API 기초**

*   **API (Application Programming Interface) 정의:** 서로 다른 소프트웨어 시스템 간의 통신을 가능하게 하는 규칙 집합. 예를 들어, 모바일 앱이 서버에서 데이터를 가져오거나, 결제 시스템이 은행과 통신할 때 사용됩니다. API는 요청과 응답의 형식을 정의하여 시스템 간 상호작용을 간소화합니다.
*   **API 유형:**
    *   **Public API:** 누구나 사용 가능하며, 개발자 포털을 통해 접근 (예: Twitter API로 트윗 데이터를 가져오거나, OpenWeatherMap API로 날씨 정보 조회). 공개 API는 보통 문서화가 잘 되어 있어 쉽게 시작 가능.
    *   **Private API:** 조직 내부 시스템 간 데이터 교환에 사용. 예를 들어, 회사의 CRM과 ERP 시스템 간 연동. 보안과 접근 제어가 중요.
    *   **Partner API:** 특정 비즈니스 파트너에게만 제공되며, 계약 기반으로 접근 권한 부여 (예: 결제 게이트웨이 Stripe가 특정 파트너에게 제공하는 API).

### **121.2 API 아키텍처 스타일**

*   **REST:** 가장 널리 사용되는 스타일로, 리소스(데이터)를 URL로 표현하고 HTTP 메서드로 조작. 직관적이고 서버-클라이언트 간 상태를 유지하지 않음(Stateless). 예: `/users/123`로 사용자 정보 조회.
*   **GraphQL:** 클라이언트가 필요한 데이터만 정확히 요청할 수 있어 과다/부족 데이터 문제를 해결. 단일 엔드포인트로 유연한 쿼리 가능 (예: GitHub API). 학습 곡선이 있지만 효율적.
*   **gRPC:** Google이 개발한 고성능 RPC 프레임워크. HTTP/2와 Protocol Buffers를 사용해 빠르고 효율적이며, 마이크로서비스 간 통신에 적합. 예: 서버 간 실시간 데이터 교환.
*   **SOAP:** XML 기반의 엄격한 프로토콜로, 복잡한 엔터프라이즈 환경에서 사용. 보안과 트랜잭션 처리가 강력하지만, REST에 비해 무겁고 복잡. 예: 금융 시스템.
*   **WebSocket:** 양방향 실시간 통신을 지원. 채팅 앱, 주식 시세 대시보드 등에서 사용. 연결이 유지되어 지속적인 데이터 교환이 가능.

### **121.3 핵심 API 용어 (REST 기준)**

*   **HTTP 메서드:**
    *   **POST:** 새 리소스 생성 (예: 새 사용자 계정 등록). 비멱등적이어서 반복 요청 시 중복 생성 가능.
    *   **GET:** 리소스 조회 (예: 사용자 프로필 정보 가져오기). 멱등적이며, 데이터 변경 없음.
    *   **PUT:** 기존 리소스 업데이트 (예: 사용자 이름 변경). 전체 리소스를 교체.
    *   **DELETE:** 리소스 삭제 (예: 게시글 삭제). 멱등적이므로 반복 호출해도 결과 동일.
*   **HTTP 상태 코드:** 요청 결과를 나타냄. 예: `200 OK` (성공), `404 Not Found` (리소스 없음), `500 Internal Server Error` (서버 오류).
*   **헤더/쿠키:** 요청/응답에 메타데이터 포함. 헤더는 인증 토큰, 콘텐츠 유형 등을 전달 (예: `Authorization: Bearer token`). 쿠키는 클라이언트 상태 유지에 사용 (예: 로그인 세션).

### **121.4 API 보안**

*   **Basic Auth:** 사용자 이름과 비밀번호를 Base64로 인코딩해 전송. HTTPS 없이는 취약하므로 최신 애플리케이션에서 잘 사용되지 않음.
*   **토큰 기반 인증:** 임시 액세스 토큰을 발급받아 사용 (예: API 키). 토큰은 만료되거나 폐기 가능해 보안성이 높음.
*   **JWT (JSON Web Token):** 사용자 정보와 서명을 포함한 토큰. 서버에서 상태를 저장하지 않아 확장성이 뛰어남. 예: 로그인 후 발급된 JWT로 API 요청 인증.
*   **OAuth:** 타 서비스에 권한을 위임 (예: Google 계정으로 앱 로그인). 복잡하지만 보안성과 사용자 경험 우수.
*   **세션 기반 인증:** 서버가 세션 ID를 저장하고 관리. 기존 웹 앱에서 흔히 사용되지만, 스케일링에 제약이 있을 수 있음.

### **121.5 API 문서화**

*   **중요성:** 명확한 문서는 개발자가 API를 쉽게 이해하고 사용하도록 도움. 좋은 문서는 채택률을 높이고 지원 비용을 줄임.
*   **도구:**
    *   **Swagger/OpenAPI Specification:** API 엔드포인트, 요청/응답 형식 등을 표준화된 포맷으로 정의. 인터랙티브 UI 제공 (예: Swagger UI로 API 테스트).
    *   **Postman:** API 테스트, 모니터링, 협업을 지원. 팀 간 워크플로우 개선 (예: API 요청 컬렉션 공유).

### **121.6 최신 API 기능**

*   **페이징 (Pagination):** 대량 데이터를 효율적으로 처리. 예: 1000개의 게시물을 10개씩 나눠 반환 (쿼리 파라미터: `?page=2&limit=10`).
*   **파라미터:** 다양한 입력 방식 지원. URL 경로 (`/users/{id}`), 쿼리 문자열 (`?sort=asc`), 요청 바디 (JSON 데이터)로 유연한 요청 가능.
*   **멱등성 (Idempotency):** 동일한 요청을 반복해도 결과가 동일 (예: DELETE 요청은 리소스가 이미 삭제된 경우 동일한 상태 유지). 안정적인 API 설계의 핵심.
*   **버전 관리:** API 변경 시 기존 클라이언트를 깨뜨리지 않음. 예: `/v1/users`에서 `/v2/users`로 업그레이드.

### **121.7 API 성능**

*   **캐싱 (Caching):** 자주 요청되는 데이터를 저장해 응답 속도 향상 (예: Redis로 GET 요청 결과 캐싱). 서버 부하 감소.
*   **Rate Limiting:** API 남용 방지. 예: 사용자당 초당 100번 요청 제한. DDoS 공격 방어에도 유용.
*   **로드 밸런싱 (Load Balancing):** 트래픽을 여러 서버로 분산해 안정성 확보 (예: NGINX, AWS ELB).
*   **효율적인 페이징:** 데이터베이스 인덱스를 활용해 쿼리 성능 최적화. 예: `OFFSET` 대신 커서 기반 페이징 사용.

### **121.8 API 게이트웨이**

*   **역할:** 모든 API 요청의 단일 진입점으로, 요청 라우팅과 관리 기능 제공. 복잡한 백엔드 구조를 단순화.
*   **기능:** 인증/인가, 요청 제한, 로깅, 모니터링 등. 예: 사용자 요청이 유효한 토큰을 포함하는지 확인.
*   **옵션:**
    *   **AWS API Gateway:** 서버리스 환경에 최적화. 빠른 설정과 확장 가능.
    *   **Kong:** 오픈 소스로, 플러그인 기반의 유연한 확장 가능.
    *   **Apigee:** 대규모 엔터프라이즈 환경에 적합. 강력한 분석 및 관리 기능.

### **121.9 API 구축 프레임워크**

*   **Express.js:** Node.js 기반, 간단한 API 빠르게 구축 가능. 초보자에게 친화적 (예: 간단한 REST API 구현).
*   **Spring Boot:** Java 기반, 엔터프라이즈 애플리케이션에 적합. 강력한 생태계와 자동 설정 지원.
*   **Flask/Django (Python):** Flask는 경량, Django는 풀스택 프레임워크. 데이터 과학 및 웹 개발에 널리 사용.
*   **FastAPI:** Python 기반, 비동기 처리와 자동 문서화(Swagger) 지원. 높은 성능과 현대적 설계.

### **121.10 시스템 디자인 패턴**

*   **동기 통신:** 요청 후 즉시 응답 반환. 예: 결제 처리 API는 즉각적인 결과를 필요로 함.
*   **비동기 통신:** 요청 후 백그라운드에서 처리 후 결과 알림. 예: 이메일 전송 API. 사용자 경험 개선.
*   **Webhooks:** 이벤트 발생 시 클라이언트에 알림 전송. 예: GitHub에서 코드 푸시 시 알림 전송.
*   **배치 처리:** 대량 데이터를 주기적으로 처리. 예: 매일 밤 사용자 통계 데이터 집계.
*   **메시지 큐:** RabbitMQ, Kafka 등을 사용해 시스템 간 안정적인 데이터 전달. 예: 주문 처리 시스템 간 데이터 전송.

