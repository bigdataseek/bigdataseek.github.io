---
title: 1차시 4(빅데이터 분석):MySQL(실습 예제)
layout: single
classes: wide
categories:
  - MySQL
toc: true # 이 포스트에서 목차를 활성화
toc_sticky: true # 목차를 고정할지 여부 (선택 사항)
---

- 출처: [SQL 배우기: Big 6를 넘어서](https://www.youtube.com/watch?v=OY885vY9eOI&list=PLGAnLqlBhx1F4pnuNANifJXth8YqDt4AY&index=12)
-  [Maven Analytics Dataset](https://mavenanalytics.io/data-playground)

- <a href="/assets/data/films.csv" download>films.csv 파일 내려받기</a> : 워크벤치로 films라는 테이블을 구성함.

## 1. 기본 SQL "빅 6" 절 복습

SQL 쿼리는 항상 다음 순서로 작성됩니다:

```sql
SELECT    -- 어떤 열을 선택할지
FROM      -- 어떤 테이블에서 가져올지
WHERE     -- 조건으로 데이터 필터링
GROUP BY  -- 데이터를 그룹으로 묶기
HAVING    -- 그룹화된 데이터 필터링
ORDER BY  -- 결과 정렬
```

### 1.1 실제 예시 (픽사 영화 데이터)

```sql
-- 2010년 이후 개봉한 영화들을 개봉일 순으로 정렬
SELECT title, release_date
FROM films
WHERE release_date >= '2010-01-01'
ORDER BY release_date DESC;

-- 등급별 영화 수가 5개 이상인 등급만 보기
SELECT rating, COUNT(*) as movie_count
FROM films
GROUP BY rating
HAVING COUNT(*) >= 5
ORDER BY movie_count DESC;
```

## 2. 유용한 SQL 함수들

### 2.1 날짜 함수
```sql
-- 영화 개봉 연도 추출
SELECT title, YEAR(release_date) as release_year
FROM films;
```

### 2.2 숫자 함수
```sql
-- 연도를 10년 단위로 그룹화 (1990년대, 2000년대 등)
-- 표현식 반복으로 작성 → 모든 환경에서 안전
SELECT FLOOR(YEAR(release_date)/10)*10 as decade,
       COUNT(*) as movie_count
FROM films
GROUP BY FLOOR(YEAR(release_date)/10)*10;
```

### 2.3 문자열 함수
```sql
-- 영화 제목에서 숫자 제거 (시리즈 영화 그룹화용)
SELECT REGEXP_REPLACE(title, '[0-9\s]+', '') as series_name,
       COUNT(*) as sequel_count
FROM films
GROUP BY REGEXP_REPLACE(title, '[0-9\s]+', '');
```

## 3. JOIN vs UNION

### 3.1 JOIN: 테이블을 옆으로 연결

```sql
-- 별도의 실습 데이터 없음. 내용만 확인

-- INNER JOIN: 두 테이블에 모두 있는 데이터만
SELECT f.title, d.director_name
FROM films f
INNER JOIN directors d ON f.director_id = d.id;

-- LEFT JOIN: 왼쪽 테이블 모든 데이터 + 오른쪽에서 일치하는 것
SELECT f.title, d.director_name
FROM films f
LEFT JOIN directors d ON f.director_id = d.id;
```

### 3.2 UNION: 테이블을 위아래로 연결
```sql
-- 별도의 실습 데이터 없음. 내용만 확인

-- 두 쿼리 결과를 하나로 합치기
SELECT title, 'Pixar' as studio FROM pixar_films
UNION
SELECT title, 'Disney' as studio FROM disney_films;
```

## 4. 윈도우 함수 (Window Functions)

전체 테이블이나 특정 그룹에 대해 계산하는 강력한 기능입니다.

```sql
-- 각 영화에 순번 매기기
SELECT title, 
       ROW_NUMBER() OVER (ORDER BY release_date) as film_number
FROM films;

-- 이전 영화와 평점 비교
SELECT title, 
       imdb_score,
       LAG(imdb_score) OVER (ORDER BY release_date) as prev_score,
       imdb_score - LAG(imdb_score) OVER (ORDER BY release_date) as score_diff
FROM films;

-- 장르별 최고 평점 영화 찾기
SELECT title, genre, imdb_score,
       RANK() OVER (PARTITION BY genre ORDER BY imdb_score DESC) as rank_in_genre
FROM films;
```

## 5. 서브쿼리 vs CTE (Common Table Expressions)

### 5.1 서브쿼리 방식
```sql
-- 시간이 지남에 따라 IMDB 점수가 개선된 영화들을 찾아라
SELECT title, imdb_score
FROM (
    SELECT title, imdb_score,
           imdb_score - LAG(imdb_score) OVER (ORDER BY release_date) as score_diff
    FROM films
) as films_with_diff
WHERE score_diff > 0;
```

### 5.2 CTE 방식 (더 깔끔하고 읽기 쉬움)
```sql
-- 같은 결과를 CTE로 구현
WITH films_with_diff AS (
    SELECT title, imdb_score,
           imdb_score - LAG(imdb_score) OVER (ORDER BY release_date) as score_diff
    FROM films
)
SELECT title, imdb_score
FROM films_with_diff
WHERE score_diff > 0;
```

### 5.3 복잡한 CTE 예시
```sql
-- 단계별로 데이터 처리하기
WITH decade_films AS (
    -- 1단계: 연도별 그룹화
    SELECT title, 
           FLOOR(YEAR(release_date)/10)*10 as decade,
           imdb_score
    FROM films
),
decade_stats AS (
    -- 2단계: 10년대별 통계 계산
    SELECT decade,
           AVG(imdb_score) as avg_score,
           COUNT(*) as film_count
    FROM decade_films
    GROUP BY decade
)
-- 3단계: 최종 결과
SELECT decade, avg_score, film_count
FROM decade_stats
WHERE film_count >= 3
ORDER BY avg_score DESC;
```

## 6. 성능 최적화 팁

### 6.1 쿼리 실행 계획 확인
- EXPLAIN ANALYZE의 주요 용도:
    *   인덱스 효율성 확인
    *   풀 테이블 스캔 여부 확인
    *   조인 최적화 분석
    *   성능 병목 지점 식별
    
```sql
-- 쿼리가 어떻게 실행되는지 확인
EXPLAIN ANALYZE 
SELECT title, imdb_score 
FROM films 
WHERE YEAR(release_date) = 2010;
```

### 6.2 효율적인 쿼리 작성
```sql
-- 비효율적: 함수를 WHERE 조건에 사용
SELECT title FROM films WHERE YEAR(release_date) = 2010;

-- 효율적: 범위 조건 사용
SELECT title FROM films 
WHERE release_date >= '2010-01-01' 
AND release_date < '2011-01-01';
```

- 범위 조건이 더 나은 이유
  * 데이터베이스는 YEAR(), MONTH(), UPPER() 같은 함수 처리 시 인덱스를 사용하지 못합니다.
따라서 컬럼 순수 값을 비교하는 조건(BETWEEN, >=, <= 등)이 훨씬 효율적입니다.

## 7. 실전 학습 조언

### 7.1 단계별 접근법
```sql
-- 복잡한 문제를 단계별로 해결
-- 1단계: 기본 데이터 확인
SELECT * FROM films LIMIT 5;

-- 2단계: 필요한 열만 선택
SELECT title, release_date, imdb_score FROM films;

-- 3단계: 조건 추가
SELECT title, release_date, imdb_score 
FROM films 
WHERE imdb_score > 8.0;

-- 4단계: 정렬 추가
SELECT title, release_date, imdb_score 
FROM films 
WHERE imdb_score > 8.0
ORDER BY imdb_score DESC;
```

### 7.2 ChatGPT 활용법
- 복잡한 정규표현식이나 특수 함수 구문을 모를 때 활용
- "MySQL에서 문자열의 첫 번째 단어만 추출하는 방법" 같은 구체적 질문
- SQL 쿼리 최적화 조언 요청

### 7.3 데이터 탐색 쿼리
```sql
-- 테이블 구조 파악
DESCRIBE films;

-- 데이터 품질 확인
SELECT 
    COUNT(*) as total_rows,
    COUNT(title) as non_null_titles,
    COUNT(DISTINCT genre) as unique_genres,
    MIN(release_date) as earliest_film,
    MAX(release_date) as latest_film
FROM films;

-- 중복 데이터 찾기
SELECT title, COUNT(*)
FROM films
GROUP BY title
HAVING COUNT(*) > 1;
```

## 8. 체크리스트

**기초를 탄탄히 하기:**
- [ ] SELECT, FROM, WHERE 완전히 이해하기
- [ ] GROUP BY와 집계함수(COUNT, SUM, AVG) 익히기
- [ ] ORDER BY로 정렬하기

**중급 단계:**
- [ ] 다양한 JOIN 종류 이해하고 사용하기
- [ ] 기본적인 윈도우 함수 사용하기
- [ ] CTE로 복잡한 쿼리 정리하기

---

**💡 기억하세요:** 모든 문법을 외울 필요 없습니다. SQL의 기본 개념과 가능성을 이해하고, 필요할 때 문서나 AI 도구를 활용하여 정확한 구문을 찾는 것이 더 효율적입니다!

---

