---
title: 7차시 10:Swift2
layout: single
classes: wide
categories:
  - Swift
toc: true # 이 포스트에서 목차를 활성화
toc_sticky: true # 목차를 고정할지 여부 (선택 사항)
---

## 6. Function

### **6.1 함수의 기본 구조**
Swift에서 함수는 특정 작업을 수행하는 코드 블록입니다. 함수는 입력(매개변수)을 받아 처리하고, 결과를 반환할 수 있습니다.

1\. **기본 문법**
```swift
func functionName(parameterName: ParameterType) -> ReturnType {
    // 함수 본문
    return value
}
```

- `func`: 함수를 정의하기 위한 키워드.
- `functionName`: 함수의 이름.
- `parameterName: ParameterType`: 매개변수 이름과 타입.
- `ReturnType`: 반환값의 타입 (없으면 `Void` 또는 생략 가능).
- `return`: 반환값을 지정.

2\. **예시**
```swift
func greet(person: String) -> String {
    return "Hello, \(person)!"
}

let greeting = greet(person: "Alice")
print(greeting) // 출력: Hello, Alice!
```

### **6.2 매개변수와 반환값**
1\. **매개변수가 없는 함수**
매개변수가 없는 함수도 정의할 수 있습니다.
```swift
func sayHello() -> String {
    return "Hello, world!"
}

print(sayHello()) // 출력: Hello, world!
```

2\. **반환값이 없는 함수**
반환값이 없는 함수는 `Void`를 반환하거나 반환 타입을 생략합니다.
```swift
func sayGoodbye() {
    print("Goodbye!")
}

sayGoodbye() // 출력: Goodbye!
```

3\. **여러 매개변수와 반환값**
여러 매개변수를 받고, 여러 값을 반환할 수도 있습니다.
```swift
func add(_ a: Int, _ b: Int) -> Int {
    return a + b
}

let result = add(5, 3)
print(result) // 출력: 8
```

### **6.3 외부 매개변수 이름 (External Parameter Names)**
Swift에서는 함수 호출 시 매개변수 이름을 명확하게 표시할 수 있도록 외부 매개변수 이름을 사용할 수 있습니다.

1\. **예시**
```swift
func greet(person: String, from hometown: String) -> String {
    return "Hello \(person)! Glad you could visit from \(hometown)."
}

let message = greet(person: "Alice", from: "Seoul")
print(message) // 출력: Hello Alice! Glad you could visit from Seoul.
```

- `from`은 외부 매개변수 이름으로, 함수 호출 시 사용됩니다.

### **6.4 기본 매개변수 값 (Default Parameter Values)**
매개변수에 기본값을 설정할 수 있습니다. 기본값이 있는 매개변수는 호출 시 생략 가능합니다.

1\. **예시**
```swift
func multiply(_ a: Int, by b: Int = 2) -> Int {
    return a * b
}

let result1 = multiply(5) // b의 기본값인 2가 사용됨
print(result1) // 출력: 10

let result2 = multiply(5, by: 3) // b를 명시적으로 3으로 설정
print(result2) // 출력: 15
```

### **6.5 가변 매개변수 (Variadic Parameters)**
함수는 동일한 타입의 값을 여러 개 받을 수 있습니다. 이를 가변 매개변수라고 합니다.

1\. **예시**
```swift
func sum(_ numbers: Int...) -> Int {
    var total = 0
    for number in numbers {
        total += number
    }
    return total
}

let result = sum(1, 2, 3, 4, 5)
print(result) // 출력: 15
```

### **6.6 In-Out 매개변수**
함수 내부에서 매개변수의 값을 변경하고, 그 변경된 값을 함수 외부에서도 반영할 수 있습니다. 이를 위해 `inout` 키워드를 사용합니다.

1\. **예시**
```swift
func swapTwoInts(_ a: inout Int, _ b: inout Int) {
    let temporaryA = a
    a = b
    b = temporaryA
}

var x = 10
var y = 20
swapTwoInts(&x, &y)
print("x is now \(x), y is now \(y)") // 출력: x is now 20, y is now 10
```

- `&` 기호를 사용하여 변수를 전달해야 합니다.

### **6.7 함수 타입 (Function Types)**
함수 자체도 타입으로 취급될 수 있습니다. 함수 타입은 매개변수 타입과 반환 타입으로 구성됩니다.

1\. **예시**
```swift
func add(_ a: Int, _ b: Int) -> Int {
    return a + b
}

func subtract(_ a: Int, _ b: Int) -> Int {
    return a - b
}

// 함수 타입 선언
var mathFunction: (Int, Int) -> Int = add

print(mathFunction(5, 3)) // 출력: 8

mathFunction = subtract
print(mathFunction(5, 3)) // 출력: 2
```

### **6.8 중첩 함수 (Nested Functions)**
함수 내부에 다른 함수를 정의할 수 있습니다. 중첩 함수는 외부 함수 내에서만 사용 가능합니다.

1\. **예시**
```swift
func chooseStepFunction(backward: Bool) -> (Int) -> Int {
    func stepForward(input: Int) -> Int { return input + 1 }
    func stepBackward(input: Int) -> Int { return input - 1 }
    
    return backward ? stepBackward : stepForward
}

let moveNearerToZero = chooseStepFunction(backward: true)
print(moveNearerToZero(5)) // 출력: 4
```

### **6.9 클로저와 함수의 차이**
함수는 명명된 코드 블록이고, 클로저는 익명의 코드 블록입니다. 클로저는 함수와 유사하지만 더 간결하게 작성할 수 있습니다.

1\. **클로저 예시**
```swift
let multiply = { (a: Int, b: Int) -> Int in
    return a * b
}

print(multiply(3, 4)) // 출력: 12
```

### **6.10 요약**
Swift의 함수는 강력하고 유연한 도구입니다. 다음은 핵심 요점입니다:
1. 매개변수와 반환값을 자유롭게 정의할 수 있음.
2. 외부 매개변수 이름, 기본값, 가변 매개변수 등을 지원.
3. `inout` 매개변수로 값을 수정 가능.
4. 함수 자체도 타입으로 사용 가능.
5. 중첩 함수와 클로저를 활용해 코드를 간결하게 작성 가능.

## 7. Closure

### **7.1 클로저란?**
클로저는 독립적으로 실행 가능한 코드 블록으로, 변수나 상수에 저장하거나 함수의 매개변수로 전달할 수 있습니다. 클로저는 다음과 같은 특징을 가집니다:
- **자체적인 문맥을 캡처**: 클로저는 자신이 정의된 주변 문맥(context)의 값을 참조할 수 있습니다.
- **간결한 문법**: 필요에 따라 문법을 축약하여 표현할 수 있습니다.
- **함수와 유사**: 클로저는 익명 함수(anonymous function)로도 볼 수 있습니다.

### **7.2 클로저의 기본 구조**
Swift에서 클로저의 일반적인 형식은 다음과 같습니다:

```swift
{ (parameters) -> ReturnType in
    statements
}
```

- **parameters**: 클로저가 받는 입력 매개변수 목록입니다.
- **ReturnType**: 클로저가 반환하는 값의 타입입니다.
- **in**: 매개변수와 반환 타입을 구분하며, 이후에 실행될 코드를 나타냅니다.

예시:
```swift
let sayHello: (String) -> String = { (name: String) -> String in
    return "Hello, \(name)!"
}

print(sayHello("Alice")) // 출력: Hello, Alice!
```

### **7.3 클로저의 종류**
Swift에서는 세 가지 유형의 클로저를 제공합니다:

1\. **전역 함수(Global Function)**
매개변수가 있고 반환값이 있는 일반적인 함수입니다. 클로저와 달리 이름이 있으며 외부 문맥을 캡처하지 않습니다.

```swift
func addTwoNumbers(a: Int, b: Int) -> Int {
    return a + b
}
```

2\. **중첩 함수(Nested Function)**
다른 함수 내부에 정의된 함수입니다. 외부 함수의 변수를 캡처할 수 있습니다.

```swift
func makeIncrementer() -> (Int) -> Int {
    var runningTotal = 0
    func incrementer(amount: Int) -> Int {
        runningTotal += amount
        return runningTotal
    }
    return incrementer
}

let incrementByTen = makeIncrementer()
print(incrementByTen(10)) // 출력: 10
print(incrementByTen(5))  // 출력: 15
```

3\. **클로저 표현식(Closure Expression)**
가장 일반적인 클로저 형태로, 간결하게 작성할 수 있습니다.

```swift
let multiply = { (a: Int, b: Int) -> Int in
    return a * b
}

print(multiply(3, 4)) // 출력: 12
```

### **7.4 클로저의 문법 축약**
Swift는 클로저를 더욱 간결하게 작성할 수 있도록 다양한 문법적 편의를 제공합니다.

1\. **타입 추론(Type Inference)**
매개변수와 반환 타입을 명시적으로 작성하지 않아도 컴파일러가 자동으로 추론합니다.

```swift
let divide = { (a: Int, b: Int) in
    return a / b
}

print(divide(10, 2)) // 출력: 5
```

2\. **단축 인자 이름(Shorthand Argument Names)**
매개변수 이름 대신 `$0`, `$1` 등의 단축 인자 이름을 사용할 수 있습니다.

```swift
let sum = { $0 + $1 }
print(sum(3, 5)) // 출력: 8
```

3\. **암시적 반환(Implicit Returns)**
클로저의 본문이 한 줄로 구성되어 있다면 `return` 키워드를 생략할 수 있습니다.

```swift
let greet = { "Hello, \($0)!" }
print(greet("Bob")) // 출력: Hello, Bob!
```

### **7.5 클로저의 캡처링(Capturing Values)**
클로저는 자신이 정의된 문맥의 값을 캡처하여 사용할 수 있습니다. 이를 통해 클로저는 외부 변수를 참조하거나 수정할 수 있습니다.

```swift
func makeCounter() -> () -> Int {
    var count = 0
    let increment: () -> Int = {
        count += 1
        return count
    }
    return increment
}

let counter = makeCounter()
print(counter()) // 출력: 1
print(counter()) // 출력: 2
```

### **7.6 클로저의 활용 예시**
클로저는 다양한 상황에서 유용하게 사용됩니다. 대표적인 예시는 다음과 같습니다:

1\. **정렬(Sorting)**
배열을 정렬할 때 클로저를 사용할 수 있습니다.

```swift
let numbers = [5, 2, 8, 1]
let sortedNumbers = numbers.sorted { $0 < $1 }
print(sortedNumbers) // 출력: [1, 2, 5, 8]
```

2\. **비동기 작업(Asynchronous Operations)**
네트워크 요청이나 타이머와 같은 비동기 작업에서 클로저를 활용할 수 있습니다.

```swift
DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
    print("This will be printed after 2 seconds.")
}
```

### **7.7 클로저의 주의사항**
- **순환 참조(Circular Reference)**: 클로저가 자신을 포함하는 객체를 강하게 참조하면 메모리 누수가 발생할 수 있습니다. 이를 방지하기 위해 `[weak self]` 또는 `[unowned self]`를 사용합니다.
  
```swift
class ViewController {
    var closure: (() -> Void)?
    
    func setupClosure() {
        closure = { [weak self] in
            self?.doSomething()
        }
    }
    
    func doSomething() {
        print("Doing something...")
    }
}
```

### **7.8 요약**
- 클로저는 독립적으로 실행 가능한 코드 블록으로, 함수보다 더 유연하고 간결하게 사용할 수 있습니다.
- 클로저는 매개변수, 반환 타입, 본문으로 구성되며, 필요에 따라 문법을 축약할 수 있습니다.
- 클로저는 외부 문맥의 값을 캡처할 수 있으며, 이를 통해 상태를 유지하거나 비동기 작업을 처리할 수 있습니다.
- 순환 참조를 피하기 위해 `[weak self]` 또는 `[unowned self]`를 적절히 사용해야 합니다.

## 8. Enumeration

### **8.1 Enumerations(열거형)란?**
- **정의**: 열거형은 관련된 값들의 그룹을 하나의 타입으로 정의하는 방법입니다.
- **목적**: 코드의 가독성과 안전성을 높이며, 특정한 값만 허용하도록 제한할 수 있습니다.
- **예시**:
  ```swift
  enum CompassPoint {
      case north
      case south
      case east
      case west
  }
  ```
  위 코드는 네 가지 방향(`north`, `south`, `east`, `west`)을 정의한 열거형입니다.

### **8.2 열거형의 기본 사용법**
1\.**열거형 선언 및 사용**
- 열거형은 `enum` 키워드로 선언하며, 각 케이스는 `case` 키워드로 정의합니다.
- 사용 시 변수나 상수에 값을 할당할 수 있습니다.
  ```swift
  var direction: CompassPoint = .north
  print(direction) // 출력: north
  ```

2\.**다중 케이스 정의**
- 여러 케이스를 한 줄에 나열할 수 있습니다.
  ```swift
  enum Planet {
      case mercury, venus, earth, mars, jupiter, saturn, uranus, neptune
  }
  ```

3\.**Switch 문과 함께 사용**
- 열거형은 `switch` 문과 함께 사용하면 모든 케이스를 처리할 수 있습니다.
  ```swift
  switch direction {
  case .north:
      print("북쪽으로 이동")
  case .south:
      print("남쪽으로 이동")
  case .east:
      print("동쪽으로 이동")
  case .west:
      print("서쪽으로 이동")
  }
  ```

### **8.3 열거형의 고급 기능**
1\.**Associated Values(연관 값)**
- 각 케이스에 추가적인 데이터를 저장할 수 있습니다.
- 예시:
  ```swift
  enum Barcode {
      case upc(Int, Int, Int, Int)
      case qrCode(String)
  }

  var productBarcode = Barcode.upc(8, 85909, 51226, 3)
  productBarcode = .qrCode("ABCD1234")

  switch productBarcode {
  case .upc(let numberSystem, let manufacturer, let product, let check):
      print("UPC: \(numberSystem), \(manufacturer), \(product), \(check)")
  case .qrCode(let code):
      print("QR Code: \(code)")
  }
  ```

2\.**Raw Values(원시 값)**
- 열거형의 각 케이스에 기본값(원시 값)을 할당할 수 있습니다.
- 원시 값은 자동으로 증가하거나 직접 지정할 수 있습니다.
  ```swift
  enum ASCIIControlCharacter: Character {
      case tab = "\t"
      case lineFeed = "\n"
      case carriageReturn = "\r"
  }

  let newline = ASCIIControlCharacter.lineFeed.rawValue
  print(newline) // 출력: \n
  ```

3\.**Recursive Enumerations(재귀 열거형)**
- 열거형 내부에서 자기 자신을 참조할 수 있는 특별한 형태입니다.
- 재귀 열거형은 `indirect` 키워드를 사용합니다.
  ```swift
  indirect enum ArithmeticExpression {
      case number(Int)
      case addition(ArithmeticExpression, ArithmeticExpression)
      case multiplication(ArithmeticExpression, ArithmeticExpression)
  }

  let five = ArithmeticExpression.number(5)
  let four = ArithmeticExpression.number(4)
  let sum = ArithmeticExpression.addition(five, four)
  ```

### **8.4 열거형의 장점**
1. **타입 안전성**: 잘못된 값을 사용하지 않도록 보장합니다.
2. **코드 가독성**: 의미 있는 이름을 사용하여 코드를 이해하기 쉽게 만듭니다.
3. **유지보수 용이성**: 새로운 케이스를 추가하거나 수정하기 쉽습니다.

### **8.5 실전 예제**
아래는 열거형을 활용한 간단한 예제입니다.
```swift
enum TrafficLight {
    case red, yellow, green
}

func handleTrafficLight(_ light: TrafficLight) {
    switch light {
    case .red:
        print("정지하세요.")
    case .yellow:
        print("준비하세요.")
    case .green:
        print("출발하세요.")
    }
}

let currentLight = TrafficLight.red
handleTrafficLight(currentLight) // 출력: 정지하세요.
```

## 9.**Class and Structure**

### **9.1 클래스와 구조체의 정의**
- **구조체(Structure):** 값 타입(Value Type)으로 동작하며, 데이터와 관련된 메서드를 포함할 수 있습니다.
- **클래스(Class):** 참조 타입(Reference Type)으로 동작하며, 상속(Inheritance)과 같은 객체 지향 프로그래밍의 특성을 지원합니다.

1\.**정의 방법**
```swift
struct SomeStructure {
    // 구조체의 속성과 메서드
}

class SomeClass {
    // 클래스의 속성과 메서드
}
```

### **9.2 클래스와 구조체의 공통점**
클래스와 구조체는 다음과 같은 공통점을 가지고 있습니다:
1. **속성(Properties):** 값을 저장하거나 계산할 수 있습니다.
   ```swift
   struct Point {
       var x: Int
       var y: Int
   }

   class Rectangle {
       var width: Int
       var height: Int
       init(width: Int, height: Int) {
           self.width = width
           self.height = height
       }
   }
   ```

2. **메서드(Methods):** 인스턴스나 타입과 관련된 동작을 정의할 수 있습니다.
   ```swift
   struct Point {
       var x: Int
       var y: Int
       func description() -> String {
           return "Point(x: \(x), y: \(y))"
       }
   }
   ```

3. **초기화(Initializers):** 초기 상태를 설정하기 위한 생성자를 정의할 수 있습니다.
   ```swift
   struct Size {
       var width: Double
       var height: Double
       init(width: Double, height: Double) {
           self.width = width
           self.height = height
       }
   }
   ```

4. **확장(Extensions):** 기존 타입에 새로운 기능을 추가할 수 있습니다.
   ```swift
   extension Point {
       func moveBy(x deltaX: Int, y deltaY: Int) {
           x += deltaX
           y += deltaY
       }
   }
   ```

5. **프로토콜 준수(Protocol Conformance):** 특정 프로토콜을 채택하여 요구사항을 충족할 수 있습니다.
   ```swift
   protocol Drawable {
       func draw()
   }

   struct Circle: Drawable {
       func draw() {
           print("Drawing a circle")
       }
   }
   ```

### **9.3 클래스와 구조체의 차이점**

| **특징**                | **구조체(Struct)**                           | **클래스(Class)**                          |
|-------------------------|---------------------------------------------|-------------------------------------------|
| **타입**               | 값 타입(Value Type)                        | 참조 타입(Reference Type)                 |
| **상속**               | 불가능                                     | 가능                                      |
| **디이니셜라이저**     | 없음                                       | 사용 가능(deinit)                         |
| **복사 동작**          | 복사 시 새로운 인스턴스 생성               | 참조만 전달                              |
| **변경 가능성(Mutability)** | `var`로 선언된 경우 변경 가능              | 항상 변경 가능                            |

1\. **예제 코드**
```swift
// 구조체: 값 타입
struct Resolution {
    var width: Int
    var height: Int
}

let hd = Resolution(width: 1920, height: 1080)
var cinema = hd
cinema.width = 2048 // cinema의 width만 변경됨, hd는 변경되지 않음

// 클래스: 참조 타입
class VideoMode {
    var resolution = Resolution(width: 1920, height: 1080)
    var interlaced = false
}

let someVideoMode = VideoMode()
let anotherVideoMode = someVideoMode
anotherVideoMode.interlaced = true // someVideoMode의 interlaced도 변경됨
```

### **9.4 값 타입 vs 참조 타입**
- **값 타입(Struct):** 변수나 상수에 할당하면 데이터가 복사됩니다. 즉, 원본 데이터는 영향을 받지 않습니다.
- **참조 타입(Class):** 변수나 상수에 할당하면 참조만 전달됩니다. 따라서 한쪽에서 변경하면 다른 쪽에도 영향을 미칩니다.

1\.**값 타입의 예시**
```swift
struct Point {
    var x: Int
    var y: Int
}

var point1 = Point(x: 10, y: 20)
var point2 = point1
point2.x = 30

print(point1.x) // 출력: 10 (point1은 변경되지 않음)
print(point2.x) // 출력: 30
```

2\.**참조 타입의 예시**
```swift
class Person {
    var name: String
    init(name: String) {
        self.name = name
    }
}

let person1 = Person(name: "Alice")
let person2 = person1
person2.name = "Bob"

print(person1.name) // 출력: Bob (person1과 person2는 동일한 인스턴스를 참조)
print(person2.name) // 출력: Bob
```

### **9.5 클래스의 고급 기능**
1. **상속(Inheritance):** 클래스는 다른 클래스로부터 속성과 메서드를 상속받을 수 있습니다.
   ```swift
   class Animal {
       func makeSound() {
           print("Some sound")
       }
   }

   class Dog: Animal {
       override func makeSound() {
           print("Bark")
       }
   }
   ```

2. **디이니셜라이저(deinit):** 클래스 인스턴스가 해제될 때 실행되는 코드를 정의할 수 있습니다.
   ```swift
   class File {
       var name: String
       init(name: String) {
           self.name = name
       }
       deinit {
           print("\(name) is being deallocated")
       }
   }
   ```

3. **참조 카운팅:** 클래스는 자동 참조 카운팅(ARC)을 통해 메모리를 관리합니다.

### **9.6 언제 구조체를 사용하고, 언제 클래스를 사용할까?**
- **구조체 사용 시점:**
  - 단순한 데이터 모델링이 필요한 경우.
  - 값 타입의 복사 동작이 적합한 경우.
  - 상속이 필요하지 않은 경우.

- **클래스 사용 시점:**
  - 객체 간 공유가 필요한 경우.
  - 상속을 통해 기능을 확장해야 하는 경우.
  - 디이니셜라이저가 필요한 경우.

## 10. **Properties**

Swift에서 속성은 특정 타입(클래스, 구조체, 열거형)과 연관된 값을 나타냅니다. 속성은 두 가지 주요 카테고리로 나뉩니다:
1. **Stored Properties (저장 속성)**  
   - 상수(`let`) 또는 변수(`var`) 형태로 값을 저장합니다.
   - 주로 클래스와 구조체에서 사용됩니다.

2. **Computed Properties (계산 속성)**  
   - 값 자체를 저장하지 않고, 다른 속성이나 값을 기반으로 계산된 결과를 제공합니다.
   - 클래스, 구조체, 열거형에서 모두 사용 가능합니다.

### **10.1 Stored Properties (저장 속성)**

저장 속성은 인스턴스가 생성될 때 메모리에 값을 저장하는 속성입니다.  
- `var`: 가변적인 값을 저장할 수 있음.
- `let`: 불변적인 값을 저장함.

1\.예시:
```swift
struct FixedLengthRange {
    var firstValue: Int // 가변적
    let length: Int     // 불변적
}

var range = FixedLengthRange(firstValue: 0, length: 3)
range.firstValue = 5 // 변경 가능
// range.length = 4  // 에러: length는 불변적임
```

2\.Lazy Stored Properties
- 초기화가 지연되는 속성으로, 처음 접근되기 전까지는 초기화되지 않습니다.
- 키워드 `lazy`를 사용하여 선언합니다.

3\.예시:
```swift
class DataImporter {
    var fileName = "data.txt"
}

class DataManager {
    lazy var importer = DataImporter() // 필요할 때 초기화됨
    var data: [String] = []
}

let manager = DataManager()
manager.data.append("Some data")
// importer는 아직 초기화되지 않음
print(manager.importer.fileName) // 여기서야 importer가 초기화됨
```

### **10.2 Computed Properties (계산 속성)**

계산 속성은 값을 저장하지 않고, 다른 속성을 기반으로 값을 계산하거나 설정합니다.  
- `get`: 값을 반환하는 코드 블록.
- `set`: 값을 설정하는 코드 블록 (옵션).

1\.예시:
```swift
struct Point {
    var x = 0.0, y = 0.0
}

struct Size {
    var width = 0.0, height = 0.0
}

struct Rect {
    var origin = Point()
    var size = Size()
    
    // 계산 속성: 넓이를 계산
    var area: Double {
        return size.width * size.height
    }
    
    // 읽기/쓰기 가능한 계산 속성
    var center: Point {
        get {
            let centerX = origin.x + (size.width / 2)
            let centerY = origin.y + (size.height / 2)
            return Point(x: centerX, y: centerY)
        }
        set(newCenter) {
            origin.x = newCenter.x - (size.width / 2)
            origin.y = newCenter.y - (size.height / 2)
        }
    }
}

var square = Rect(origin: Point(x: 0.0, y: 0.0), size: Size(width: 10.0, height: 10.0))
print(square.area) // 출력: 100.0
square.center = Point(x: 15.0, y: 15.0)
print(square.origin) // 출력: x: 10.0, y: 10.0
```

### **10.3 Property Observers**

속성의 값이 변경될 때 추가 작업을 수행할 수 있는 기능입니다.  
- `willSet`: 값이 변경되기 직전에 호출.
- `didSet`: 값이 변경된 직후에 호출.

1\.예시:
```swift
class StepCounter {
    var totalSteps: Int = 0 {
        willSet(newTotalSteps) {
            print("About to set totalSteps to \(newTotalSteps)")
        }
        didSet {
            if totalSteps > oldValue {
                print("Added \(totalSteps - oldValue) steps")
            }
        }
    }
}

let counter = StepCounter()
counter.totalSteps = 200
// 출력:
// About to set totalSteps to 200
// Added 200 steps
```

### **10.4 Type Properties**

인스턴스가 아닌 타입 자체에 속하는 속성입니다.  
- `static`: 구조체와 열거형에서 사용.
- `class`: 클래스에서 사용 (상속 가능).

1\.예시:
```swift
struct SomeStructure {
    static var storedTypeProperty = "Some value."
    static var computedTypeProperty: Int {
        return 42
    }
}

class SomeClass {
    static var storedTypeProperty = "Some value."
    class var computedTypeProperty: Int {
        return 42
    }
}

print(SomeStructure.storedTypeProperty) // 출력: Some value.
print(SomeClass.computedTypeProperty)   // 출력: 42
```

### **10.5 Property Wrappers**

속성의 동작을 캡슐화하는 방법으로, 재사용 가능한 속성 동작을 정의할 수 있습니다.  
`@propertyWrapper` 어노테이션을 사용하여 정의합니다.

1\.예시:
```swift
@propertyWrapper
struct TwelveOrLess {
    private var number = 0
    var wrappedValue: Int {
        get { return number }
        set { number = min(newValue, 12) }
    }
}

struct SmallRectangle {
    @TwelveOrLess var height: Int
    @TwelveOrLess var width: Int
}

var rectangle = SmallRectangle()
rectangle.height = 15
print(rectangle.height) // 출력: 12
```

### **10.6 정리**
Swift의 속성(Properties)은 데이터를 저장하거나 계산하는 다양한 방식을 제공하며, 이를 통해 유연하고 강력한 코드를 작성할 수 있습니다. 핵심 개념은 다음과 같습니다:
1. **Stored Properties**: 값을 직접 저장.
2. **Computed Properties**: 값을 계산하여 제공.
3. **Property Observers**: 값 변경 시 추가 작업 수행.
4. **Type Properties**: 타입 자체에 속하는 속성.
5. **Property Wrappers**: 속성 동작을 캡슐화.


## 11. Methods

### **11.1 Instance Methods (인스턴스 메서드)**
- **정의**: 특정 타입의 인스턴스에서 호출되는 메서드입니다.
- **특징**:
  - `func` 키워드를 사용하여 정의합니다.
  - 인스턴스 속성 및 기타 인스턴스 메서드에 접근 가능합니다.
  - `self` 키워드를 통해 현재 인스턴스를 참조할 수 있습니다.
- **예시**:
  ```swift
  struct Counter {
      var count = 0
      
      func increment() {
          self.count += 1 // self를 사용하여 인스턴스 속성 접근
      }
      
      func reset() {
          count = 0
      }
  }

  var counter = Counter()
  counter.increment()
  print(counter.count) // 출력: 1
  ```

### **11.2 Type Methods (타입 메서드)**
- **정의**: 특정 타입 자체에서 호출되는 메서드입니다.
- **특징**:
  - `static` 키워드를 사용하여 정의합니다.
  - 클래스에서는 `class` 키워드를 사용할 수도 있습니다.
  - 인스턴스 속성에는 접근할 수 없으며, 타입 속성만 사용 가능합니다.
- **예시**:
  ```swift
  struct MathUtility {
      static func add(_ a: Int, _ b: Int) -> Int {
          return a + b
      }
  }

  let result = MathUtility.add(5, 3)
  print(result) // 출력: 8
  ```

### **11.3 Mutating Methods (변경 가능한 메서드)**

- **정의**: 구조체(struct)나 열거형(enum)의 인스턴스 속성을 변경하는 메서드입니다.
- **특징**:
  - `mutating` 키워드를 사용하여 정의합니다.
  - 클래스(class)에서는 필요하지 않습니다(클래스는 기본적으로 변경 가능).
- **예시**:
  ```swift
  struct Point {
      var x = 0.0, y = 0.0
      
      mutating func moveBy(x deltaX: Double, y deltaY: Double) {
          x += deltaX
          y += deltaY
      }
  }

  var point = Point(x: 1.0, y: 1.0)
  point.moveBy(x: 2.0, y: 3.0)
  print("(\(point.x), \(point.y))") // 출력: (3.0, 4.0)
  ```

### **11.4 Self Property**
- **정의**: 모든 인스턴스 메서드는 암시적으로 `self` 프로퍼티를 가지고 있습니다.
- **사용 사례**:
  - 메서드 내에서 현재 인스턴스를 참조하거나 반환할 때 사용합니다.
  - 이름 충돌이 발생할 경우 명확히 구분하기 위해 사용됩니다.
- **예시**:
  ```swift
  struct Person {
      var name: String
      
      func getSelf() -> Self {
          return self // 현재 인스턴스 반환
      }
  }

  let person = Person(name: "John")
  let samePerson = person.getSelf()
  print(samePerson.name) // 출력: John
  ```

### **11.5 Methods in Enumerations and Structures**
- **열거형과 구조체에서도 메서드를 정의할 수 있습니다.**
- **예시**:
  ```swift
  enum TriStateSwitch {
      case off, low, high
      
      mutating func next() {
          switch self {
          case .off:
              self = .low
          case .low:
              self = .high
          case .high:
              self = .off
          }
      }
  }

  var switchState = TriStateSwitch.off
  switchState.next()
  print(switchState) // 출력: low
  ```

### **11.6 Key Points to Remember**

1. **Instance vs Type Methods**:
   - 인스턴스 메서드는 특정 인스턴스에 대해 동작하며, `self`를 통해 인스턴스 속성에 접근할 수 있습니다.
   - 타입 메서드는 타입 자체에서 호출되며, `static` 또는 `class` 키워드로 정의됩니다.

2. **Mutating Methods**:
   - 구조체나 열거형에서 인스턴스 속성을 변경하려면 `mutating` 키워드를 사용해야 합니다.

3. **Self Property**:
   - `self`는 현재 인스턴스를 나타내며, 이름 충돌을 방지하거나 명확성을 위해 사용됩니다.

4. **Enumerations and Structures**:
   - 열거형과 구조체에서도 메서드를 정의할 수 있으며, 이를 통해 상태 변경이나 로직 처리를 구현할 수 있습니다.


