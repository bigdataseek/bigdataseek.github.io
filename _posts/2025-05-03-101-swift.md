---
title: 7차시 10:Swift
layout: single
classes: wide
categories:
  - Swift
toc: true # 이 포스트에서 목차를 활성화
toc_sticky: true # 목차를 고정할지 여부 (선택 사항)
---

## 1. Swift Basic

### **1.1 Constants and Variables (상수와 변수)**
- **상수 (Constants):**
  - `let` 키워드를 사용하여 선언.
  - 한 번 값이 할당되면 변경할 수 없음.
  - 예: `let maximumNumberOfLoginAttempts = 10`
  
- **변수 (Variables):**
  - `var` 키워드를 사용하여 선언.
  - 값을 여러 번 변경할 수 있음.
  - 예: `var currentLoginAttempt = 0`

- **네이밍 규칙:**
  - 상수와 변수 이름은 문자, 숫자, 밑줄(`_`)을 포함할 수 있지만, 숫자로 시작할 수 없음.
  - 특수문자나 공백은 사용 불가.
  - 대소문자를 구분함.

### **1.2 Type Annotations (타입 어노테이션)**
- 변수 또는 상수의 데이터 타입을 명시적으로 지정.
- 형식: `변수명: 타입`
- 예:
  ```swift
  var welcomeMessage: String
  welcomeMessage = "Hello, world!"
  ```

- Swift는 타입 추론(Type Inference)을 지원하므로, 초기값을 제공하면 타입 어노테이션을 생략할 수 있음.

### **1.3 Numeric Types (숫자 타입)**
- **정수형 (Integers):**
  - `Int`: 플랫폼에 따라 32비트 또는 64비트 정수.
  - `UInt`: 부호 없는 정수.

- **부동소수점형 (Floating-Point Numbers):**
  - `Double`: 64비트 부동소수점 숫자.
  - `Float`: 32비트 부동소수점 숫자.

- **산술 연산:**
  - 기본 연산자: `+`, `-`, `*`, `/`, `%`.
  - 예: 
    ```swift
    let sum = 1 + 2
    let difference = 5 - 3
    ```

- **타입 변환:**
  - 다른 타입 간의 연산은 명시적 타입 변환이 필요.
  - 예: 
    ```swift
    let integerNumber: Int = 5
    let doubleNumber: Double = 3.14
    let result = Double(integerNumber) + doubleNumber
    ```

### **1.4 Booleans (불리언)**
- `Bool` 타입으로 참(True) 또는 거짓(False) 값을 표현.
- 예:
  ```swift
  let isAvailable: Bool = true
  ```

- 조건문에서 자주 사용됨.
  ```swift
  if isAvailable {
      print("Service is available.")
  } else {
      print("Service is not available.")
  }
  ```

### **1.5 Tuples (튜플)**
- 여러 값을 하나의 그룹으로 묶어서 표현.
- 튜플 내 각 값은 서로 다른 타입을 가질 수 있음.
- 예:
  ```swift
  let http404Error = (404, "Not Found")
  ```

- 튜플의 값 접근 방법:
  - 인덱스로 접근: `http404Error.0`, `http404Error.1`
  - 이름 지정: 
    ```swift
    let http200Status = (statusCode: 200, description: "OK")
    print(http200Status.statusCode)
    ```

- 튜플 분해:
  ```swift
  let (statusCode, statusMessage) = http404Error
  print("The status code is \(statusCode)")
  ```

### **1.6 Optionals (옵셔널)**
- 값이 있을 수도 있고 없을 수도 있는 경우를 표현.
- `nil`로 값이 없음을 나타냄.
- 예:
  ```swift
  var optionalString: String? = "Hello"
  optionalString = nil
  ```

- **옵셔널 바인딩 (Optional Binding):**
  - `if let` 또는 `guard let`을 사용하여 안전하게 옵셔널 값을 확인.
  - 예:
    ```swift
    if let unwrappedString = optionalString {
        print(unwrappedString)
    } else {
        print("optionalString is nil")
    }
    ```

- **강제 언래핑 (Forced Unwrapping):**
  - `!`를 사용하여 옵셔널 값을 강제로 언래핑.
  - 값이 없으면 런타임 에러 발생.

- **Nil-Coalescing Operator (`??`):**
  - 옵셔널 값이 `nil`일 경우 기본값을 제공.
  - 예:
    ```swift
    let defaultString = optionalString ?? "Default Value"
    ```
- **새로운 문법: 암시적 이름 사용**
  - Swift 5.7부터는 더 간단한 방식으로 옵셔널 바인딩을 작성할 수 있습니다. 새로운 상수 이름을 명시적으로 지정하지 않고, 원래 옵셔널 변수의 이름을 그대로 사용할 수 있습니다.
  ```
  let myNumber = Int(possibleNumber)
  if let myNumber {
      print("My number is \(myNumber)")
  }
  ```

### **1.7 Error Handling (에러 처리)**
- Swift는 에러를 던지고(throw), 잡고(catch), 전파하고(propagate) 처리할 수 있는 메커니즘 제공.
- `throws` 키워드를 사용하여 함수에서 에러를 던짐.
- 예:
  ```swift
  enum PrinterError: Error {
      case outOfPaper
      case noToner
  }

  func send(job: Int, toPrinter printerName: String) throws -> String {
      if printerName == "Never Has Toner" {
          throw PrinterError.noToner
      }
      return "Job sent"
  }
  ```

- **do-catch 구문:**
  ```swift
  do {
      let printerResponse = try send(job: 1040, toPrinter: "Never Has Toner")
      print(printerResponse)
  } catch {
      print(error)
  }
  ```

### **1.8 Assertions and Preconditions (단언 및 전제 조건)**
- 프로그램 실행 중 특정 조건이 충족되지 않으면 중단.
- **Assertion:**
  - 디버그 모드에서만 작동.
  - 예:
    ```swift
    let age = -3
    assert(age >= 0, "Age cannot be less than zero.")
    ```

- **Precondition:**
  - 릴리즈 모드에서도 작동.
  - 예:
    ```swift
    precondition(index > 0, "Index must be greater than zero.")
    ```

## 2. Swift Operator

### **2.1 Terminology (용어 설명)**
- **Operand (피연산자):**
  - 연산자가 작동하는 값.
  - 예: `1 + 2`에서 `1`과 `2`가 피연산자.

- **Unary Operator (단항 연산자):**
  - 하나의 피연산자에만 작동.
  - 예: `-a` (음수 변환), `!b` (논리 NOT).

- **Binary Operator (이항 연산자):**
  - 두 개의 피연산자에 작동.
  - 예: `a + b`, `c * d`.

- **Ternary Operator (삼항 연산자):**
  - 세 개의 피연산자에 작동.
  - Swift에서는 삼항 조건 연산자(`? :`)만 존재.

---

### **2.2 Assignment Operator (할당 연산자)**
- 변수에 값을 할당하는 연산자 (`=`).
- 예:
  ```swift
  let b = 10
  var a = 5
  a = b // a의 값은 이제 10
  ```

- **주의사항:**
  - Swift의 할당 연산자는 다른 언어와 달리 표현식으로 평가되지 않음.
  - 예: `if x = y`와 같은 코드는 에러 발생.

---

### **2.3 Arithmetic Operators (산술 연산자)**
- 기본적인 수학 연산을 수행.
- **주요 연산자:**
  - `+`: 덧셈
  - `-`: 뺄셈
  - `*`: 곱셈
  - `/`: 나눗셈
  - `%`: 나머지(모듈러)

- 예:
  ```swift
  let sum = 1 + 2       // 3
  let difference = 5 - 3 // 2
  let product = 2 * 3    // 6
  let quotient = 10 / 3  // 3
  let remainder = 10 % 3 // 1
  ```

- **부동소수점 연산:**
  - 부동소수점 숫자에서도 동일하게 작동.
  - 예: `8.0 / 2.5` → `3.2`

---

### **2.4 Compound Assignment Operators (복합 할당 연산자)**
- 산술 연산과 할당 연산을 결합.
- **형식:** `변수 연산자= 값`
- 예:
  ```swift
  var a = 1
  a += 2 // a = a + 2 → 결과: 3
  a -= 1 // a = a - 1 → 결과: 2
  a *= 3 // a = a * 3 → 결과: 6
  a /= 2 // a = a / 2 → 결과: 3
  ```

---

### **2.5 Comparison Operators (비교 연산자)**
- 두 값을 비교하여 `true` 또는 `false`를 반환.
- **주요 연산자:**
  - `==`: 같음
  - `!=`: 같지 않음
  - `>`: 초과
  - `<`: 미만
  - `>=`: 이상
  - `<=`: 이하

- 예:
  ```swift
  let isEqual = (1 == 1)      // true
  let isNotEqual = (1 != 2)   // true
  let isGreater = (5 > 3)     // true
  ```

- **튜플 비교:**
  - 튜플도 비교 가능하며, 왼쪽부터 순서대로 비교.
  - 예:
    ```swift
    (1, "zebra") < (2, "apple") // true (첫 번째 요소 비교)
    (3, "apple") < (3, "bird")  // true (두 번째 요소 비교)
    ```

---

### **2.6 Ternary Conditional Operator (삼항 조건 연산자)**
- 조건에 따라 두 가지 값 중 하나를 선택.
- **형식:** `조건 ? 값1 : 값2`
- 예:
  ```swift
  let contentHeight = 40
  let hasHeader = true
  let rowHeight = contentHeight + (hasHeader ? 50 : 20)
  // hasHeader가 true이므로 rowHeight는 90
  ```

---

### **2.7 Nil-Coalescing Operator (Nil 병합 연산자)**
- 옵셔널 값이 `nil`인지 확인하고, `nil`일 경우 기본값을 제공.
- **형식:** `옵셔널 ?? 기본값`
- 예:
  ```swift
  let defaultColorName = "red"
  var userDefinedColorName: String? = nil
  let colorNameToUse = userDefinedColorName ?? defaultColorName
  // userDefinedColorName이 nil이므로 colorNameToUse는 "red"
  ```

---

### **2.8 Range Operators (범위 연산자)**
- 일정 범위의 값을 표현.
- **주요 연산자:**
  - **Closed Range (`...`):** 시작값과 끝값 모두 포함.
    - 예: `1...5` → 1, 2, 3, 4, 5
  - **Half-Open Range (`..<`):** 시작값 포함, 끝값 미포함.
    - 예: `1..<5` → 1, 2, 3, 4

- **One-Sided Ranges (한쪽 방향 범위):**
  - 시작값이나 끝값 중 하나만 지정.
  - 예:
    ```swift
    let names = ["Anna", "Alex", "Brian", "Jack"]
    let firstTwo = names[..<2] // ["Anna", "Alex"]
    let lastTwo = names[2...]  // ["Brian", "Jack"]
    ```

---

### **2.9 Logical Operators (논리 연산자)**
- 논리적 조건을 평가.
- **주요 연산자:**
  - `!`: NOT (부정)
  - `&&`: AND (논리곱)
  - `||`: OR (논리합)

- **예제:**
  ```swift
  let allowEntry = false
  if !allowEntry {
      print("ACCESS DENIED")
  }

  let enteredDoorCode = true
  let passedRetinaScan = false
  if enteredDoorCode && passedRetinaScan {
      print("Welcome!")
  } else {
      print("ACCESS DENIED")
  }
  ```

- **Short-Circuit Evaluation (단락 평가):**
  - `&&`는 첫 번째 값이 `false`면 두 번째 값을 평가하지 않음.
  - `||`는 첫 번째 값이 `true`면 두 번째 값을 평가하지 않음.

## 3. String

### **3.1 String Literals (문자열 리터럴)**
- 문자열은 큰따옴표(`"`)로 감싸서 표현.
- 예:
  ```swift
  let greeting = "Hello, world!"
  ```

- **멀티라인 문자열 리터럴:**
  - 세 개의 큰따옴표(`"""`)로 감싸서 여러 줄의 문자열을 작성 가능.
  - 예:
    ```swift
    let multilineGreeting = """
    Hello,
    world!
    """
    ```

---

### **3.2 Initializing an Empty String (빈 문자열 초기화)**
- 빈 문자열을 생성하는 두 가지 방법:
  - 빈 문자열 리터럴 사용:
    ```swift
    var emptyString = ""
    ```
  - `String` 타입의 초기화 메서드 사용:
    ```swift
    var anotherEmptyString = String()
    ```

- **비어 있는지 확인:**
  - `isEmpty` 프로퍼티를 사용하여 문자열이 비어 있는지 확인.
  - 예:
    ```swift
    if emptyString.isEmpty {
        print("Nothing to see here")
    }
    ```

---

### **3.3 String Mutability (문자열 가변성)**
- Swift에서 문자열은 `var`로 선언하면 변경 가능(가변적), `let`으로 선언하면 불변.
- 예:
  ```swift
  var variableString = "Horse"
  variableString += " and carriage" // 변경 가능

  let constantString = "Highlander"
  // constantString += " and another Highlander" // 에러 발생
  ```

---

### **3.4 Working with Characters (문자 작업)**
- 문자열은 `Character` 타입의 값들의 집합.
- **문자 반복:**
  - 문자열 내 각 문자에 접근 가능.
  - 예:
    ```swift
    for character in "Dog!".characters {
        print(character)
    }
    ```

- **문자 배열로 문자열 생성:**
  - `[Character]` 배열을 사용하여 문자열 생성 가능.
  - 예:
    ```swift
    let catCharacters: [Character] = ["C", "a", "t"]
    let catString = String(catCharacters) // "Cat"
    ```

---

### **3.5 Concatenating Strings and Characters (문자열 및 문자 연결)**
- 문자열 또는 문자를 연결할 때 `+` 연산자 사용.
- 예:
  ```swift
  let string1 = "hello"
  let string2 = " there"
  let combinedString = string1 + string2 // "hello there"
  ```

- **문자열에 문자 추가:**
  - `append()` 메서드를 사용하여 문자 추가 가능.
  - 예:
    ```swift
    var welcome = "hello"
    welcome.append("!") // "hello!"
    ```

---

### **3.6 String Interpolation (문자열 보간법)**
- 변수나 상수의 값을 문자열 안에 삽입.
- 형식: `\()`
- 예:
  ```swift
  let multiplier = 3
  let message = "\(multiplier) times 2.5 is \(Double(multiplier) * 2.5)"
  // "3 times 2.5 is 7.5"
  ```

---

### **3.7 Counting Characters (문자 수 세기)**
- `count` 프로퍼티를 사용하여 문자열의 문자 수 확인.
- 예:
  ```swift
  let unusualMenagerie = "Koala 🐨, Snail 🐌, Penguin 🐧, Dromedary 🐪"
  print("unusualMenagerie has \(unusualMenagerie.count) characters")
  // "unusualMenagerie has 40 characters"
  ```

---

### **3.8 Accessing and Modifying a String (문자열 접근 및 수정)**
- **인덱스 사용:**
  - 문자열은 `Index` 타입을 사용하여 특정 위치의 문자에 접근.
  - 예:
    ```swift
    let greeting = "Hello, world!"
    let index = greeting.index(greeting.startIndex, offsetBy: 7)
    print(greeting[index]) // "w"
    ```

- **삽입 및 삭제:**
  - `insert(_:at:)`, `remove(at:)` 메서드를 사용하여 문자열 수정.
  - 예:
    ```swift
    var welcome = "hello"
    welcome.insert("!", at: welcome.endIndex) // "hello!"
    welcome.remove(at: welcome.index(before: welcome.endIndex)) // "hello"
    ```

---

### **3.9 Substrings (부분 문자열)**
- 문자열의 일부를 추출하여 `Substring` 타입으로 반환.
- **주의사항:** `Substring`은 원본 문자열의 메모리를 공유하므로, 장기간 저장하지 않는 것이 좋음.
- 예:
  ```swift
  let greeting = "Hello, world!"
  let substring = greeting.prefix(5) // "Hello"
  ```

---

### **3.10 Comparing Strings (문자열 비교)**
- **동등성 비교:**
  - `==` 연산자를 사용하여 두 문자열이 같은지 확인.
  - 예:
    ```swift
    let quotation = "We're a lot alike, you and I."
    let sameQuotation = "We're a lot alike, you and I."
    if quotation == sameQuotation {
        print("These two strings are considered equal")
    }
    ```

- **접두사/접미사 비교:**
  - `hasPrefix(_:)`, `hasSuffix(_:)` 메서드를 사용.
  - 예:
    ```swift
    let romeoAndJuliet = [
        "Act 1 Scene 1: Verona, A public place",
        "Act 1 Scene 2: Capulet's mansion",
        "Act 1 Scene 3: A room in Capulet's mansion"
    ]
    var act1SceneCount = 0
    for scene in romeoAndJuliet {
        if scene.hasPrefix("Act 1 ") {
            act1SceneCount += 1
        }
    }
    print(act1SceneCount) // 3
    ```

---

### **3.11 Unicode Representations of Strings (문자열의 유니코드 표현)**
- Swift는 유니코드를 완벽히 지원.
- **주요 유니코드 표현:**
  - **UTF-8:** `utf8` 프로퍼티.
  - **UTF-16:** `utf16` 프로퍼티.
  - **Unicode Scalar:** `unicodeScalars` 프로퍼티.

- 예:
  ```swift
  let dogString = "Dog‼🐶"
  for codeUnit in dogString.utf8 {
      print(codeUnit)
  }
  ```

## 4. Collection

### **4.1 Mutability of Collections (컬렉션의 가변성)**
- **가변성(Mutability):**
  - 컬렉션(배열, 셋, 딕셔너리)은 `var`로 선언하면 변경 가능(가변적), `let`으로 선언하면 불변.
  - 예:
    ```swift
    var mutableArray = [1, 2, 3] // 변경 가능
    let immutableArray = [1, 2, 3] // 변경 불가능
    ```

- **주의사항:**
  - 컬렉션이 가변적인지 여부는 컬렉션의 타입 자체가 아니라 선언 방식에 따라 결정됨.

---

### **4.2 Arrays (배열)**

1\.**배열 생성 및 초기화**
- **배열 선언:**
  - 형식: `[Element]`
  - 예:
    ```swift
    var someInts: [Int] = [1, 2, 3]
    var emptyArray: [String] = []
    ```

- **빈 배열 초기화:**
  - `[]` 또는 `Array<Element>()` 사용.
  - 예:
    ```swift
    var emptyArray1: [String] = []
    var emptyArray2 = [String]()
    ```

- **기본값으로 초기화:**
  - 특정 값으로 배열을 채우기.
  - 예:
    ```swift
    var threeDoubles = Array(repeating: 0.0, count: 3) // [0.0, 0.0, 0.0]
    ```

2\. **배열 접근 및 수정**
- **요소 추가:**
  - `append(_:)` 메서드 또는 `+=` 연산자 사용.
  - 예:
    ```swift
    var shoppingList = ["Eggs", "Milk"]
    shoppingList.append("Flour")
    shoppingList += ["Baking Powder"] // ["Eggs", "Milk", "Flour", "Baking Powder"]
    ```

- **요소 삭제:**
  - `remove(at:)`, `removeLast()` 메서드 사용.
  - 예:
    ```swift
    shoppingList.remove(at: 0) // "Eggs" 제거
    shoppingList.removeLast()  // 마지막 요소 제거
    ```

- **요소 접근:**
  - 인덱스를 사용하여 접근.
  - 예:
    ```swift
    let firstItem = shoppingList[0]
    ```

- **범위로 수정:**
  - 특정 범위의 요소를 새로운 값으로 대체.
  - 예:
    ```swift
    shoppingList[1...3] = ["Bananas", "Apples"]
    ```

### **4.3 Sets (셋)**

1\. **셋 생성 및 초기화**
- **셋 선언:**
  - 형식: `Set<Element>`
  - 예:
    ```swift
    var letters: Set<Character> = ["a", "b", "c"]
    ```

- **빈 셋 초기화:**
  - `Set<Element>()` 사용.
  - 예:
    ```swift
    var emptySet: Set<Int> = []
    ```

2\. **셋 연산**
- **삽입 및 삭제:**
  - `insert(_:)`, `remove(_:)` 메서드 사용.
  - 예:
    ```swift
    letters.insert("d")
    letters.remove("a")
    ```

- **집합 연산:**
  - 교집합, 합집합, 차집합 등을 계산.
  - 예:
    ```swift
    let oddDigits: Set = [1, 3, 5, 7, 9]
    let evenDigits: Set = [0, 2, 4, 6, 8]
    let singleDigitPrimeNumbers: Set = [2, 3, 5, 7]

    oddDigits.union(evenDigits).sorted() // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    oddDigits.intersection(evenDigits).sorted() // []
    ```

- **멤버십 및 동등성 확인:**
  - `contains(_:)`, `==` 연산자 사용.
  - 예:
    ```swift
    if letters.contains("a") {
        print("The set contains 'a'")
    }
    ```

### **4.4 Dictionaries (딕셔너리)**

1\. **딕셔너리 생성 및 초기화**
- **딕셔너리 선언:**
  - 형식: `[Key: Value]`
  - 예:
    ```swift
    var namesOfIntegers: [Int: String] = [1: "One", 2: "Two"]
    ```

- **빈 딕셔너리 초기화:**
  - `[:]` 또는 `[Key: Value]()` 사용.
  - 예:
    ```swift
    var emptyDictionary: [String: Int] = [:]
    ```

2\. **딕셔너리 접근 및 수정**
- **값 추가 및 업데이트:**
  - 키를 사용하여 값을 추가하거나 업데이트.
  - 예:
    ```swift
    var airports: [String: String] = ["YYZ": "Toronto Pearson"]
    airports["LAX"] = "Los Angeles International"
    airports["YYZ"] = "Toronto Pearson International"
    ```

- **값 삭제:**
  - `removeValue(forKey:)` 메서드 사용.
  - 예:
    ```swift
    airports.removeValue(forKey: "LAX")
    ```

- **값 접근:**
  - 키를 사용하여 접근.
  - 예:
    ```swift
    if let airportName = airports["YYZ"] {
        print("The name of the airport is \(airportName)")
    }
    ```

- **전체 순회:**
  - `for-in` 루프를 사용하여 키와 값 순회.
  - 예:
    ```swift
    for (airportCode, airportName) in airports {
        print("\(airportCode): \(airportName)")
    }
    ```

## 5. Control-Flow

### **5.1 For-In Loops (for-in 루프)**
- **배열, 범위, 문자열 등 반복 가능한 항목들을 순회.**
- 형식:
  ```swift
  for item in items {
      // 작업 수행
  }
  ```

- **예제:**
  ```swift
  let names = ["Anna", "Alex", "Brian", "Jack"]
  for name in names {
      print("Hello, \(name)!")
  }
  ```

- **범위 순회:**
  ```swift
  for index in 1...5 {
      print("\(index) times 5 is \(index * 5)")
  }
  ```

- **튜플 분해:**
  ```swift
  let numberOfLegs = ["spider": 8, "ant": 6, "cat": 4]
  for (animalName, legCount) in numberOfLegs {
      print("\(animalName)s have \(legCount) legs")
  }
  ```

### **5.2 While Loops (while 루프)**

1\. **`while`**
- 조건이 `true`인 동안 반복.
- 형식:
  ```swift
  while condition {
      // 작업 수행
  }
  ```

- **예제:**
  ```swift
  var i = 0
  while i < 5 {
      print(i)
      i += 1
  }
  ```

2\. **`repeat-while`**
- 최소 한 번은 실행한 후 조건을 확인.
- 형식:
  ```swift
  repeat {
      // 작업 수행
  } while condition
  ```

- **예제:**
  ```swift
  var j = 0
  repeat {
      print(j)
      j += 1
  } while j < 5
  ```

### **5.3 Conditional Statements (조건문)**

1\. **`if`**
- 조건에 따라 코드 블록 실행.
- 형식:
  ```swift
  if condition {
      // 작업 수행
  }
  ```

- **예제:**
  ```swift
  let temperature = 25
  if temperature > 30 {
      print("It's really warm.")
  }
  ```

2\. **`else if`**
- 여러 조건을 검사.
- 형식:
  ```swift
  if condition1 {
      // 작업 수행
  } else if condition2 {
      // 작업 수행
  } else {
      // 기본 작업 수행
  }
  ```

- **예제:**
  ```swift
  let score = 85
  if score >= 90 {
      print("Grade A")
  } else if score >= 80 {
      print("Grade B")
  } else {
      print("Grade C")
  }
  ```

3\. **`switch`**
- 값에 따라 여러 경우를 처리.
- 형식:
  ```swift
  switch value {
  case pattern1:
      // 작업 수행
  case pattern2:
      // 작업 수행
  default:
      // 기본 작업 수행
  }
  ```

- **예제:**
  ```swift
  let vegetable = "red pepper"
  switch vegetable {
  case "celery":
      print("Add some raisins and make ants on a log.")
  case "cucumber", "watercress":
      print("That would make a good tea sandwich.")
  case let x where x.hasSuffix("pepper"):
      print("Is it a spicy \(x)?")
  default:
      print("Everything tastes good in soup.")
  }
  ```

- **특징:**
  - `default`가 반드시 필요하지 않음(모든 경우를 처리하면 생략 가능).
  - `where`를 사용하여 추가 조건 지정 가능.

### **5.4 Control Transfer Statements (제어 전환 문)**

1\. **`continue`**
- 현재 반복을 건너뛰고 다음 반복으로 넘어감.
- 예:
  ```swift
  for number in 1...10 {
      if number % 2 == 0 {
          continue
      }
      print(number)
  }
  ```

2\. **`break`**
- 반복문 또는 `switch` 문을 즉시 종료.
- 예:
  ```swift
  for number in 1...10 {
      if number == 5 {
          break
      }
      print(number)
  }
  ```

3\. **`fallthrough`**
- `switch` 문에서 다음 케이스로 넘어감.
- 예:
  ```swift
  let integerToDescribe = 5
  var description = "The number \(integerToDescribe) is"
  switch integerToDescribe {
  case 2, 3, 5, 7, 11, 13:
      description += " a prime number, and also"
      fallthrough
  default:
      description += " an integer."
  }
  print(description)
  ```

4\. **`return`**
- 함수에서 값을 반환하거나 종료.
- 예:
  ```swift
  func greet(name: String) -> String {
      return "Hello, \(name)!"
  }
  ```

### **5.5 Labeled Statements (레이블 문)**
- 중첩된 루프나 조건문에서 특정 블록을 식별.
- 형식:
  ```swift
  labelName: for item in items {
      // 작업 수행
  }
  ```

- **예제:**
  ```swift
  outerLoop: for i in 1...5 {
      for j in 1...5 {
          if j == 3 {
              break outerLoop
          }
          print("i: \(i), j: \(j)")
      }
  }
  ```

### **5.6 Early Exit (조기 종료)**
- `guard`를 사용하여 조건이 충족되지 않을 때 조기에 종료.
- 형식:
  ```swift
  guard condition else {
      // 조기 종료 작업
      return
  }
  ```

- **예제:**
  ```swift
  func greet(person: [String: String]) {
      guard let name = person["name"] else {
          print("Name is missing")
          return
      }
      print("Hello, \(name)!")
  }
  ```

### **5.7 Checking API Availability (API 가용성 확인)**
- 특정 플랫폼 또는 버전에서 API를 사용할 수 있는지 확인.
- 형식:
  ```swift
  if #available(iOS 15, macOS 12, *) {
      // iOS 15 이상 또는 macOS 12 이상에서 실행
  } else {
      // 이전 버전에서 실행
  }
  ```

- **예제:**
  ```swift
  if #available(iOS 14, *) {
      print("This feature is available on iOS 14 and later.")
  } else {
      print("This feature is not available on your version of iOS.")
  }
  ```

