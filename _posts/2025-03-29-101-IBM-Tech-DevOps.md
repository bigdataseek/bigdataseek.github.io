---
title: 21차시 1:IBM TECH(DevOps)
layout: single
classes: wide
categories:
  - DevOps
toc: true # 이 포스트에서 목차를 활성화
toc_sticky: true # 목차를 고정할지 여부 (선택 사항)
---


## 1. DevOps란?
- 출처: [What is DevOps?](https://www.youtube.com/watch?v=UbtB4sMaaNM&list=PLOspHqNVtKAAm1dmyiR9WMmw1UBoOwZVj)


### **1.1 DevOps란?**  
DevOps는 **소프트웨어 개발(Application Development)과 IT 운영(IT Operations) 간의 긴밀한 협업을 강조하는 방법론**으로, 개발팀과 운영팀 간의 사일로(silo, 부서 이기주의)를 제거하고 협력 문화를 조성하는 것

- **개발(Development):**  
  - 새로운 기능 추가, 코드 변경, 버그 수정의 속도를 최우선으로 고려  
  - 최신 기술 도입 및 빠른 반복 개발(Iterative Development) 진행  
- **운영(Operations):**  
  - 시스템의 안정성, 보안성, 가용성(Availability) 확보가 최우선  
  - 장애 발생 시 신속한 대응 및 서비스 중단 최소화  

이러한 상반된 목표로 인해 발생하는 **부서 간 갈등을 완화하고, 협업을 통해 지속적인 비즈니스 가치를 창출**하는 것이 DevOps의 핵심입니다.


### **1.2 DevOps의 중요성 및 목표**  

DevOps는 소프트웨어 개발 및 배포 과정을 최적화하여 기업의 경쟁력을 높이는 데 기여합니다.  

- **비즈니스 민첩성(Business Agility) 향상:**  
  - 시장 변화와 고객 요구 사항에 신속하게 대응 가능  
  - 반복적인 배포 및 신속한 기능 개선을 통해 비즈니스 성장 지원  

- **제품 출시 기간 단축(Time to Market 단축):**  
  - 자동화 및 지속적 통합/배포(CI/CD)를 활용하여 소프트웨어 개발 속도 향상  
  - 시장에서의 경쟁 우위 확보  

- **주요 이점:**  
  - **속도(Velocity):**  
    - 소프트웨어 릴리스 주기를 단축하고, 기능 업데이트를 빠르게 적용  
  - **품질(Quality):**  
    - 자동화된 테스트 및 모니터링을 통해 코드 품질 유지 및 애플리케이션 신뢰성 향상  
    - 디지털 평판을 유지하며 고객 만족도 증대  


### **1.3 애플리케이션 딜리버리 파이프라인 (공급망)**  

DevOps에서는 애플리케이션이 기획 단계부터 배포 및 운영, 개선 단계까지 원활하게 흐를 수 있도록 **자동화된 소프트웨어 공급망(Software Delivery Pipeline)**을 구축하는 것이 중요합니다.  

1. **아이디어 구상(Ideation):**  
   - 고객 요구사항을 기반으로 사용자 스토리(User Story) 정의  
   - 피드백을 바탕으로 개발 우선순위 설정  

2. **코딩(Coding):**  
   - 사용자 스토리를 기반으로 개발자가 기능을 구현  
   - 코드 품질을 유지하기 위한 코드 리뷰(Code Review) 수행  

3. **빌드(Build):**  
   - 코드를 컴파일하고 유닛 테스트(Unit Test) 실행  
   - 실행 파일 패키징 및 아티팩트(Artifact, 모든 결과물) 생성  

4. **배포(Deploy):**  
   - 지속적 배포(Continuous Deployment) 또는 블루-그린 배포(Blue-Green Deployment) 기법 활용  
   - 운영 환경(Production)으로의 원활한 전환  

5. **관리(Manage):**  
   - 애플리케이션이 개발, 테스트, 운영 환경에서 정상적으로 작동하도록 관리  
   - 성능 모니터링 및 장애 대응  

6. **학습(Learn):**  
   - 배포 이후 사용자 피드백과 성능 데이터를 분석하여 지속적인 개선 진행  
   - A/B 테스트를 통해 최적의 기능 제공  

### **1.4 DevOps 적용 Use-Case**  

DevOps는 다양한 환경에서 적용될 수 있으며, 조직의 목표에 따라 다음과 같이 활용됩니다.  

1. **코어 시스템 최적화 (Optimizing the core):**  
   - 기존 레거시 시스템에 자동화 도입하여 운영 효율성 극대화  
   - 대규모 시스템 현대화, 리팩토링 과정에서 DevOps의 도구와 원칙을 적용하여 부담 완화  

2. **레거시 시스템 활용 (Unlocking the legacy):**  
   - 기존 시스템과 새로운 DevOps 프로세스를 융합하여 개발 및 운영 문화 개선  
   - 기능 추가 및 변경을 빠르게 수행할 수 있도록 지속적 통합/배포(CI/CD) 환경 구축  

3. **디지털 역량 강화 (Unleashing the digital):**  
   - **클라우드 네이티브** 환경에서 컨테이너 기술(Docker, Kubernetes) 활용  
   - 아이디어 구상부터 지속적 개선까지의 전 과정을 자동화  
   - 최신 클라우드 기반 플랫폼을 활용하여 신속한 애플리케이션 개발 및 배포  

### **1.5 DevOps의 핵심 요소**  

DevOps는 **"사람(People), 프로세스(Process), 도구(Tools)"**의 세 가지 요소가 조화를 이루며 운영됩니다.  

- **사람(People):**  
  - 개발 및 운영팀 간의 협업 문화 조성  
  - DevOps 원칙을 이해하고 실천할 수 있는 팀 구성  

- **프로세스(Process):**  
  - 지속적 통합(Continuous Integration) 및 지속적 배포(Continuous Deployment)를 포함한 효율적인 개발 및 운영 프로세스 구축  
  - 애자일(Agile) 및 린(Lean) 원칙을 활용하여 반복적 개선 수행  

- **도구(Tools):**  
  - 자동화된 빌드 및 배포 시스템 (Jenkins, GitHub Actions, GitLab CI/CD)  
  - 컨테이너 오케스트레이션 시스템 (Kubernetes, Docker)  
  - 코드 품질 및 보안 분석 도구 (SonarQube, Snyk)  
  - 모니터링 및 로깅 시스템 (Prometheus, ELK Stack, Datadog)  


## 2. Jenkins vs. Tekton CI/CD
- 출처: [Tekton vs. Jenkins: What's the difference?](https://www.youtube.com/watch?v=7aSe1HQ2lXo&list=PLOspHqNVtKAAm1dmyiR9WMmw1UBoOwZVj&index=2)

### **2.1 CI/CD 기본 개념**

*   CI/CD(Continuous Integration/Continuous Deployment)는 소프트웨어 개발 과정에서 테스트, 빌드, 배포를 자동화하는 프로세스로, 개발자의 생산성을 높이고 안정적인 소프트웨어 릴리스를 가능하게 함.
*   Jenkins와 Tekton은 이러한 CI/CD 파이프라인을 구축하는 데 사용되는 대표적인 도구로, 각각의 환경과 목적에 따라 다른 방식으로 동작합니다.

### **2.2 Tekton**

*   **Kubernetes 네이티브:** Tekton은 Kubernetes에서 실행되도록 설계된 CI/CD 프레임워크로, 컨테이너 환경과 자연스럽게 통합되며 클러스터 내에서 워크로드를 효율적으로 관리할 수 있습니다.
*   **확장성:** Kubernetes 클러스터의 노드를 추가함으로써 CI/CD 프로세스의 성능을 쉽게 확장할 수 있으며, 다양한 컨테이너 기반 애플리케이션과 유연하게 연동됩니다.
*   **아키텍처:** Tekton의 구성 요소들은 모듈화되어 있어 확장성과 재사용성이 높습니다.
    *   **Step:** 
        - Tekton의 최소 실행 단위로, 특정 명령어나 스크립트를 실행하는 개별적인 작업을 정의합니다.
    *   **Task:** 
        - 여러 개의 Step을 하나의 작업 단위로 묶어 구성하며, 재사용이 가능하여 여러 파이프라인에서 공통적으로 사용할 수 있습니다.
    *   **Pipeline:** 
        - Task들의 실행 순서와 방식을 정의하며, 작업을 병렬 또는 순차적으로 실행할 수 있도록 설계.
    *   **Pipeline Resources:** 
        - 소스 코드, 빌드된 이미지 등의 입출력을 정의하는 개념, 파이프라인이 데이터를 주고받는 방식을 결정.
    *   **PipelineRun:** 
        - 파이프라인을 실제로 실행하는 트리거 역할을 합니다.
    *   **EventListener:** 
        - 특정 이벤트(예: 코드 커밋, PR 생성)를 감지하여 자동으로 파이프라인을 실행하도록 합니다.
    *   **TriggerTemplate:** 
        - 실행될 PipelineRun을 정의하는 템플릿 역할을 합니다.
*   **구조:** Tekton은 각 구성 요소를 개별적인 YAML 파일로 관리하여 모듈화가 가능하며, 파이프라인의 수정 및 확장이 용이합니다.
*   **스토리지 관리:** Tekton은 빌드와 배포 과정에서 데이터를 효과적으로 관리하기 위해 다양한 저장소 개념을 사용합니다.
    *   **Workspaces:** 
        - CI/CD 실행 중 데이터를 저장하는 공유 파일 시스템 영역으로, Task 간 데이터를 주고받음.
    *   **Persistent Volume Claim (PVC):** 
        - Kubernetes의 영구 저장소를 활용하여 빌드 아티팩트나 설정 데이터를 유지하고 공유 가능.
    *   **Service Accounts:** 
        - CI/CD 프로세스에서 필요한 인증 정보를 안전하게 관리하여, GitHub 또는 Docker Registry와 같은 외부 서비스와 연동할 수 있습니다.

### **2.3 Jenkins**

*   **서버/VM 기반:** Jenkins는 Kubernetes 클러스터가 아닌 독립적인 서버 또는 가상 머신에서 실행되며, 온프레미스 환경에서 널리 사용됩니다.
*   **Java 기반:** Java로 개발되었으며, 기본적으로 Java 프로젝트와 호환되지만 다양한 플러그인을 통해 Python, Node.js 등의 다른 언어도 지원할 수 있습니다.
*   **플러그인 확장성:** 1,800개 이상의 플러그인을 제공하여 다양한 기능(예: GitHub 연동, Docker 빌드, 테스트 자동화 등)을 추가할 수 있습니다.
*   **UI 기반 작업 관리:** Jenkins는 웹 UI를 제공하여 사용자가 파이프라인을 시각적으로 관리할 수 있으며, 명령줄을 통한 자동화도 지원합니다.
*   **파일 구조:** Jenkins는 파이프라인 구성을 단일 `Jenkinsfile`에 정의하며, 스크립트 형태로 작성된 파이프라인을 실행합니다.
    *   **Stages:** 파이프라인의 주요 단계(예: 빌드, 테스트, 배포)를 정의하는 개념으로, Tekton의 Task와 유사합니다.
    *   **Steps:** 각 Stage 내에서 실행되는 세부 작업(예: 명령어 실행, 스크립트 실행)을 정의합니다.
*   **Webhook 트리거:** 특정 이벤트(예: 코드 커밋, PR 생성)를 감지하여 파이프라인을 실행할 수 있습니다.
*   **스토리지 관리:** Jenkins는 자체적인 파일 시스템 구조를 사용하여 빌드 결과 및 설정을 관리합니다.
    *   **Jenkins Home:** 빌드 로그, 설정 파일, 플러그인 데이터 등을 저장하는 주요 디렉터리입니다.
    *   **Workspace:** 파이프라인 실행 중 생성되는 임시 작업 디렉터리로, 빌드 아티팩트와 데이터를 저장하며 공유할 수 있습니다.


### **2.4 주요 차이점**

| 특징          | Tekton                                  | Jenkins                                 |
| ----------- | --------------------------------------- | --------------------------------------- |
| 실행 환경       | Kubernetes 기반 컨테이너 환경                 | 독립적인 서버 또는 VM                      |
| 기반 언어       | 컨테이너 기반(언어에 제한 없음)                   | Java (플러그인으로 다양한 언어 지원)           |
| 확장성          | Kubernetes 클러스터 확장을 통해 유연하게 확장 가능 | 플러그인 시스템을 활용한 기능 확장 가능          |
| 파일 구조       | 각 구성 요소가 독립적인 YAML 파일로 관리         | 하나의 `Jenkinsfile`에 모든 정보 포함          |
| 재사용성         | 모듈화된 구성 요소로 높은 재사용성 지원          | 상대적으로 낮은 재사용성                        |


### **2.5 공통점**

*   소프트웨어 개발의 빌드, 테스트, 배포 프로세스를 자동화하는 CI/CD 도구입니다.
*   반복적인 수작업을 최소화하여 개발 효율성을 높이고, 일관된 빌드 및 배포 환경을 제공합니다.
*   파일 시스템 기반의 저장소를 활용하여 빌드 결과물과 실행 데이터를 관리합니다.


### **2.6 요약**

- Jenkins와 Tekton은 CI/CD를 자동화하는 강력한 도구이지만, 실행 환경과 아키텍처에서 차이 존재.
- Tekton은 Kubernetes와 완벽하게 통합되며 컨테이너 기반 환경에서 뛰어난 확장성과 모듈화를 제공
- Jenkins는 독립적인 서버 또는 VM 환경에서 실행되며 다양한 플러그인을 활용하여 기능을 확장 가능.
- 따라서 Kubernetes 기반의 클라우드 네이티브 애플리케이션을 운영하는 경우 Tekton이 적합하며,  
기존 온프레미스 환경에서 다양한 플러그인을 활용한 CI/CD를 구성하고자 한다면 Jenkins가 더 적합할 수 있습니다.


## 3. DevOps vs. SRE
- 출처: [DevOps vs. SRE: What's the difference?](https://www.youtube.com/watch?v=KCzNd3StIoU&list=PLOspHqNVtKAAm1dmyiR9WMmw1UBoOwZVj&index=3)

### **3.1 DevOps**  

*   **목표:**  
    * 개발팀과 운영팀 간의 벽을 허물고 협업을 강화하여 보다 신속하고 안정적인 소프트웨어 배포를 가능
    * 조직 내 사일로를 제거하고 공통의 목표를 기반으로 한 효율적인 개발 및 운영 환경 구축  

*   **역할:**  
    * 소프트웨어 개발을 주도하며, "어떤 기능을 구현할 것인가?"에 대한 기획 및 설계를 담당  
    * 지속적인 통합(CI) 및 지속적인 배포(CD) 파이프라인을 설계하고 개선  
    * 애플리케이션의 코드 품질과 확장성을 고려한 개발 진행  

*   **초점:**  
    * 문제를 해결하기 위한 최적의 방법을 연구하고, 프로세스를 설계하는 이론적인 접근 방식  
    * 개발과 운영을 통합할 수 있는 방법론을 도입하여 배포 속도를 높이고 품질을 유지  

*   **자동화:**  
    * 빌드 및 테스트 자동화, 배포 자동화(CI/CD)  
    * 코드형 인프라(IaC, Infrastructure as Code)를 활용한 환경 설정 및 관리  
    * 반복적인 수작업을 줄이기 위한 다양한 자동화 도구 도입  

### **3.2 SRE (Site Reliability Engineering)**  

*   **목표:**  
    * 자동화를 통해 시스템의 안정성과 가용성을 보장  
    * 장애를 최소화하고, 신뢰성을 극대화하는 운영 모델 구축  

*   **역할:**  
    * 주요 서비스의 안정적인 운영을 담당하고, 개발 및 운영 프로세스를 개선  
    * 개발팀과 협력하여 성능 모니터링, 장애 대응, 확장성 개선 등의 작업 수행  
    * DevOps 팀과 협력하여 코드 배포 및 운영 환경을 최적화  

*   **초점:**  
    * 문제 해결 방법을 실질적으로 적용하고 운영하는 실천적 접근 방식  
    * 모니터링 및 장애 감지 시스템을 구축하여 사전 예방적인 조치를 실행  
    * 효율적인 운영을 위해 반복적인 작업을 자동화  

*   **자동화:**  
    * 시스템 복구 및 장애 대응 자동화  
    * 대규모 인프라 운영을 위한 오토스케일링 및 로드 밸런싱 기술 적용  
    * 반복적인 운영 작업 및 배포 프로세스를 자동화하여 인적 오류 최소화  

### **3.3 공통점**  

DevOps와 SRE는 다음과 같은 공통 목표를 공유한다:  

*   **사일로 제거:** 개발과 운영의 협업을 촉진하여 팀 간 장벽을 허문다.  
*   **자동화:** 반복적인 프로세스를 자동화하여 효율성과 안정성을 극대화한다.  
*   **공동의 목표:** 시스템의 가용성과 신뢰성을 높이고, 조직의 성공을 도모한다.  

### **3.4 실패 관리(Failure Management)**  

**SRE의 역할:**  
*   시스템 장애를 사전에 감지하고, 모니터링 및 로깅을 통해 예방 조치를 수행  
*   장애 발생 시 빠르게 복구할 수 있는 프로세스를 마련하고 대응 전략을 실행  
*   장애 발생 후 근본 원인 분석(RCA, Root Cause Analysis)을 수행하여 문제의 원인을 파악  
*   분석 결과를 DevOps 팀과 공유하여 근본적인 해결책을 모색  

**DevOps의 역할:**  
*   SRE 팀으로부터 받은 RCA 결과를 바탕으로 근본적인 원인을 해결하는 작업 수행  
*   코드 수정, 인프라 개선, 배포 전략 수정 등을 통해 장애의 재발 방지  
*   지속적인 개선과 반복을 통해 시스템의 안정성을 높이고 품질을 유지  

## 4. Site Reliability Engineering
- 출처: [What is Site Reliability Engineering (SRE)?](https://www.youtube.com/watch?v=ztIIcXNzMN4&list=PLOspHqNVtKAAm1dmyiR9WMmw1UBoOwZVj&index=4)

### **4.1 SRE란 무엇인가?**  

*   **정의:**  
    Site Reliability Engineering(SRE)은 전통적인 IT 운영(Ops)과 소프트웨어 개발(Dev)의 요소를 결합하여 시스템의 안정성을 극대화하는 접근 방식입니다. 이는 Google에서 처음 개념화한 모델로, 운영을 단순한 유지보수 작업이 아닌 엔지니어링 방식으로 접근하는 것이 핵심입니다.  

*   **역사:**  
    SRE라는 용어는 비교적 최근(약 15~18년 전) 등장했지만, 실제로는 오랫동안 IT 업계에서 존재해온 역할입니다. 기존의 시스템 관리자 및 IT 운영 팀이 수행하던 업무를 보다 체계적이고 효율적으로 운영하기 위한 개념으로 발전되었습니다.  

*   **목표:**  
    SRE의 궁극적인 목표는 대규모 소프트웨어 시스템을 보다 안정적이고 신뢰성 있게 운영하는 것입니다. 이를 위해 자동화, 모니터링, 장애 대응 등의 기술을 활용하여 서비스 중단을 최소화하고, 지속적인 성능 개선을 추구합니다.  

### **4.2 SRE의 역할**  

*   **50/50 역할:**  
    SRE 엔지니어는 단순히 시스템을 유지보수하는 역할이 아니라, 서비스의 안정성을 개선하는 엔지니어링적 접근을 수행합니다. 업무의 절반은 고객 지원 및 장애 대응, 나머지 절반은 자동화를 통한 효율성 개선에 집중합니다.  
    *   **50% - 고객 문제 해결:**  
        - 장애 발생 시 신속한 대응 (Incident Management)  
        - 문제 해결 프로세스 정립 및 지속적인 개선  
        - 고객 피드백을 반영한 서비스 운영 최적화  
    *   **50% - 자동화를 통한 업무 효율화:**  
        - 반복적인 수작업을 자동화하여 인력 부담 감소  
        - 인프라 관리 자동화 도구(SRE Tooling) 활용  
        - 지속적인 개선을 위한 실험 및 최적화  

*   **자동화:**  
    *   운영 과정에서 발생하는 수작업을 최소화하는 것이 SRE의 핵심 목표 중 하나입니다.  
    *   하드웨어, 미들웨어, 소프트웨어 구성 요소 모두 자동화를 통해 효율적으로 관리됩니다.  
    *   자동화를 진행하면서 시스템 구조에 대한 깊은 이해가 가능해지며, 추가적인 개선 기회도 발견

*   **DevOps 접근 방식:**  
    *   개발자의 사고방식으로 운영 업무를 바라보고, 소프트웨어 엔지니어링 기법을 적용하여 문제를 해결
    *   동일한 문제가 반복되지 않도록, 일회성 해결이 아니라 시스템 개선을 목표로 합니다.  
    *   코드 기반 인프라(Infrastructure as Code, IaC)를 적극 활용하여 운영을 자동화


### **4.3 SRE의 주요 업무**  

*   **고객 대응:**  
    *   고객 및 내부 팀과 원활하게 소통하며 발생하는 문제를 신속하게 해결합니다.  
    *   단순히 장애를 해결하는 것이 아니라, 근본적인 원인을 분석하고 예방하는 것이 목표입니다.  

*   **지식 공유:**  
    *   SRE는 단순히 운영만 담당하는 것이 아니라, 하드웨어, 소프트웨어, 모니터링, 로깅, 자동화 등의 다양한 분야에 대한 폭넓은 지식을 보유해야 합니다.  
    *   팀 내 지식 공유를 통해 조직 전체의 운영 수준을 향상시킵니다.  

*   **개발팀 협업:**  
    *   실제 운영 데이터(장애 발생 로그, 성능 지표 등)를 개발팀에 제공하여 서비스 품질 개선을 유도합니다.  
    *   소프트웨어 개발 초기 단계부터 신뢰성과 가용성을 고려하도록 협력합니다.  

*   **장애 예측 및 해결:**  
    *   실시간 모니터링을 통해 장애 발생 가능성을 사전에 감지하고 대응합니다.  
    *   발생한 장애에 대해 철저한 분석을 수행하여 근본 원인을 해결하고, 동일한 문제 발생 예방.

*   **모니터링 및 로깅:**  
    *   **모니터링:** 실시간으로 시스템 상태를 추적하고, 이상 징후를 빠르게 탐지하여 사전 대응합니다.  
    *   **로깅:** 과거 장애 및 시스템 이벤트를 기록하여, 향후 문제 분석 및 예방 조치에 활용합니다.  

### **4.4 SRE의 중요성**  

*   **성공적인 비즈니스 운영의 핵심:**  
    *   오늘날 대부분의 기업은 이미 SRE와 유사한 역할을 수행하고 있습니다.  
    *   특히 클라우드 기반 서비스에서는 높은 신뢰성과 가용성이 필수적이므로, SRE의 역할이 더욱 강조

*   **장애 대응:**  
    *   100% 완벽한 시스템은 존재하지 않으며, 장애는 언제든 발생할 수 있습니다.  
    *   SRE는 장애 발생 가능성을 최소화하고, 발생했을 때 신속히 대응할 수 있도록 준비하는 역할

*   **자동화 및 모니터링:**  
    *   지속적인 자동화와 모니터링을 통해 장애를 사전에 예측하고 예방할 수 있습니다.  
    *   이를 통해 운영 비용을 절감하고, 서비스 품질을 유지 및 향상시킬 수 있습니다.  

### **4.5 스타트업(소규모 기업)을 위한 SRE 접근 방식**  

*   **SRE 조직을 따로 구축하기보다는, 개발 단계에서부터 SRE 마인드셋을 적용하는 것이 중요합니다.**  
*   **핵심 개념:**  
    *   장애를 예측하고 자동화를 통해 문제를 해결  
    *   충분한 이중화(Redundancy)를 통해 장애 발생 시 영향 최소화  
    *   근본 원인 분석(Root Cause Analysis, RCA)을 통한 재발 방지  
    *   효과적인 모니터링을 활용하여 장애 가능성을 사전에 탐지하고 대응  

### **4.6 대규모 조직을 위한 SRE 접근 방식**  

*   **SRE 전담 조직 구축 또는 기존 운영 그룹을 SRE로 전환:**  
    *   기존 IT 운영 그룹에 자동화 권한을 부여하고, 점진적으로 SRE로 전환하는 방식도 가능합니다.  
    *   클라우드 기반 인프라에서는 SRE의 역할이 더욱 중요해집니다.  

*   **50/50 규칙 적용:**  
    *   자동화와 문제 해결을 균형 있게 수행하는 것이 핵심 원칙입니다.  

*   **자동화 우선 접근:**  
    *   가능한 모든 반복 작업을 자동화하여 인적 리소스를 최적화합니다.  


## 5. 인프라스트럭처 as Code (IaC)
- 출처: [What is Infrastructure as Code?]()

### **5.1 IaC의 중요성**

*   **애플리케이션 배포 빈도 증가**  
    - 현대 소프트웨어 개발에서는 CI/CD(Continuous Integration & Continuous Deployment) 파이프라인을 통해 하루에도 수백 번 배포가 이루어짐. 
    - 수동으로 인프라를 설정하는 방식은 이러한 배포 속도를 따라가기 어려움.  
*   **인프라의 유연성**  
    - 트래픽 증가 또는 감소에 따라 동적으로 인프라를 확장(프로비저닝)하거나 축소(디프로비저닝)할 수 있어야 함. 
    - IaC를 활용하면 필요할 때 즉시 새로운 서버나 네트워크를 설정하고, 필요하지 않을 때 제거할 수 있음.  
*   **개발/테스트 환경 불일치 문제 해결**  
    - 개발 환경에서 정상 작동하던 애플리케이션이 테스트 또는 운영 환경에서 오류가 발생하는 문제(환경 차이로 인한 문제)를 해결할 수 있음. 
    - IaC를 사용하면 모든 환경을 동일한 코드로 정의할 수 있어, 환경 간 불일치 문제를 최소화함.  

### **5.2 예시 시나리오**

*   **Kubernetes, VM, VPC를 이용한 애플리케이션 개발 환경 구축**  
    - 기업에은 컨테이너 기반 애플리케이션을 운영하기 위해 Kubernetes(K8s)를 활용하는 경우가 많음. 
    - VM(가상 머신)이나 VPC(가상 네트워크)와 함께 IaC를 이용해 일관된 환경을 구축할 수 있음.  
*   **개발 환경과 동일한 테스트 환경 구축 시 설정 누락 또는 플랫폼 차이로 인한 문제 발생**  
    - 예를 들어, 개발자는 로컬 환경에서 Docker Compose를 사용해 애플리케이션을 실행하지만, 운영 환경에서는 Kubernetes를 사용하는 경우가 많음. 
    - IaC를 활용하면 동일한 환경을 자동화된 코드로 구축하여 환경 차이로 인한 문제를 방지할 수 있음.  

### **5.3 IaC 접근 방식**

*   **명령형 (Imperative) 접근 방식**  
    - 사용자가 인프라를 설정하는 단계별 명령을 직접 정의하는 방식.  
    *   **장점:**  
        - 인프라 프로비저닝 과정에서 세부적인 제어 가능  
        - 특정 조건이나 예외 처리를 명령어로 직접 관리할 수 있어 유연성 제공  
    *   **단점:**  
        - 복잡성이 증가하여 유지보수가 어려워질 수 있음  
        - 인프라 변경 및 확장 시 별도의 사용자 정의 스크립트가 필요하여 자동화 수준이 낮음  
    *   **예시:**  
        - CLI(Command Line Interface)를 이용한 인프라 설정 (`aws ec2 create-instance` 등)  
        - Bash 스크립트를 활용한 서버 및 네트워크 구성  

*   **선언형 (Declarative) 접근 방식**  
    - 최종적으로 원하는 인프라 상태를 정의하고, 시스템이 자동으로 해당 상태를 유지하도록 하는 방식.  
    *   **장점:**  
        - 코드로 작성된 인프라 상태를 기반으로 자동화가 가능하여 유지보수 용이  
        - 변경 사항을 자동 적용하여 환경을 일관되게 유지 가능  
    *   **단점:**  
        - 세부적인 제어가 어려워 특정 시나리오에서 제약이 있을 수 있음  
    *   **예시:**  
        - Terraform을 이용한 인프라 코드 정의  
        - Kubernetes의 YAML 파일을 이용한 배포 관리  
        - CloudFormation을 활용한 AWS 인프라 설정  

### **5.4 DevOps와 IaC**

*   IaC는 **인프라를 코드처럼 관리**하여 DevOps 팀이 효율적으로 협업할 수 있도록 지원함.  
*   **Git과 같은 버전 관리 시스템을 활용**하여 인프라 변경 사항을 추적하고 롤백할 수 있음.  
*   CI/CD 파이프라인과 연계하여 코드 변경 시 자동으로 인프라 변경을 적용하는 자동화된 환경 구축 가능.  

### **5.5 Immutable vs Mutable 인프라**

*   **Mutable (가변) 인프라:**  
    - 인프라의 상태를 필요에 따라 직접 변경하는 방식  
    *   **단점:**  
        - 설정 변경 중 오류가 발생하면 기존 환경과 불일치한 상태(구성 드리프트, Configuration Drift)가 발생할 수 있음  
        - 예기치 않은 문제 발생 시 원래 상태로 복구하기 어려움  
        - 확장성이 낮고 유지보수가 어려움  

*   **Immutable (불변) 인프라:**  
    - 기존 인프라를 변경하는 대신 새로운 환경을 구축하여 교체하는 방식  
    *   **장점:**  
        - 변경 사항을 적용할 때 새 환경을 생성한 후 검증하여 안정성 확보 가능  
        - 구성 드리프트 방지  
        - 확장성이 뛰어나고, 롤백이 용이함  
    *   **단점:**  
        - 기존 환경을 유지하면서 새 환경을 배포해야 하므로 운영 비용이 증가할 수 있음  


### **5.6 결론**

*   **IaC 접근 방식을 이해하는 것이 중요**  
    - 명령형 vs 선언형 접근 방식의 차이를 이해하고, 프로젝트에 적절한 방식을 선택해야 함.  
*   **선언형(Declarative) 방식이 일반적으로 선호됨**  
    - 유지보수 용이성과 자동화된 환경 구축의 장점이 크기 때문.  
*   **Immutable 인프라가 확장 가능하고 안정적인 인프라 구축에 효과적**  
    - 클라우드 환경에서 대규모 확장을 고려할 때, Immutable 방식을 적용하는 것이 유리함.  

## 6. 연속적 통합(Continuous Integration)
- 출처: [What is Continuous Integration?](https://www.youtube.com/watch?v=1er2cjUq1UI&list=PLOspHqNVtKAAm1dmyiR9WMmw1UBoOwZVj&index=6)

### **6.1 문제점: 통합 지옥 (Merge Hell)**

*   **과거 방식:** 개발자(Alice, Bob 등)가 각자 독립적인 기능을 오랫동안 개발한 후 한꺼번에 통합하는 방식.  
*   **문제 발생:**  
    *   코드 충돌(Merge Conflict) 증가로 인해 개발 속도 저하.  
    *   호환성 문제로 인해 예상치 못한 버그 다수 발생.  
    *   프로젝트 규모가 커질수록 파일 수 및 개발자 수 증가 → 통합 과정의 복잡도 급증.  
    *   통합 과정에서 수정해야 할 사항이 많아지고 일정 지연 발생 → "통합 지옥"으로 이어짐.  

### **6.2 해결책 1: 빈번한 통합**  

*   **핵심 원칙:**  
    *   "고통스럽다면 자주 하라. 그러면 덜 고통스러워진다."  
    *   즉, 자주 통합할수록 충돌이 작아지고 해결이 쉬워짐.  
*   **방식:**  
    *   Alice가 새로운 기능을 개발하면서 부분적으로 작동하는 상태에서 소스 컨트롤에 자주 반영(커밋 및 푸시).  
    *   Bob이 작업을 시작하기 전에 항상 최신 코드를 가져와 반영된 변경 사항을 기반으로 개발.  
    *   Alice와 Bob 모두 정기적으로 최신 코드를 받아 자신의 코드와 함께 통합하며 작업 진행.  
*   **효과:**  
    *   코드 충돌 가능성 감소 → 나중에 대규모 충돌을 해결해야 하는 부담 감소.  
    *   충돌이 발생하더라도 최근 작업 내역이므로 원인 파악 및 해결이 용이.  
    *   "통합 지옥"을 미연에 방지하여 개발 속도와 효율성 향상.  

### **6.3 해결책 2: 자동화된 빌드 및 테스트**  

*   **문제점:**  
    *   빈번한 통합은 코드 안정성을 유지하는 것이 중요함.  
    *   그러나 수동으로 빌드 및 테스트를 수행하면 시간이 많이 소요되고, 사람이 놓칠 수 있는 오류 발생 가능성 존재.  
*   **해결책: 자동화 시스템 도입**  
    *   **자동화 프로세스:**  
        1. 코드 변경 사항을 감지하면 자동으로 빌드 시작.  
        2. 빌드 후 유닛 테스트 실행하여 코드의 정상 작동 여부 확인.  
        3. 테스트 실패 시, 관련 개발자(Alice, Bob, 팀 전체)에게 즉각 알림 발송.  
*   **효과:**  
    *   코드 안정성 유지 → 지속적으로 빌드 가능한 상태를 확보.  
    *   개발자들이 코드 변경 시마다 즉각 피드백을 받아 빠른 수정 가능.  
    *   QA(테스트) 팀이 항상 최신 코드 기반에서 검증 가능하여 품질 보장.  

### **6.4 결론: 연속적 통합의 장점**  

*   **빈번한 통합 + 자동화된 빌드 및 테스트**를 통해 "통합 지옥"을 예방.  
*   코드 충돌을 줄이고, 문제 발생 시 빠르게 해결 가능하여 개발 생산성 향상.  
*   언제든지 테스트 및 배포 가능한 상태 유지 → 안정적인 소프트웨어 개발 환경 조성.  

## 7. DevSecOps
- 출처: [What is DevSecOps?](https://www.youtube.com/watch?v=J73MELGF6u0&list=PLOspHqNVtKAAm1dmyiR9WMmw1UBoOwZVj&index=7)

### **7.1 정의**  
- DevSecOps는 DevOps의 원칙을 따르면서도 보안을 소프트웨어 개발 라이프사이클(SDLC) 전반에 걸쳐 통합하는 접근 방식이다. 
- 기존 DevOps가 개발(Development)과 운영(Operations)의 협업을 중시했다면, 
- DevSecOps는 여기에 보안(Security)을 추가하여 초기 설계 단계부터 배포 및 운영까지 보안이 지속적으로 적용되도록 한다. 이를 통해 소프트웨어의 품질과 신뢰성을 높이며, 보안 사고를 사전에 예방할 수 있다.

### **7.2 DevSecOps의 주요 이점**

1. **관찰 가능성 (Observability)**  
애플리케이션 전달 프로세스의 투명성을 높여 각 단계에서 진행 상황을 명확히 파악할 수 있도록 한다.  
- **프로세스 흐름:** 사용자 스토리 → 코드 → 빌드 → 배포 → 관리 → 지속적 개선  
- 각 단계에서 로그, 메트릭, 트레이스 정보를 수집하여 개발팀과 운영팀이 문제를 조기에 식별할 수 있도록 지원  

2. **추적 가능성 (Traceability)**  
배포된 코드가 어떤 사용자 스토리에서 시작되었는지, 현재 런타임 환경에서 어떻게 운영되고 있는지를 증명할 수 있도록 한다.  
- 소프트웨어 개발 라이프사이클(SDLC) 전반에 걸쳐 모든 변경 사항을 기록하여 문제 발생 시 신속한 대응 가능  
- CI/CD 파이프라인과 연계된 변경 관리 시스템을 활용하여 이력 관리 강화  

3. **신뢰성 (Confidence)**  
비즈니스 요구사항과 IT 조직이 제공하는 결과물이 일치하는지에 대한 신뢰를 높인다.  
- **테스트 자동화 및 품질 보장:** 요구사항 기반 테스트 작성, 코드 품질 검증 도구 활용  
- **피드백 루프 개선:** 지속적인 모니터링과 로그 분석을 통해 성능과 안정성을 유지  

4. **규정 준수 (Compliance)**  
의료, 공공, 금융 등 산업별 규제 준수를 DevSecOps 프로세스에 내장하여 운영 리스크를 최소화한다.  
- **사전 대응적 보안 적용:** 보안 정책을 코드로 정의(Infrastructure as Code, Policy as Code)  
- **자동화된 감시:** 감사 로그 자동 수집 및 정책 위반 시 즉각적인 경고 발생  
- **설계 단계부터 보안 고려:** GDPR, HIPAA, ISO 27001 등의 규정을 코드 및 CI/CD 프로세스에 반영  

### **7.3 DevSecOps 활동 (파이프라인 전반에 걸쳐 리스크 완화 활동 포함)**  

| **단계** | **주요 활동** |
|----------|-------------|
| **사용자 스토리** | - 적절한 크기의 사용자 스토리를 정의하여 개발팀이 쉽게 이해하고 구현할 수 있도록 함  |
| **코드** | - 테스트 주도 개발(TDD) 적용<br>- 페어 프로그래밍 활용<br>- 테스트 코드 커버리지 향상 (테스트 케이스 먼저 작성) |
| **빌드** | - 코드 린팅(Linting) 수행 (코드 스타일 및 규칙 준수 확인)<br>- 정적 분석(Static Analysis) 적용 (무한 루프, 미선언 변수 등 잠재적 취약점 검사) |
| **배포** | - Notary 서비스를 활용하여 컨테이너 이미지의 무결성 보장<br>- 서명된 아티팩트만 배포하도록 정책 적용 |
| **관리** | - 변이 감지(Mutation Detection) 기능을 활용하여 런타임 환경에서 발생하는 취약점 식별 및 대응 |


### **7.4 DevSecOps 활용 사례**  

1. **애플리케이션 진행 과정의 투명성 확보**  
   - 어떤 코드가, 누구에 의해, 언제, 어떤 환경에 배포되었는지를 명확히 파악할 수 있음  
   - 배포 과정에서 발생하는 오류 및 보안 문제를 조기에 발견하여 신속한 조치 가능  

2. **감사 대응 및 규제 준수 강화**  
   - 파이프라인 전반에 걸쳐 자동으로 감사 데이터를 수집하여 규정 준수를 입증  
   - 외부 감사 요구에 신속히 대응할 수 있도록 보안 로그 및 변경 이력 관리  

3. **전사적 거버넌스 일관성 유지**  
   - 기업 전체적으로 동일한 보안 정책과 코드 품질 기준을 적용  
   - 보안 자동화를 통해 개발자가 별도의 보안 지식 없이도 안전한 코드를 작성할 수 있도록 지원  

4. **기업 평판 보호 및 리스크 완화**  
   - 보안 사고 및 데이터 유출을 사전에 방지하여 기업 신뢰도 유지  
   - 공급망 보안(Supply Chain Security) 강화로 서드파티 라이브러리 및 종속성 관리  

## 8. 지속적 개선(Continuous Improvement)
- 출처: [What is Continuous Improvement?](https://www.youtube.com/watch?v=iITmoI0s1DQ&list=PLOspHqNVtKAAm1dmyiR9WMmw1UBoOwZVj&index=8)

### **8.1 지속적 개선(Continuous Improvement)이란 무엇인가?**  

- **목표**  
    - 애플리케이션 전달 파이프라인의 **속도 및 품질을 향상**시키고, 이를 통해 **고객 경험을 지속적으로 개선**하는 것이 궁극적인 목표이다. 
    - 이를 위해 개발, 운영, 보안팀이 협력하여 자동화, 프로세스 최적화, 데이터 기반 의사 결정을 수행한다.  


### **8.2 지속적 개선의 중요성**  
지속적 개선은 단순한 일회성 조치가 아니라, **지속적인 학습과 최적화를 통해 프로세스를 발전시키는 철학적 접근 방식**이다. 이를 위해 다음과 같은 활동이 필요하다.  

- **자동화 도구 투자:**  
  - 반복적인 수작업을 최소화하여 개발 및 배포 속도를 높이고, 일관된 품질을 유지  
  - CI/CD(Continuous Integration/ Deployment) 파이프라인을 최적화, 배포 주기를 단축  

- **거버넌스 프로세스 수정:**  
  - 보안 및 규제 준수를 위한 자동화된 정책 적용 (예: Infrastructure as Code, Policy as Code 활용)  
  - 조직 내 개발 표준 및 코드 리뷰 프로세스 개선  

- **인력 투자:**  
  - 개발자 및 운영자의 역량 강화를 위한 교육과 지속적인 피드백 문화 조성  
  - DevSecOps 및 SRE(Site Reliability Engineering) 원칙 적용  

- **경험적 데이터 기반 성과 분석:**  
  - 속도 향상 및 결함 감소를 측정하여 **투자 대비 효과(ROI)** 를 정량화  
  - 애플리케이션 성능과 고객 만족도를 분석하여 데이터 기반 개선 추진  
  - 제품 출시 속도를 높이는 동시에, **사용자 친화적인 디지털 경험을 제공**하여 소비자 공감 형성  

### **8.3 핵심 성과 지표(KPI) 정의 및 측정**  
지속적 개선을 효과적으로 수행하기 위해서는 **측정 가능한 KPI(Key Performance Indicators)** 가 필요하다. **ROI를 정량화하고, 개선 목표를 명확히 설정**하는 것이 중요하다.  

- **배포 빈도(Deployment Frequency):**  
  - 프로덕션 환경으로 배포가 이루어지는 횟수 (일간, 주간, 월간 단위)  
  - **배포 빈도가 높을수록 빠른 피드백 루프가 가능**하여 개선 주기가 짧아짐  

- **전달 리드 타임(Delivery Lead Time):**  
  - 코드 작성에서 프로덕션 배포까지 걸리는 시간  
  - **리드 타임이 짧을수록 변화 적용이 빠르고 민첩한 대응 가능**  

- **변경량(Change Volume):**  
  - 한 번의 릴리스에서 프로덕션 환경으로 배포되는 **스토리 포인트(기능 개선, 버그 수정 등)의 크기**  
  - 지나치게 큰 변경은 위험 요소 증가, 작은 변경을 자주 수행하는 것이 이상적  

- **평균 복구 시간(Mean Time to Recovery, MTTR):**  
  - 프로덕션 환경에서 오류가 발생했을 때 **수정 및 재배포까지 걸리는 평균 시간**  
  - **MTTR이 짧을수록 장애 대응이 빠르고 시스템의 신뢰성 향상**  

### **8.4 개선 전략**  

지속적 개선을 위해서는 **현재 프로세스의 문제점을 식별하고 해결 방안을 모색하는 과정이 필수적**이다.  

- **계측 부족 문제 해결:**  
  - 파이프라인 내 데이터 수집이 부족할 경우, 모니터링 및 로깅 시스템을 구축하여 경험적 데이터를 확보  
  - APM(Application Performance Monitoring) 및 Observability 도구(New Relic, Prometheus, Grafana 등) 활용  

- **투자 금액과 ROI 연결 문제 해결:**  
  - 개선 활동이 실제 **비즈니스 성과에 기여하는지 평가**하기 위해 재무적 ROI 분석 필요  
  - KPI 데이터와 비용 데이터를 결합하여 정량적 분석 수행  

### **8.5 개선 방법**  

- **KPI 기반 성과 측정:**  
  - 성공적인 ROI 측정을 위해 **각 단계별 성과를 평가할 KPI를 정의**  
  - 개발팀, 운영팀, 보안팀 간 **공유된 목표 설정 및 진행 상황 시각화**  

- **파이프라인 계측 및 데이터 분석:**  
  - 애플리케이션이 CI/CD 파이프라인을 거치는 동안 걸리는 시간, 오류 발생률 등을 수집하여 **병목 현상을 파악**  
  - 로그 분석 및 AIOps(AI for IT Operations)를 활용하여 **데이터 기반 의사 결정 수행**  

- **병목 현상 제거 및 자동화 강화:**  
  - 코드 리뷰 및 테스트 자동화를 통해 배포 속도를 개선  
  - 릴리스 프로세스를 단순화하여 배포 리스크 감소  
  - 지속적 피드백 문화를 정착시켜 **개발팀의 효율성과 품질을 동시에 향상**  

### **8.6 지속적 개선의 3요소**  

지속적 개선이 효과적으로 작동하려면 **세 가지 핵심 요소가 균형을 이루어야 한다.**  

- **사람(People):**  
  - 개발자, 운영팀, 보안팀이 원활하게 협업할 수 있도록 조직 문화 조성  
  - DevOps 및 Agile 마인드셋 교육, 지속적인 피드백 루프 구축  

- **프로세스(Process):**  
  - CI/CD 및 DevSecOps 등 **자동화된 개발 및 운영 프로세스 적용**  
  - 릴리스 관리 최적화, 코드 리뷰 및 테스트 자동화 수행  

- **도구(Tools):**  
  - **효율적인 모니터링 및 배포 도구 활용** (예: GitHub Actions, Jenkins, ArgoCD, Kubernetes)  
  - 애플리케이션 성능 분석 및 장애 감지를 위한 APM 솔루션 도입  


## 9. 지속적 배포(Continuous Delivery)
- 출처: [What is Continuous Delivery?](https://www.youtube.com/watch?v=2TTU5BB-k9U&list=PLOspHqNVtKAAm1dmyiR9WMmw1UBoOwZVj&index=9)

### **9.1 지속적 배포의 핵심 원칙**  
지속적 배포(Continuous Delivery, CD)는 고객에게 가치 있는 소프트웨어를 빠르고 지속적으로 제공하는 것을 목표로 한다. 이를 위해 코드 변경 사항이 자동화된 테스트와 승인 프로세스를 거쳐 신속하게 프로덕션 환경에 반영될 수 있어야 한다.


### **9.2 지속적 배포 프로세스**  
CD의 전반적인 과정은 코드 개발부터 프로덕션 배포까지 일련의 단계로 구성된다.

1. **빌드(Build)**  
   - 개발자가 작성한 소스 코드를 실행 가능한 소프트웨어로 변환하는 단계  
   - 빌드 자동화를 통해 코드 변경 사항이 즉시 반영되도록 설정  
   - 코드 품질 검사 및 종속성 관리 수행  

2. **테스트(Test)**  
   - 프로덕션 환경에 배포하기 전에 소프트웨어가 안정적으로 동작하는지 확인  
   - 자동화된 테스트(단위 테스트, 통합 테스트, UI 테스트 등)를 활용하여 품질 보장  
   - QA 환경, 성능 테스트(Performance), 스테이징(Staging) 환경에서 테스트 수행  

3. **배포(Deploy)**  
   - **QA 환경 배포:** 기본적인 기능 테스트 수행  
   - **Staging 환경 배포:** 실서비스와 유사한 환경에서 최종 테스트 진행  
   - **프로덕션 환경 배포:**  
     - 최종 검토 및 승인 프로세스 필요  
     - 배포 후 모니터링을 통해 문제가 발생할 경우 롤백(Rollback) 가능하도록 구성  

### **9.3 주요 활동**  

1. **자동 배포(Auto Deploy)**  
   - 빌드된 소프트웨어를 각 환경(QA, Staging, Production)으로 자동 이동  
   - Application Release Automation(ARA) 및 CD Pipeline을 활용하여 배포 프로세스 자동화  
   - 환경 간 배포 순서 및 규칙을 설정하여 일관된 배포 프로세스 유지  

2. **지속적인 테스팅(Continuous Testing)**  
   - CI/CD 파이프라인 내에서 각 환경에서 자동화된 테스트를 수행  
   - 새로운 코드가 추가될 때마다 테스트가 실행되어 빠르게 오류를 감지  
   - CI 서버(Jenkins, GitHub Actions, GitLab CI/CD 등)를 활용하여 테스트 자동화  

3. **거버넌스(Governance)**  
   - Staging 환경에서 프로덕션으로 이동할 때 추가적인 승인 과정 필요  
   - 조직의 변경 관리 정책(Change Management Policy)에 따라 승인 절차 적용  
   - 일정 수준 이상의 위험을 수반하는 변경 사항은 변경 승인 위원회(CAB)의 심사를 거칠 수도 있음  

### **9.4 자동화된 배포 예시**  

1. 개발자가 GitHub에 코드 커밋(Commit)  
2. CI 서버(Jenkins, GitHub Actions 등)가 변경 사항을 감지하여 자동 빌드 수행  
3. 빌드된 애플리케이션을 QA 환경에 자동 배포 후 테스트 실행  
4. QA 테스트를 통과한 코드가 Staging 환경에 자동 배포되어 최종 점검  
5. 프로덕션 배포 전 승인 단계 (예: 변경 승인 위원회(CAB) 승인 또는 자동화된 정책 기반 승인)  
6. 모든 테스트와 승인 절차가 완료되면 프로덕션 환경으로 배포  
7. 배포 후 모니터링을 통해 성능 및 안정성을 지속적으로 점검  


## 10. Continuous Deployment vs. Continuous Delivery
- 출처: [Continuous Deployment vs. Continuous Delivery](https://www.youtube.com/watch?v=LNLKZ4Rvk8w&list=PLOspHqNVtKAAm1dmyiR9WMmw1UBoOwZVj&index=10)


### **10.1 공통점**  
Continuous Deployment(지속적 배포)와 Continuous Delivery(지속적 전달)는 모두 DevOps 및 CI/CD(Continuous Integration/Continuous Deployment) 개념의 일부로, 배포 프로세스를 자동화하여 개발 효율성을 높이는 것을 목표로 한다. 이 둘은 다음과 같은 공통점을 가진다.

*   **코드를 지속적 통합 도구로 빌드**: 코드 변경 사항이 있을 때마다 자동으로 빌드하여 실행 가능한 상태로 만든다.  
*   **테스트 환경(1개 이상)에 배포**: 변경된 코드가 운영 환경에 반영되기 전에 테스트 환경에서 충분한 검증이 이루어진다.  
*   **자동화된 테스트 수행**: 기능 테스트, 통합 테스트, 회귀 테스트 등 다양한 자동화된 테스트를 실행하여 코드의 안정성을 보장한다.  

### **10.2 차이점**

| 구분                  | Continuous Deployment (지속적 배포)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Continuous Delivery (지속적 전달)                                                                                                                                                                                                                                                                 |
| --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **정의**                | 코드 작성 후 사람의 개입 없이 자동으로 프로덕션 환경까지 배포.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | 코드의 빌드, 테스트, 릴리스 준비 단계를 자동화하고, 마지막 프로덕션 배포 단계에서 사람의 승인(결정)을 거침.                                                                                                                                                                                                    |
| **핵심**                | 완전 자동화, 강력한 테스트 자동화, 프로덕션 환경에서 테스트(카나리 배포), 강력한 모니터링                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | 자동화된 테스트, 마지막 단계에서 사람의 의사 결정 개입                                                                                                                                                                                                                                                          |
| **예시**                | IMVU: 하루 50번 프로덕션 배포 (소비자 대상 앱, 신용카드 정보 X)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | 대부분의 조직이 목표로 하는 방식 (규제 준수 필요, 충분한 테스트 환경 미비 등의 이유)                                                                                                                                                                                                                         |
| **장점**                | 빠른 배포 속도, 즉각적인 피드백 반영                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | 위험 감소 (사람의 판단 개입), 규제 준수 가능                                                                                                                                                                                                                                                           |
| **전제 조건**           | 탄탄한 자동화 테스트 환경, 프로덕션 환경 모니터링 시스템, 문제 발생 시 빠른 롤백 시스템                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | 자동화된 테스트 환경                                                                                                                                                                                                                                                                               |
| **적합한 상황**          | 위험 부담이 적은 서비스, 빠른 배포가 중요한 서비스                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | 규제 준수가 필요한 서비스, 충분한 테스트 환경 구축이 어려운 경우                                                                                                                                                                                                                                  |
| **결론**                | Continuous Deployment는 극단적인 접근 방식이지만, 올바른 상황에서는 효과적일 수 있음.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Continuous Delivery는 대부분의 조직이 목표로 하며, 비즈니스 결정에 따라 릴리스 여부를 결정하는 방식.                                                                                                                                                                                                        |
| **참고** | 코드 리뷰를 통해 다른 개발자의 확인 절차를 추가하고, 테스트를 통해 안전망을 확보할 수 있음.  |  |                                                    

### **10.3 결론**
- Continuous Deployment와 Continuous Delivery는 모두 CI/CD 파이프라인을 최적화하는 중요한 방법론이다. 
- 그러나 적용 가능한 환경과 요구 사항이 다르므로, 조직의 배포 전략을 결정할 때 각 방식의 장점과 단점을 고려해야 한다. 
- 핵심은 **자동화를 통해 배포 과정을 효율적으로 만들고, 신뢰성을 확보하는 것**이며, 이를 위해 적절한 테스트와 모니터링 시스템을 갖추는 것이 필수적이다.