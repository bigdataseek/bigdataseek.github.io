---
title: 8차시 3:Neuralnine(자료 구조 1)
layout: single
classes: wide
categories:
  - Data Structure
toc: true # 이 포스트에서 목차를 활성화
toc_sticky: true # 목차를 고정할지 여부 (선택 사항)
---

## 1. 연결 리스트 (Linked List)

### 1.1 개념 설명
연결 리스트는 데이터를 담은 "상자(노드)"들이 줄줄이 연결된 구조입니다. 각 상자는 **값**과 **다음 상자의 위치**를 기억합니다. 파이썬의 리스트처럼 보이지만, 메모리상에서 연속되어 있지 않고 각자 흩어져 있다는 차이가 있습니다.

**장점**: 중간에 데이터를 삽입/삭제할 때 유리합니다.
**단점**: 특정 위치의 데이터에 바로 접근할 수 없어 처음부터 찾아가야 합니다.

### 1.2 샘플 코드

```python
# 단일 연결 리스트 (Singly Linked List)

class Node:
    """연결 리스트의 각 노드"""
    def __init__(self, value):
        self.value = value
        self.next = None  # 다음 노드를 가리킴

class LinkedList:
    """단일 연결 리스트 구현"""
    def __init__(self):
        self.head = None  # 리스트의 시작점
    
    def prepend(self, value):
        """맨 앞에 추가 - O(1)"""
        new_node = Node(value)
        new_node.next = self.head
        self.head = new_node
    
    def append(self, value):
        """맨 뒤에 추가 - O(N)"""
        new_node = Node(value)
        
        if not self.head:  # 비어있는 경우
            self.head = new_node
            return
        
        # 마지막 노드까지 이동
        current = self.head
        while current.next:
            current = current.next
        current.next = new_node
    
    def search(self, value):
        """값 찾기 - O(N)"""
        current = self.head
        while current:
            if current.value == value:
                return True
            current = current.next
        return False
    
    def display(self):
        """리스트 출력"""
        elements = []
        current = self.head
        while current:
            elements.append(str(current.value))
            current = current.next
        print(" -> ".join(elements))

# 사용 예제
print("=== 단일 연결 리스트 ===")
ll = LinkedList()
ll.append(10)
ll.append(20)
ll.prepend(5)
ll.append(30)

print("리스트 내용:")
ll.display()  # 5 -> 10 -> 20 -> 30

print(f"\n20이 있나요? {ll.search(20)}")  # True
print(f"100이 있나요? {ll.search(100)}")  # False


# 이중 연결 리스트 (Doubly Linked List)

class DNode:
    """이중 연결 리스트의 노드"""
    def __init__(self, value):
        self.value = value
        self.next = None  # 다음 노드
        self.prev = None  # 이전 노드

class DoublyLinkedList:
    """이중 연결 리스트 구현"""
    def __init__(self):
        self.head = None
        self.tail = None  # 마지막 노드를 추적
    
    def append(self, value):
        """맨 뒤에 추가 - O(1)"""
        new_node = DNode(value)
        
        if not self.head:  # 비어있는 경우
            self.head = new_node
            self.tail = new_node
            return
        
        # tail을 사용하여 바로 추가
        self.tail.next = new_node
        new_node.prev = self.tail
        self.tail = new_node
    
    def prepend(self, value):
        """맨 앞에 추가 - O(1)"""
        new_node = DNode(value)
        
        if not self.head:
            self.head = new_node
            self.tail = new_node
            return
        
        new_node.next = self.head
        self.head.prev = new_node
        self.head = new_node
    
    def display_forward(self):
        """앞에서 뒤로 출력"""
        elements = []
        current = self.head
        while current:
            elements.append(str(current.value))
            current = current.next
        print(" <-> ".join(elements))
    
    def display_backward(self):
        """뒤에서 앞으로 출력"""
        elements = []
        current = self.tail
        while current:
            elements.append(str(current.value))
            current = current.prev
        print(" <-> ".join(elements))

# 사용 예제
print("\n\n=== 이중 연결 리스트 ===")
dll = DoublyLinkedList()
dll.append(10)
dll.append(20)
dll.prepend(5)
dll.append(30)

print("앞에서 뒤로:")
dll.display_forward()  # 5 <-> 10 <-> 20 <-> 30

print("\n뒤에서 앞으로:")
dll.display_backward()  # 30 <-> 20 <-> 10 <-> 5
```


## 2. 스택 (Stack)

### 2.1 개념 설명
스택은 "쌓아올린다"는 의미 그대로, 접시를 쌓듯이 데이터를 관리합니다. **후입선출(LIFO: Last In First Out)** 원칙을 따릅니다. 가장 마지막에 넣은 것이 가장 먼저 나옵니다.

**실생활 예시**:
- 웹브라우저의 뒤로 가기 버튼
- 함수 호출 스택 (재귀 함수)
- Ctrl+Z (실행 취소)

### 2.2 샘플 코드

```python 
# 스택 (Stack) 구현

class Stack:
    """리스트 기반 스택 구현"""
    def __init__(self):
        self.items = []
    
    def push(self, item):
        """스택에 추가 - O(1)"""
        self.items.append(item)
    
    def pop(self):
        """스택에서 제거하고 반환 - O(1)"""
        if self.is_empty():
            return None
        return self.items.pop()
    
    def peek(self):
        """맨 위 요소 확인 - O(1)"""
        if self.is_empty():
            return None
        return self.items[-1]
    
    def is_empty(self):
        """비어있는지 확인"""
        return len(self.items) == 0
    
    def size(self):
        """스택 크기"""
        return len(self.items)
    
    def display(self):
        """스택 내용 출력 (위에서 아래로)"""
        if self.is_empty():
            print("스택이 비어있습니다")
            return
        
        print("스택 내용 (위 -> 아래):")
        for item in reversed(self.items):
            print(f"  [{item}]")

# 사용 예제
print("=== 스택 예제 1: 기본 동작 ===")
stack = Stack()

stack.push(10)
stack.push(20)
stack.push(30)
stack.display()

print(f"\n맨 위 요소: {stack.peek()}")  # 30
print(f"pop: {stack.pop()}")  # 30
print(f"pop: {stack.pop()}")  # 20
stack.display()


# 실전 활용 예제: 괄호 짝 맞추기
def check_balanced_parentheses(expression):
    """괄호의 짝이 올바른지 검사"""
    stack = Stack()
    pairs = {')': '(', ']': '[', '}': '{'}
    
    for char in expression:
        if char in '([{':
            stack.push(char)
        elif char in ')]}':
            if stack.is_empty():
                return False
            if stack.pop() != pairs[char]:
                return False
    
    return stack.is_empty()

print("\n\n=== 스택 예제 2: 괄호 검사 ===")
test_cases = [
    "((a + b) * c)",
    "({a + [b * c]})",
    "((a + b)",
    "a + b)",
    "{[()]}"
]

for expr in test_cases:
    result = check_balanced_parentheses(expr)
    print(f"{expr:20} -> {'올바름' if result else '잘못됨'}")


# 실전 활용 예제: 문자열 뒤집기
def reverse_string(text):
    """스택을 이용한 문자열 뒤집기"""
    stack = Stack()
    
    # 모든 문자를 스택에 push
    for char in text:
        stack.push(char)
    
    # pop하면서 새 문자열 만들기
    reversed_text = ""
    while not stack.is_empty():
        reversed_text += stack.pop()
    
    return reversed_text

print("\n\n=== 스택 예제 3: 문자열 뒤집기 ===")
original = "Hello, World!"
reversed_str = reverse_string(original)
print(f"원본: {original}")
print(f"뒤집기: {reversed_str}")


# 실전 활용 예제: 웹브라우저 뒤로가기
class Browser:
    """스택을 이용한 간단한 브라우저 히스토리"""
    def __init__(self):
        self.history = Stack()
        self.current_page = None
    
    def visit(self, url):
        """새 페이지 방문"""
        if self.current_page:
            self.history.push(self.current_page)
        self.current_page = url
        print(f"방문: {url}")
    
    def back(self):
        """뒤로 가기"""
        if self.history.is_empty():
            print("이전 페이지가 없습니다")
            return
        
        self.current_page = self.history.pop()
        print(f"뒤로 가기: {self.current_page}")
    
    def show_current(self):
        """현재 페이지 표시"""
        print(f"현재 페이지: {self.current_page}")

print("\n\n=== 스택 예제 4: 브라우저 히스토리 ===")
browser = Browser()
browser.visit("google.com")
browser.visit("youtube.com")
browser.visit("github.com")
browser.show_current()
browser.back()
browser.back()
browser.show_current()
```


## 3. 큐 (Queue)

### 3.1 개념 설명
큐는 줄을 서는 것과 같습니다. **선입선출(FIFO: First In First Out)** 원칙을 따릅니다. 먼저 들어온 것이 먼저 나갑니다.

**실생활 예시**:
- 은행 대기줄
- 프린터 출력 대기
- 작업 스케줄링

### 3.2 샘플 코드

```python
# 큐 (Queue) 구현

from collections import deque

class Queue:
    """deque를 이용한 효율적인 큐 구현"""
    def __init__(self):
        self.items = deque()
    
    def enqueue(self, item):
        """큐에 추가 (뒤쪽) - O(1)"""
        self.items.append(item)
    
    def dequeue(self):
        """큐에서 제거 (앞쪽) - O(1)"""
        if self.is_empty():
            return None
        return self.items.popleft()
    
    def front(self):
        """맨 앞 요소 확인 - O(1)"""
        if self.is_empty():
            return None
        return self.items[0]
    
    def is_empty(self):
        """비어있는지 확인"""
        return len(self.items) == 0
    
    def size(self):
        """큐 크기"""
        return len(self.items)
    
    def display(self):
        """큐 내용 출력"""
        if self.is_empty():
            print("큐가 비어있습니다")
            return
        
        print("큐 내용 (앞 -> 뒤):", end=" ")
        print(" <- ".join(str(item) for item in self.items))

# 사용 예제
print("=== 큐 예제 1: 기본 동작 ===")
queue = Queue()

queue.enqueue("첫 번째 손님")
queue.enqueue("두 번째 손님")
queue.enqueue("세 번째 손님")
queue.display()

print(f"\n처리: {queue.dequeue()}")
print(f"처리: {queue.dequeue()}")
queue.display()


# 실전 활용 예제: 프린터 대기열
class PrintJob:
    """출력 작업"""
    def __init__(self, document_name, pages):
        self.document_name = document_name
        self.pages = pages
    
    def __str__(self):
        return f"{self.document_name} ({self.pages}페이지)"

class Printer:
    """큐를 이용한 프린터 시뮬레이션"""
    def __init__(self):
        self.queue = Queue()
    
    def add_job(self, job):
        """출력 작업 추가"""
        self.queue.enqueue(job)
        print(f"작업 추가: {job}")
    
    def process_next(self):
        """다음 작업 처리"""
        if self.queue.is_empty():
            print("대기 중인 작업이 없습니다")
            return
        
        job = self.queue.dequeue()
        print(f"출력 중: {job}")
    
    def show_queue(self):
        """대기열 표시"""
        if self.queue.is_empty():
            print("대기 중인 작업이 없습니다")
            return
        
        print(f"\n대기 중인 작업 ({self.queue.size()}개):")
        for i, job in enumerate(self.queue.items, 1):
            print(f"  {i}. {job}")

print("\n\n=== 큐 예제 2: 프린터 대기열 ===")
printer = Printer()

printer.add_job(PrintJob("보고서.pdf", 10))
printer.add_job(PrintJob("이력서.docx", 2))
printer.add_job(PrintJob("사진.jpg", 1))

printer.show_queue()

print("\n[작업 처리 시작]")
printer.process_next()
printer.process_next()

printer.show_queue()


# 실전 활용 예제: 고객 서비스 센터
class Customer:
    """고객"""
    def __init__(self, name, ticket_number):
        self.name = name
        self.ticket_number = ticket_number
    
    def __str__(self):
        return f"{self.name} (번호: {self.ticket_number})"

class ServiceCenter:
    """큐를 이용한 고객 서비스 센터"""
    def __init__(self):
        self.queue = Queue()
        self.next_ticket = 1
    
    def take_ticket(self, name):
        """대기 번호표 받기"""
        customer = Customer(name, self.next_ticket)
        self.queue.enqueue(customer)
        print(f"{name}님, 대기번호 {self.next_ticket}번입니다")
        self.next_ticket += 1
    
    def call_next(self):
        """다음 고객 호출"""
        if self.queue.is_empty():
            print("대기 중인 고객이 없습니다")
            return
        
        customer = self.queue.dequeue()
        print(f"\n[호출] {customer}님, 창구로 오세요!")
    
    def show_waiting(self):
        """대기 현황"""
        if self.queue.is_empty():
            print("대기 중인 고객이 없습니다")
            return
        
        print(f"\n현재 대기 인원: {self.queue.size()}명")
        for customer in self.queue.items:
            print(f"  - {customer}")

print("\n\n=== 큐 예제 3: 고객 서비스 센터 ===")
center = ServiceCenter()

center.take_ticket("김철수")
center.take_ticket("이영희")
center.take_ticket("박민수")

center.show_waiting()

center.call_next()
center.call_next()

center.show_waiting()


# 참고: 리스트만으로 큐 구현 (비효율적)
class SimpleQueue:
    """리스트만 사용한 큐 (학습용)"""
    def __init__(self):
        self.items = []
    
    def enqueue(self, item):
        """추가 - O(1)"""
        self.items.append(item)
    
    def dequeue(self):
        """제거 - O(N) 비효율적!"""
        if not self.items:
            return None
        return self.items.pop(0)  # 첫 요소 제거는 느림

print("\n\n=== 참고: 리스트 기반 큐 ===")
print("리스트의 pop(0)은 O(N) 시간이 걸립니다")
print("실전에서는 deque를 사용하세요!")
```

## 4. 해시맵 (Hashmap / Dictionary)

### 4.1 개념 설명
해시맵은 **키(key)**를 사용하여 **값(value)**을 빠르게 찾는 자료 구조입니다. 파이썬의 `dict`가 바로 해시맵입니다! 해시 함수를 사용하여 키를 배열의 인덱스로 변환합니다.

**장점**: 평균적으로 O(1) 시간에 데이터를 추가/검색/삭제할 수 있습니다.
**단점**: 해시 충돌이 발생할 수 있고, 순서가 보장되지 않습니다(파이썬 3.7+ 제외).

### 4.2 샘플 코드

```python
# 해시맵 (Hashmap) 직접 구현

class HashMap:
    """간단한 해시맵 구현 (체이닝 방식)"""
    def __init__(self, size=10):
        self.size = size
        # 각 버킷은 리스트 (충돌 처리용)
        self.buckets = [[] for _ in range(size)]
    
    def _hash(self, key):
        """해시 함수 - 키를 인덱스로 변환"""
        return hash(key) % self.size
    
    def put(self, key, value):
        """키-값 쌍 추가/수정 - 평균 O(1)"""
        index = self._hash(key)
        bucket = self.buckets[index]
        
        # 이미 키가 있으면 값 업데이트
        for i, (k, v) in enumerate(bucket):
            if k == key:
                bucket[i] = (key, value)
                return
        
        # 새 키-값 쌍 추가
        bucket.append((key, value))
    
    def get(self, key):
        """키로 값 찾기 - 평균 O(1)"""
        index = self._hash(key)
        bucket = self.buckets[index]
        
        for k, v in bucket:
            if k == key:
                return v
        
        return None  # 키가 없음
    
    def remove(self, key):
        """키-값 쌍 삭제 - 평균 O(1)"""
        index = self._hash(key)
        bucket = self.buckets[index]
        
        for i, (k, v) in enumerate(bucket):
            if k == key:
                del bucket[i]
                return True
        
        return False  # 키가 없음
    
    def contains(self, key):
        """키 존재 여부 확인"""
        return self.get(key) is not None
    
    def keys(self):
        """모든 키 반환 - O(N)"""
        all_keys = []
        for bucket in self.buckets:
            for k, v in bucket:
                all_keys.append(k)
        return all_keys
    
    def values(self):
        """모든 값 반환 - O(N)"""
        all_values = []
        for bucket in self.buckets:
            for k, v in bucket:
                all_values.append(v)
        return all_values
    
    def items(self):
        """모든 키-값 쌍 반환 - O(N)"""
        all_items = []
        for bucket in self.buckets:
            for item in bucket:
                all_items.append(item)
        return all_items
    
    def display(self):
        """해시맵 내용 표시 (디버깅용)"""
        print(f"\n해시맵 (크기: {self.size}):")
        for i, bucket in enumerate(self.buckets):
            if bucket:
                print(f"  버킷 {i}: {bucket}")

# 사용 예제
print("=== 해시맵 예제 1: 기본 동작 ===")
hm = HashMap(size=5)

hm.put("apple", 1000)
hm.put("banana", 500)
hm.put("orange", 800)
hm.put("grape", 1500)

hm.display()

print(f"\napple의 가격: {hm.get('apple')}원")
print(f"banana의 가격: {hm.get('banana')}원")
print(f"mango의 가격: {hm.get('mango')}")  # None

print(f"\napple이 있나요? {hm.contains('apple')}")
print(f"mango가 있나요? {hm.contains('mango')}")


# 실전 활용 예제: 단어 빈도수 세기
def count_word_frequency(text):
    """텍스트에서 각 단어의 빈도수 계산"""
    # 파이썬 딕셔너리 사용 (내부적으로 해시맵)
    frequency = {}
    
    # 단어 추출 (소문자 변환, 구두점 제거)
    words = text.lower().replace(',', '').replace('.', '').split()
    
    for word in words:
        if word in frequency:
            frequency[word] += 1
        else:
            frequency[word] = 1
    
    return frequency

print("\n\n=== 해시맵 예제 2: 단어 빈도수 ===")
text = "Hello world, hello Python. Python is great and world is beautiful."
freq = count_word_frequency(text)

print("단어 빈도수:")
for word, count in sorted(freq.items(), key=lambda x: x[1], reverse=True):
    print(f"  {word}: {count}회")


# 실전 활용 예제: 전화번호부
class PhoneBook:
    """해시맵을 이용한 전화번호부"""
    def __init__(self):
        self.contacts = {}
    
    def add(self, name, phone):
        """연락처 추가"""
        self.contacts[name] = phone
        print(f"추가: {name} - {phone}")
    
    def search(self, name):
        """연락처 검색"""
        if name in self.contacts:
            return self.contacts[name]
        return None
    
    def delete(self, name):
        """연락처 삭제"""
        if name in self.contacts:
            del self.contacts[name]
            print(f"삭제: {name}")
            return True
        return False
    
    def list_all(self):
        """모든 연락처 출력"""
        if not self.contacts:
            print("저장된 연락처가 없습니다")
            return
        
        print("\n전화번호부:")
        for name, phone in sorted(self.contacts.items()):
            print(f"  {name}: {phone}")

print("\n\n=== 해시맵 예제 3: 전화번호부 ===")
phonebook = PhoneBook()

phonebook.add("김철수", "010-1234-5678")
phonebook.add("이영희", "010-2345-6789")
phonebook.add("박민수", "010-3456-7890")

phonebook.list_all()

print(f"\n김철수의 번호: {phonebook.search('김철수')}")
print(f"홍길동의 번호: {phonebook.search('홍길동')}")

phonebook.delete("이영희")
phonebook.list_all()


# 실전 활용 예제: 중복 제거
def remove_duplicates(items):
    """리스트에서 중복 제거 (순서 유지)"""
    seen = {}
    result = []
    
    for item in items:
        if item not in seen:
            seen[item] = True
            result.append(item)
    
    return result

print("\n\n=== 해시맵 예제 4: 중복 제거 ===")
numbers = [1, 2, 3, 2, 4, 1, 5, 3, 6]
print(f"원본: {numbers}")
print(f"중복 제거: {remove_duplicates(numbers)}")


# 실전 활용 예제: 두 수의 합 찾기
def find_two_sum(numbers, target):
    """리스트에서 합이 target이 되는 두 수의 인덱스 찾기"""
    seen = {}  # 값: 인덱스
    
    for i, num in enumerate(numbers):
        complement = target - num
        if complement in seen:
            return [seen[complement], i]
        seen[num] = i
    
    return None

print("\n\n=== 해시맵 예제 5: 두 수의 합 ===")
nums = [2, 7, 11, 15]
target = 9
result = find_two_sum(nums, target)

if result:
    print(f"배열: {nums}")
    print(f"목표: {target}")
    print(f"답: 인덱스 {result[0]}과 {result[1]}")
    print(f"  {nums[result[0]]} + {nums[result[1]]} = {target}")


# 해시 충돌 시연
print("\n\n=== 해시 충돌 시연 ===")
hm_small = HashMap(size=3)  # 작은 크기로 충돌 유발

hm_small.put("cat", "고양이")
hm_small.put("dog", "강아지")
hm_small.put("bird", "새")
hm_small.put("fish", "물고기")

print("작은 해시맵에 여러 항목 추가 (충돌 발생 가능):")
hm_small.display()
print("\n같은 버킷에 여러 항목이 저장되면 체이닝으로 처리됩니다")
```

## 5. 이진 검색 트리 (Binary Search Tree, BST)

### 5.1 개념 설명
이진 검색 트리는 각 노드가 **최대 2개의 자식**(왼쪽, 오른쪽)을 가지는 트리 구조입니다. 중요한 규칙은:
- **왼쪽 자식 < 부모 < 오른쪽 자식**

이 규칙 덕분에 데이터를 빠르게 찾을 수 있습니다 (이진 검색처럼).

**장점**: 균형 잡혀 있으면 O(log N) 시간에 검색/삽입/삭제
**단점**: 불균형하면 O(N)으로 느려질 수 있음

### 5.2 샘플 코드

```python
# 이진 검색 트리 (Binary Search Tree)

class TreeNode:
    """트리의 노드"""
    def __init__(self, key, value=None):
        self.key = key
        self.value = value if value is not None else key
        self.left = None   # 왼쪽 자식
        self.right = None  # 오른쪽 자식
        self.parent = None # 부모 노드

class BinarySearchTree:
    """이진 검색 트리 구현"""
    def __init__(self):
        self.root = None
    
    def insert(self, key, value=None):
        """노드 삽입 - 평균 O(log N), 최악 O(N)"""
        if self.root is None:
            self.root = TreeNode(key, value)
            return
        
        self._insert_recursive(self.root, key, value)
    
    def _insert_recursive(self, node, key, value):
        """재귀적으로 삽입 위치 찾기"""
        if key < node.key:
            if node.left is None:
                node.left = TreeNode(key, value)
                node.left.parent = node
            else:
                self._insert_recursive(node.left, key, value)
        elif key > node.key:
            if node.right is None:
                node.right = TreeNode(key, value)
                node.right.parent = node
            else:
                self._insert_recursive(node.right, key, value)
        else:
            # 키가 이미 존재하면 값 업데이트
            node.value = value
    
    def search(self, key):
        """키로 값 찾기 - 평균 O(log N), 최악 O(N)"""
        return self._search_recursive(self.root, key)
    
    def _search_recursive(self, node, key):
        """재귀적으로 검색"""
        if node is None:
            return None
        
        if key == node.key:
            return node.value
        elif key < node.key:
            return self._search_recursive(node.left, key)
        else:
            return self._search_recursive(node.right, key)
    
    def contains(self, key):
        """키 존재 여부 확인"""
        return self.search(key) is not None
    
    def minimum(self, node=None):
        """최솟값 찾기"""
        if node is None:
            node = self.root
        
        while node.left is not None:
            node = node.left
        return node
    
    def maximum(self, node=None):
        """최댓값 찾기"""
        if node is None:
            node = self.root
        
        while node.right is not None:
            node = node.right
        return node
    
    # 순회 방법들
    def inorder_traversal(self):
        """중위 순회 (왼쪽-루트-오른쪽) - 오름차순 정렬"""
        result = []
        self._inorder_recursive(self.root, result)
        return result
    
    def _inorder_recursive(self, node, result):
        if node is not None:
            self._inorder_recursive(node.left, result)
            result.append((node.key, node.value))
            self._inorder_recursive(node.right, result)
    
    def preorder_traversal(self):
        """전위 순회 (루트-왼쪽-오른쪽)"""
        result = []
        self._preorder_recursive(self.root, result)
        return result
    
    def _preorder_recursive(self, node, result):
        if node is not None:
            result.append((node.key, node.value))
            self._preorder_recursive(node.left, result)
            self._preorder_recursive(node.right, result)
    
    def postorder_traversal(self):
        """후위 순회 (왼쪽-오른쪽-루트)"""
        result = []
        self._postorder_recursive(self.root, result)
        return result
    
    def _postorder_recursive(self, node, result):
        if node is not None:
            self._postorder_recursive(node.left, result)
            self._postorder_recursive(node.right, result)
            result.append((node.key, node.value))
    
    def display_tree(self, node=None, level=0):
        """트리 구조 시각화"""
        if node is None:
            node = self.root
        
        if node is not None:
            self.display_tree(node.right, level + 1)
            print('    ' * level + f'→ {node.key}')
            self.display_tree(node.left, level + 1)

# 사용 예제
print("=== BST 예제 1: 기본 동작 ===")
bst = BinarySearchTree()

# 삽입
numbers = [50, 30, 70, 20, 40, 60, 80]
for num in numbers:
    bst.insert(num)

print(f"삽입한 숫자: {numbers}")
print("\n트리 구조:")
bst.display_tree()

print(f"\n40 찾기: {bst.search(40)}")
print(f"100 찾기: {bst.search(100)}")


# 순회 방법들
print("\n\n=== BST 예제 2: 순회 방법 ===")
print(f"중위 순회 (오름차순): {[k for k, v in bst.inorder_traversal()]}")
print(f"전위 순회: {[k for k, v in bst.preorder_traversal()]}")
print(f"후위 순회: {[k for k, v in bst.postorder_traversal()]}")


# 실전 활용 예제: 단어 사전
class Dictionary:
    """BST를 이용한 단어 사전"""
    def __init__(self):
        self.tree = BinarySearchTree()
    
    def add_word(self, word, meaning):
        """단어 추가"""
        self.tree.insert(word.lower(), meaning)
        print(f"추가: {word} - {meaning}")
    
    def lookup(self, word):
        """단어 찾기"""
        meaning = self.tree.search(word.lower())
        if meaning:
            return meaning
        return "단어를 찾을 수 없습니다"
    
    def list_all_words(self):
        """모든 단어 알파벳 순으로 출력"""
        words = self.tree.inorder_traversal()
        print("\n사전 내용 (알파벳 순):")
        for word, meaning in words:
            print(f"  {word}: {meaning}")

print("\n\n=== BST 예제 3: 단어 사전 ===")
dictionary = Dictionary()

dictionary.add_word("apple", "사과")
dictionary.add_word("banana", "바나나")
dictionary.add_word("cherry", "체리")
dictionary.add_word("date", "대추야자")

dictionary.list_all_words()

print(f"\nbanana 검색: {dictionary.lookup('banana')}")
print(f"grape 검색: {dictionary.lookup('grape')}")


# 실전 활용 예제: 점수 순위 시스템
class ScoreBoard:
    """BST를 이용한 점수 관리"""
    def __init__(self):
        self.tree = BinarySearchTree()
    
    def add_score(self, player, score):
        """점수 추가"""
        self.tree.insert(score, player)
        print(f"{player}: {score}점")
    
    def get_top_player(self):
        """최고 점수 플레이어"""
        max_node = self.tree.maximum()
        return max_node.value, max_node.key
    
    def get_lowest_player(self):
        """최저 점수 플레이어"""
        min_node = self.tree.minimum()
        return min_node.value, min_node.key
    
    def show_rankings(self):
        """점수 순위 (내림차순)"""
        scores = self.tree.inorder_traversal()
        print("\n점수 순위:")
        for i, (score, player) in enumerate(reversed(scores), 1):
            print(f"  {i}위: {player} - {score}점")

print("\n\n=== BST 예제 4: 점수 순위 ===")
scoreboard = ScoreBoard()

scoreboard.add_score("Alice", 85)
scoreboard.add_score("Bob", 92)
scoreboard.add_score("Charlie", 78)
scoreboard.add_score("David", 95)
scoreboard.add_score("Eve", 88)

scoreboard.show_rankings()

top_player, top_score = scoreboard.get_top_player()
print(f"\n최고 점수: {top_player} ({top_score}점)")


# 균형 vs 불균형 트리 비교
print("\n\n=== BST 예제 5: 균형 트리의 중요성 ===")

print("균형 잡힌 트리:")
balanced_bst = BinarySearchTree()
for num in [50, 25, 75, 12, 37, 62, 87]:
    balanced_bst.insert(num)
balanced_bst.display_tree()

print("\n불균형 트리 (최악의 경우):")
unbalanced_bst = BinarySearchTree()
for num in [10, 20, 30, 40, 50, 60, 70]:  # 오름차순 삽입
    unbalanced_bst.insert(num)
unbalanced_bst.display_tree()

print("\n불균형 트리는 연결 리스트처럼 되어 성능이 O(N)으로 저하됩니다!")
print("실전에서는 AVL 트리나 Red-Black 트리 같은 자가 균형 트리를 사용합니다.")
```
